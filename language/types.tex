\specsection{Types}

\begin{grammar}
\nonterminaldef{type} \\
	\nonterminal{storage-class} \\
	\terminal{const} \nonterminal{storage-class} \\

\nonterminaldef{storage-class} \\
	\nonterminal{scalar-type} \\
	\nonterminal{struct-union-type} \\
	\nonterminal{tagged-union-type} \\
	\nonterminal{slice-array-type} \\
	\nonterminal{function-type} \\
	\nonterminal{alias-type} \\
	\nonterminal{string-type} \\

\nonterminaldef{scalar-type} \\
	\nonterminal{integer-type} \\
	\nonterminal{floating-type} \\
	\nonterminal{enum-type} \\
	\nonterminal{pointer-type} \\
	\terminal{rune} \\
	\terminal{bool} \\
	\terminal{void} \\
\end{grammar}

\specsubitem
A type defines the storage and semantics of a value. The attributes common to
all types are its \textit{size}, in octets; \textit{alignment}; its
\textit{constant} or \textit{mutable} nature; and its \textit{default value}.

\specsubitem
The implementation shall assign a globally unique ID to every type, in a
deterministic manner, such that several subsequent translation environments,
perhaps with different inputs, will obtain the same unique ID; and such that
distinct types shall have distinct IDs.

This specification details under what circumstances two types are equivalent to
one another, and thus shall have the same ID. For all types, any two types are
distinct if their type class, and their constant or mutable nature, are
distinct. Each type class may impose additional distinguishing characteristics
on their types, which are specified in their respective sections.

\specsubitem
Some types have an undefined size. This includes \nonterminal{function-type},
and some cases of \nonterminal{slice-array-type}.

\specsubitem
Some types have an undefined default value. If the default value of such a type
would be used, the implementation shall instead print a diagnostic message and
abort the translation phase.

\specsubitem
The \terminal{const} terminal, when used in a type specifier, enables the
constant flag and prohibits write operations on any value of that type. Types
without this attribute are considered mutable by default.

\specsubitem
A scalar type, also called a \textit{built-in} or \textit{primitive} type,
stores one value at a specific, pre-defined precision. Scalar types are the
most basic unit in the Hare type system. Other types are referred to as
\textit{aggregate types}, with the exception of alias types, which may be
either scalar or aggregate.

\specsubitem
The \textit{type class} of a type is defined for scalar types as the terminal
which reprents it, for example \terminal{i32}.

\specsubsection{Integer types}

\begin{grammar}
\nonterminaldef{integer-type}\oneof \\
	\terminal{i8}
	\terminal{i16}
	\terminal{i32}
	\terminal{i64}
	\terminal{u8}
	\terminal{u16}
	\terminal{u32}
	\terminal{u64}
	\terminal{int}
	\terminal{uint}
	\terminal{size}
	\terminal{uintptr}
	\terminal{char}
\end{grammar}

\specsubsubitem
Integer types represent an integer value at a specific precision. These values
are either \textit{signed} or \textit{unsigned}; which respectively
\textbf{are} and \textbf{are not} able to represent negative integers. Zero is
not negative. Integer types are considered \textit{numeric types}.

\specsubsubitem
Signed integer types shall be represented in two's compliment form; the
most-significant bit is the sign bit.

\specsubsubitem
The endianness (byte order) of integer types shall be implementation-defined.

\specsubsubitem
The precision of \nonterminal{i8}, \nonterminal{i16}, \nonterminal{i32},
\nonterminal{i64}, \nonterminal{u8}, \nonterminal{u16}, \nonterminal{u32}, and
\nonterminal{u64} are specified by the numeric suffix, which represents their
precision in bits. Of those, types prefixed with \terminal{u} are unsigned, and
those prefixed with \terminal{i} are signed.

\specsubsubitem
The precision of \nonterminal{int} and \nonterminal{uint} are
implementation-defined. \nonterminal{int} shall be signed, and
\nonterminal{uint} shall be unsigned. Both types shall be at least 32-bits in
precision. The precision in bits shall be a power of two.

\specsubsubitem
The precision of \nonterminal{size} is implementation-defined. It shall be
unsigned and shall be able to represent the maximum length of an array type.
The precision in bits shall be a power of two.

\specsubsubitem
The precision of \nonterminal{uintptr} is implementation-defined. It shall be
able to represent the value of any \nonterminal{pointer-type} as an integer.
It shall be unsigned.

\specsubsubitem
The \terminal{char} type is equivalent to the \terminal{u8} type. However, there
are limitations on its use, see \subsecref{Arithmetic expressions}
\& \subsecref{Access expressions}.

\specsubsubitem
The implementation is not required to provide the \terminal{char} type. If the
implementation does not support the \terminal{char} type, it must print a
diagnostic message and abort the translation phase for programs which attempt
to utilize it.

\specsubsubitem
The alignment of integer types shall be equal to their size in octets.

\specsubsubitem
The default value of an integer type shall be zero.

\informative{The following table is informative.}

\begin{tabular}{r | l l l}
Type & Size in bits & Minimum value & Maximum value \\
\hline
\nonterminal{i8} & 8 & -128 & 127 \\
\nonterminal{i16} & 16 & -32708 & 32707 \\
\nonterminal{i32} & 32 & -2147483648 & 2147483647 \\
\nonterminal{i64} & 64 & -9223372036854775808 & 9223372036854775807 \\
\nonterminal{u8} & 8 & 0 & 255 \\
\nonterminal{u16} & 16 & 0 & 65535 \\
\nonterminal{u32} & 32 & 0 & 4294967295 \\
\nonterminal{u64} & 64 & 0 & 18446744073709551615 \\
\nonterminal{int} & $\ge32$ & $\leq-2147483648$ & $\geq2147483647$ \\
\nonterminal{uint} & $\ge32$ & 0 & $\geq4294967295$ \\
\nonterminal{size} & $\ast$ & $\ast$ & $\ast$ \\
\nonterminal{uintptr} & $\ast$ & $+$ & $+$ \\
\end{tabular}

$\ast$ implementation-defined

$+$ undefined

\specsubsection{Floating point types}

\begin{grammar}
\nonterminaldef{floating-type} \\
	\terminal{f32} \\
	\terminal{f64} \\
\end{grammar}

\specsubsubitem
Floating-point types shall represent real numbers, i.e. numbers with both an
integer and fractional part. Floating point types are considered \textit{numeric
types}.

\specsubsubitem
The implementation shall represent floating-point types as IEEE 754-compatible
floating-point numbers. \terminal{f32} shall be stored in the binary32 format,
and \terminal{f64} shall use the binary64 format.

\specsubsubitem
The alignment of float types shall be equal to their size in octets.

\specsubsubitem
The default value of a float type shall be zero.

\specsubsection{Rune types}

\specsubsubitem
The \terminal{rune} type represents a Unicode codepoint, encoded as a
\nonterminal{u32}.

\specsubsection{Enum types}

\begin{grammar}
\nonterminaldef{enum-type} \\
	\terminal{enum} \terminal{\{} \nonterminal{enum-values} \terminal{\}} \\
	\terminal{enum} \nonterminal{integer-type} \terminal{\{} \nonterminal{enum-values} \terminal{\}} \\

\nonterminaldef{enum-values} \\
	\nonterminal{enum-value} \optional{\terminal{,}} \\
	\nonterminal{enum-value} \terminal{,} \nonterminal{enum-values} \\

\nonterminaldef{enum-value} \\
	\nonterminal{name} \\
	\nonterminal{name} \terminal{=} \nonterminal{simple-expression} \\
\end{grammar}

\specsubsubitem
Enum types, or \textit{enumerated types}, are a subset of integer types which
allows the user to assign a name to specific values.

\specsubsubitem
If \nonterminal{integer-type} is specified, the underlying storage of the enum
type is defined by the integer type specified. Otherwise, the underlying storage
is \terminal{int}.

\specsubsubitem
The size and alignment of an enum type is equivalent to those attributes of the
underlying integer type.

\specsubsubitem
If the \nonterminal{enum-value} does not specify a
\nonterminal{simple-expression}, the value assigned to that \nonterminal{name}
is equal to the last value assigned to an \nonterminal{enum-value} of this enum
type plus one. If no such previous value exists, zero is assigned.

\specsubsubitem
An implicitly assigned value shall not exceed the precision of the underlying
integer type; if it were to, a diagnostic message shall be shown instead per
\secref{Diagnostics}.

\specsubsubitem
\nonterminal{simple-expression}, if specified, shall be evaluated in the
translation environment and the resulting value shall be assigned to the
corresponding \nonterminal{enum-value}. The result type must be assignable to
the enum type's underlying integer type (ref \subsecref{Assignment}).

\specsubsubitem
\nonterminal{simple-expression} shall be limited to the
\secref{Translation compatible expression subset}.

\specsubsubitem
Each \nonterminal{enum-value}'s name shall be unique within the set of all
names of \nonterminal{enum-value}s of the \nonterminal{enum-type}. Otherwise, a
diagnostic message shall be printed and the translation phase shall be aborted.

\specsubsubitem
Two enum types shall be considered equivalent if all of these conditions are
met:

\begin{subsubitemize}
\item
The underlying storage type is the same.
\item
The set of assigned values and the names assigned to those values is the same,
regardless of their order.
\end{subsubitemize}

\specsubsubitem
The default value of an enum type is undefined.

\specsubsection{Pointer types}

\begin{grammar}
\nonterminaldef{pointer-type} \\
	\terminal{*} \nonterminal{type} \\
	\terminal{nullable} \terminal{*} \nonterminal{type} \\
\end{grammar}

\specsubsubitem
A pointer type is an indirect reference to an object of a secondary type. The
notation of a pointer type is a \terminal{*} prefix before the secondary type.

\specsubsubitem
A normal pointer type shall \textbf{always} refers to a valid secondary object.
A pointer type prefixed with \terminal{nullable} is considered a
\textit{nullable pointer type}, and shall refer to either valid secondary object
or to a special value called \textit{null}.

\specsubsubitem
The representation of a pointer type shall be implementation-defined, but it
shall have an implementation-defined length and alignment.

\specsubsubitem
The default value of a nullable pointer type is null. The default value of a
non-nullable pointer type is undefined.

\specsubsubitem
A pointer type shall be equivalent to another pointer type only if they share
the same secondary type and nullable status.

\specsubsection{Other primitive types}

\textbf{The bool type}

\specsubsubitem
The \terminal{bool} type represents a boolean value, which may have one of two
states: true or false.

\specsubsubitem
The boolean type representation shall be equivalent to the \terminal{uint} type.
Any non-zero value shall be interpreted as true, and zero shall be intepreted as
false.

\specsubsubitem
The default value of a boolean type is false.

\textbf{The null type}

\specsubsubitem
The \terminal{null} type shall have the same representation as a pointer and can
only store a specific, implementation-defined value (the \textit{null} value).

\specsubsubitem
There is no grammar for defining a value of type null, or a sub-type of null. It
is for internal use only, as the type of the \terminal{null} constant.

\textbf{The void type}

\specsubsubitem
The \terminal{void} type represents a non-existent value, and shall have no
storage.

\specsubsection{Struct and union types}

\begin{grammar}
\nonterminaldef{struct-union-type} \\
	\terminal{struct} \terminal{\{} \nonterminal{struct-union-fields} \terminal{\}} \\
	\terminal{union} \terminal{\{} \nonterminal{struct-union-fields} \terminal{\}} \\

\nonterminaldef{struct-union-fields} \\
	\nonterminal{struct-union-field} \optional{\terminal{,}} \\
	\nonterminal{struct-union-field} \terminal{,} \nonterminal{struct-union-fields} \\

\nonterminaldef{struct-union-field} \\
	\nonterminal{name} \terminal{:} \nonterminal{type} \\
	\nonterminal{struct-union-type} \\
	\nonterminal{identifier} \\
\end{grammar}

\specsubsubitem
The \textit{struct type} and \textit{union type} are \textit{aggregate types},
which \textit{collect} multiple types, names them, and assigns them
\textit{offset}s within their storage area. A struct type stores each value at a
different offset; a union type stores all of its values at the the same offset.
A type defined with the \terminal{struct} terminal is a struct type and uses the
struct type class; if the \terminal{union} terminal is used the type is a union
type with the union type class.

\specsubsubitem
The \nonterminal{struct-union-fields} list denotes, in order, the subvalues
which are collected by a struct or union, and potentially assigns a
\nonterminal{name} to each.

\specsubsubitem
For a struct type, the offset of each field is equal to the minimum
\textit{aligned} offset which would meet the alignment requirements of the
field's type and which is greater than the offset of the previous field plus the
size of the previous field. The implementation shall add \textit{padding} to
meet the alignment requirements of struct fields. For a union type, the offset
of all members is zero.

\specsubsubitem
A union type's size is the maximum size among its fields. A struct type's size
is the sum of the sizes of its fields plus any necessary padding.

\specsubsubitem
The default value of a struct or union type shall be defined as a value whose
fields assume the default values of their respective types. The default
value of any fields which have overlapping storage (as defined by the bounds of
their offset and their size) shall be undefined.

\specsubsubitem
If the \nonterminal{struct-union-type} form of \nonterminal{struct-union-field}
is given, the parent type shall collect the fields of the child type as its
own. The offset of each field within the child type shall be the sum of the
offset within the child type and the offset the child type occupies within the
parent struct. The \nonterminal{identifier} form shall be interpreted in the same
manner as a \nonterminal{struct-union-type} if it refers to a type alias of a
struct or union type, otherwise a diagnostic message shall be printed and the
translation phase shall abort.

Forward references: \subsecref{Type aliases}

\specsubsubitem
A struct or union type shall be equivalent to another struct or union type if
their fields are of equivalent name, type, and offset, without respect to the
order of their appearance in the program source.

\informative{The following types are equivalent: \\
\code{struct \{ a: int, b: int \}} \\
\code{struct \{ a: int, struct \{ b: int \} \}}}

\specsubsubitem
Each field name (including names of embedded fields) shall be unique within the
set of all field names of the \nonterminal{struct-union-type}.

\specsubsection{Tagged union types}

\begin{grammar}
\nonterminaldef{tagged-union-type} \\
	\terminal{(} \nonterminal{tagged-types} \terminal{)} \\

\nonterminaldef{tagged-types} \\
	\nonterminal{type} \terminal{|} \nonterminal{type} \optional{\terminal{|}}\\
	\nonterminal{type} \terminal{|} \nonterminal{tagged-types} \\
\end{grammar}

\specsubsubitem
A tagged union stores a value of \textbf{one} of its constituent types, as well
as a \textit{tag} which indicates which of the constituent types is selected.
The constituent types is defined by \nonterminal{tagged-types}.

\specsubsubitem
The representation of a tagged union shall be a \terminal{uint}, in which the
tag value is stored, followed by sufficient space to store any of the possible
constituent types. Padding shall be inserted between the tag and the value area
and after the value area if necessary to meet the maximum alignment among the
tagged union members and the \terminal{uint} field.

\specsubsubitem
The tag value shall be the type ID of the type which is selected from the
constituent types. This value shall be stored at the \terminal{uint} field and
shall indicate which type is stored in the value area.

\informative{It follows that the types \code{(A | B)} and \code{(B | A)}
are equivalent.}

\specsubsubitem
The alignment of a tagged union type shall be the alignment of the
\terminal{uint} type or the maximum alignment of the constituent types,
whichever is greater.

\specsubsubitem
The size of a tagged union type shall be the maximum size of its constituent
types, plus the size of the \terminal{uint} type, plus any padding added per
\subsubitemref{Tagged union types}{2}.

\specsubsubitem
If a member type among \nonterminal{tagged-types} is a tagged union type, it
shall be reduced such that nested tagged union type is replaced with its
constitent types in the parent union.

\informative{The types \code{(A | (B | (C | D)))} and
\code{(A | B | C | D)} are equivalent.}

\specsubsubitem
The default value of a tagged union type is undefined.

\specsubsubitem
A tagged union type shall be equivalent to another tagged union type if they
share the same set of secondary types, without regard to order, and considering
the secondary types of nested tagged unions as members of the set of their
parent's secondary types.

\specsubsection{Slice and array types}

\begin{grammar}
\nonterminaldef{slice-array-type} \\
	\terminal{[} \terminal{]} \nonterminal{type} \\
	\terminal{[} \nonterminal{simple-expression} \terminal{]} \nonterminal{type} \\
	\terminal{[} \terminal{*} \terminal{]} \nonterminal{type} \\
	\terminal{[} \terminal{\_} \terminal{]} \nonterminal{type} \\
\end{grammar}

\specsubsubitem
An \textit{array type} stores one or more items of a uniform secondary type.
The number of items stored in an array type is an attribute of the array type
and is specified during the translation phase. The secondary type shall have a
definite, nonzero size.

\specsubsubitem
The \nonterminal{simple-expression} representation is used for array types of a
determinate length, that is, with a determinate number of items. Such arrays are
\textit{bounded}. The \nonterminal{simple-expression} must evaluate to a
positive integer value, and shall be limited to the \subsecref{Translation
compatible expression subset}.

\specsubsubitem
An array type may be \textit{unbounded}, in which case the number of items is
not known. The \terminal{*} representation indicates an array of this type.

\specsubsubitem
An array may be bounded, but infer its size from context, using the
\terminal{\_} representation. Such an array is said to be
\textit{context-defined}.

\specsubsubitem
An array type may be \textit{expandable}. This state is not represented in the
type grammar, and is only used in specific situations. Array types are presumed
to be non-expandable unless otherwise specified.

\specsubsubitem
The representation of an \textit{array type} shall be the items concatenated one
after another, such that the offset of the \textit{N}th item is determined by
the equation $N \times S$, where \textit{S} is the size of the secondary type.

\specsubsubitem
A \textit{slice type} stores a pointer to an unbounded array type, with a given
\textit{capacity}, and \textit{length}, which respectively refer to the number
of items that the unbounded array \textbf{may} store without re-allocation, and
the number of items which are \textbf{currently valid}. The representation with
no lexical elements between \terminal{[} and \terminal{]} indicates a slice
type.

\specsubsubitem
The representation of a slice type shall be equivalent to the following struct
type:

\begin{codesample}
struct {
	data: nullable *[*]type,
	length: size,
	capacity: size,
}
\end{codesample}

The type of the \textit{data} field shall be a pointer to an unbounded array of
the secondary type.

\specsubsubitem
The alignment of an array type shall be equivalent to the alignment of the
underlying type. The alignment of a slice type shall be equivalent to the
alignment of the \terminal{size} type or \subsecref{Pointer types}, whichever is
greater.

\specsubsubitem
The size of a bounded array type shall be equal to $N \times S$, where N is the
number of items and S is the size of the underlying type. The size of an
unbounded array is undefined. The size of a slice type shall be equal to the
size of the struct type defined by \subsubitemref{Slice and array types}{6}.

\specsubsubitem
The default value of an array type shall be equal to all of its members set to
the default value of the underlying type. If the default value of the
underlying type is undefined, the default value of the array type is undefined.

\specsubsubitem
The default value of a slice type shall have the capacity and length fields set
to zero and the data field set to null.

\specsubsubitem
An array type shall be equivalent to another array type only if its length and
secondary types are equivalent. A slice type shall only be equivalent to a
slice type with the same secondary type.

\specsubsection{String types}

\begin{grammar}
\nonterminaldef{string-type} \\
	\terminal{str} \\
\end{grammar}

\specsubsubitem
A string stores a reference to a sequence of Unicode codepoints, encoded as
UTF-8, along with its \textit{length} and \textit{capacity}. The length and
capacity are measured in octets, rather than codepoints.

\specsubsubitem
The UTF-8 data shall end with a NUL terminator. The length and capacity fields
will not include this additional octet.

\specsubsubitem
The representation of the string type shall be equivalent to the following
struct type:

\begin{codesample}
struct {
	data: *[*]const u8,
	length: size,
	capacity: size,
}
\end{codesample}

\specsubsection{Function types}

\begin{grammar}
\nonterminaldef{function-type} \\
	\optional{\nonterminal{fntype-attr}} \terminal{fn} \nonterminal{prototype} \\

\nonterminaldef{prototype} \\
	\terminal{(} \optional{\nonterminal{parameter-list}} \terminal{)} \nonterminal{type} \\

\nonterminaldef{fntype-attr} \\
	\terminal{@noreturn} \\

\nonterminaldef{parameter-list} \\
	\nonterminal{parameters} \optional{\terminal{,}} \\
	\nonterminal{parameters} \terminal{...} \optional{\terminal{,}} \\
	\nonterminal{parameters} \terminal{,} \terminal{...} \optional{\terminal{,}} \\

\nonterminaldef{parameters} \\
	\nonterminal{parameter} \\
	\nonterminal{parameters} \terminal{,} \nonterminal{parameter} \\

\nonterminaldef{parameter} \\
	\nonterminal{name} \terminal{:} \nonterminal{type} \\
	\nonterminal{type} \\
\end{grammar}

\specsubsubitem
Function types represent a procedure which may be completed in the
\secref{Execution environment} to obtain a result and possibly cause side
effects (see \subsubitemref{Program execution}{1}).

\specsubsubitem
If the \terminal{@noreturn} form of \nonterminal{fntype-attr} is specified in
the \nonterminal{function-parameters}, the \nonterminal{type} shall be
\terminal{void} and the specified function shall not return to its caller.

\specsubsubitem
The attributes of a function type are its \textit{result type} and
\textit{input parameters}. A function type must have one result type (which may
be \terminal{void}), and zero or more parameters. Each \nonterminal{name} shall
be unique.

\specsubsubitem
If the second form of \nonterminal{parameters} is usesd, the final parameter of
the function type uses \textit{Hare-style variadism}. If the third form is
used, the function uses \textit{C-style variadism}. The variadism of a function
type affects the calling semantics for that function.

\begin{codesample}
// Hare-style variadism:
fn(x: int, y: int, z: int...)

// C-style variadism:
fn(x: int, y: int, ...)
\end{codesample}

Forward references: \subsecref{Call expressions}

\specsubsubitem
The implementation is not required to support C-style variadism. If the
implementation does not support C-style variadism, it must print a diagnostic
message and abort the translation environment for programs which attempt to
utilize it.

\specsubsubitem
The type of a parameter which uses Hare-style variadism shall be a slice of the
specified type.

\informative{Therefore, in the case of \code{fn(x: int...)}, the type of x
shall be \code{const []int}.}

\specsubsubitem
The size, alignment, default value, and storage semantics of function types is
undefined. All function types shall be \terminal{const}, without regard to the
use of \terminal{const} in the type description.

\specsubsubitem
The function's result type, list of parameter types (in order), its variadism,
and \terminal{@noreturn} status, are distinct characteristics of the function
type, for the purpose of determining equivalency.

\specsubsection{Type aliases}

\begin{grammar}
\nonterminaldef{alias-type} \\
	\nonterminal{identifier} \\

\nonterminaldef{unwrapped-alias} \\
	\terminal{...} \nonterminal{identifier} \\
\end{grammar}

\specsubsubitem
A type alias assigns an \nonterminal{identifier} a unique type which is an
alias for another type.

\informative{The grammar for an \nonterminal{alias-type} does not specify the
underlying type. The underlying type is specified at the time it is declared,
see \secref{Declarations}.}

\specsubsubitem
A type alias shall have the same storage, alignment, size, default value, and
semantics as its underlying type.

\specsubsubitem
Each type alias (uniquely identified by its \nonterminal{identifier}) shall be
a unique type, even if it shares its underlying type with another type alias.

\specsubsubitem
The \terminal{...} operator shall \textit{unwrap} the type alias, and shall
case the statement to refer to the underlying type rather than the type alias
itself.

\informative{This notably affects the relationship between type aliases and
tagged unions. In the following example, union\_a and union\_b have different
storage semantics, the former being a tagged union of two other tagged unions,
and the latter being reduced to a single tagged union.}

\begin{codesample}
type signed = (i8 | i16 | i32 | i64 | int);
type unsigned = (u8 | u16 | u32 | u64 | uint);
type union_a = (signed | unsigned);
type union_b = (...signed | ...unsigned);
\end{codesample}
