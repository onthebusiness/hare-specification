\specsection{Types}

\begin{grammar}
\nonterminaldef{type} \\
	\nonterminal{scalar-type} \\
	\nonterminal{struct-union-type} \\
	\nonterminal{tagged-union-type} \\
	\nonterminal{slice-array-type} \\
	\nonterminal{function-type} \\
	\nonterminal{alias-type} \\
	\terminal{const} \nonterminal{type} \\

\nonterminaldef{scalar-type} \\
	\nonterminal{integer-type} \\
	\nonterminal{floating-type} \\
	\nonterminal{enum-type} \\
	\nonterminal{pointer-type} \\
	\terminal{bool} \\
	\terminal{null} \\
	\terminal{void} \\
\end{grammar}

\specsubitem
A type defines the storage and semantics of a value. The attributes common to
all types are its \textit{size}, in octets; \textit{alignment}; and its
\textit{constant} or \textit{mutable} nature.

\specsubitem
Some types have an undefined size. This includes \nonterminal{function-type},
and some cases of \nonterminal{slice-array-type}.

\specsubitem
The \terminal{const} terminal, when used in a type specifier, enables the
constant flag and prohibits write operations on any value of that type. Types
without this attribute are considered mutable by default.

\specsubitem
A scalar type, also called a \textit{built-in} or \textit{primitive} type,
stores one value at a specific, pre-defined precision. Scalar types are the
most basic unit in the Hare type system. Other types are referred to as
\textit{aggregate types}, with the exception of alias types, which may be
either scalar or aggregate.

\specsubsection{Integer types}

\begin{grammar}
\nonterminaldef{integer-type}\oneof \\
	\terminal{i8}
	\terminal{i16}
	\terminal{i32}
	\terminal{i64}
	\terminal{u8}
	\terminal{u16}
	\terminal{u32}
	\terminal{u64}
	\terminal{int}
	\terminal{uint}
	\terminal{size}
	\terminal{uintptr}
\end{grammar}

\specsubsubitem
Integer types represent an integer value at a specific precision. These values
are either \textit{signed} or \textit{unsigned}; which respectively
\textbf{are} and \textbf{are not} able to represent negative integers. Zero is
not negative.

\specsubsubitem
Signed integer types shall be represented in two's compliment form; the
most-significant bit is the sign bit.

\specsubsubitem
The endianness (byte order) of integer types shall be implementation-defined.

\specsubsubitem
The precision of \nonterminal{i16}, \nonterminal{i32}, \nonterminal{i64},
\nonterminal{u8}, \nonterminal{u16}, \nonterminal{u32}, and \nonterminal{u64}
are specified by the numeric suffix, which represents their precision in bits.
Of those, types prefixed with \terminal{u} are unsigned, and those prefixed
with \terminal{i} are signed.

\specsubsubitem
The precision of \nonterminal{int} and \nonterminal{uint} are
implementation-defined. \nonterminal{int} shall be signed, and
\nonterminal{uint} shall be unsigned. Both types shall be at least 32-bits in
precision. The precision in bits shall be a power of two.

\specsubsubitem
The precision of \nonterminal{size} is implementation-defined. It shall be
unsigned and shall be able to represent the maximum length of an array type.
The precision in bits shall be a power of two.

\specsubsubitem
The precision of \nonterminal{uintptr} is implementation-defined. It shall be
able to represent the value of any \nonterminal{pointer-type} as an integer.
The signedness of this type is undefined.

\specsubsubitem
The alignment of integer types shall be equal to their size in octets.

\informative{The following table is informative.}

\begin{tabular}{r | l l l}
Type & Size in bits & Minimum value & Maximum value \\
\hline
\nonterminal{i8} & 8 & -128 & 127 \\
\nonterminal{i16} & 16 & -32708 & 32707 \\
\nonterminal{i32} & 32 & -2147483648 & 2147483647 \\
\nonterminal{i64} & 64 & -9223372036854775808 & 9223372036854775807 \\
\nonterminal{u8} & 8 & 0 & 255 \\
\nonterminal{u16} & 16 & 0 & 65535 \\
\nonterminal{u32} & 32 & 0 & 4294967295 \\
\nonterminal{u64} & 64 & 0 & 18446744073709551615 \\
\nonterminal{int} & $\ge32$ & $\leq-2147483648$ & $\geq2147483647$ \\
\nonterminal{uint} & $\ge32$ & 0 & $\geq4294967295$ \\
\nonterminal{size} & $\ast$ & $\ast$ & $\ast$ \\
\nonterminal{uintptr} & $\ast$ & $+$ & $+$ \\
\end{tabular}

$\ast$ implementation-defined

$+$ undefined

\specsubsection{Floating point types}

\begin{grammar}
\nonterminaldef{floating-type} \\
	\terminal{f32} \\
	\terminal{f64} \\
\end{grammar}

\specsubsubitem
Floating-point types shall represent real numbers, i.e. numbers with both an
integer and fractional part.

\specsubsubitem
The implementation shall represent floating-point types as IEEE 754-compatible
floating-point numbers. \terminal{f32} shall be stored in the binary32 format,
and \terminal{f64} shall use the binary64 format.

\specsubsubitem
The alignment of float types shall be equal to their size in octets.

\specsubsection{Enum types}

\begin{grammar}
\nonterminaldef{enum-type} \\
	\terminal{enum} \terminal{\{} \nonterminal{enum-values} \terminal{\}} \\
	\terminal{enum} \nonterminal{integer-type} \terminal{\{} \nonterminal{enum-values} \terminal{\}} \\

\nonterminaldef{enum-values} \\
	\nonterminal{enum-value} \optional{\terminal{,}} \\
	\nonterminal{enum-value} \terminal{,} \nonterminal{enum-values} \\

\nonterminaldef{enum-value} \\
	\nonterminal{name} \\
	\nonterminal{name} \terminal{=} \nonterminal{simple-expression} \\
\end{grammar}

\specsubsubitem
Enum types, or \textit{enumerated types}, are a subset of integer types which
allows the user to assign a name to specific values.

\specsubsubitem
If \nonterminal{integer-type} is specified, the underlying storage of the enum
type is defined by the integer type specified. Otherwise, the underlying storage
is \terminal{int}.

\specsubsubitem
The size and alignment of an enum type is equivalent to those attributes of the
underlying integer type.

\specsubsubitem
If the \nonterminal{enum-value} does not specify a
\nonterminal{simple-expression}, the value assigned to that \nonterminal{name}
is equal to the last value assigned to an \nonterminal{enum-value} of this enum
type plus one. If no such previous value exists, the zero is assigned.

\specsubsubitem
An implicitly assigned value shall not exceed the precision of the underlying
integer type; if it were to, a diagnostic message shall be shown instead per
\secref{Diagnostics}.

\specsubsubitem
\nonterminal{simple-expression}, if specified, shall be evaluated in the
translation environment and the resulting value shall be assigned to the
corresponding \nonterminal{enum-value}. The result type must be assignable to
the enum type's underlying integer type (ref \subsecref{Assignment
expressions}).

\specsubsubitem
\nonterminal{simple-expression} shall be limited to the
\subsecref{Translation compatible expression subset}.

\specsubsection{Pointer types}

\specsubsection{Other primitive types}

\specsubsection{Struct and union types}

\specsubsection{Tagged union types}

\specsubsection{Slice and array types}

\specsubsection{Function types}

\specsubsection{Type aliases}
