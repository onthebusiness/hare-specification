\specsection{Types}

\begin{grammar}

\nonterminaldef{type} \\
	\optional{\terminal{const}} \optional{\terminal{!}} \nonterminal{storage-class} \\

\nonterminaldef{storage-class} \\
	\nonterminal{scalar-type} \\
	\nonterminal{struct-union-type} \\
	\nonterminal{tuple-type} \\
	\nonterminal{tagged-union-type} \\
	\nonterminal{slice-array-type} \\
	\nonterminal{function-type} \\
	\nonterminal{alias-type} \\
	\nonterminal{unwrapped-alias} \\
	\nonterminal{string-type} \\

\nonterminaldef{scalar-type} \\
	\nonterminal{integer-type} \\
	\nonterminal{floating-type} \\
	\nonterminal{enum-type} \\
	\nonterminal{pointer-type} \\
	\terminal{rune} \\
	\terminal{bool} \\
	\terminal{valist} \\
	\terminal{void} \\
\end{grammar}

\specsubitem
A type defines the storage and semantics of a value. The attributes common to
all types are its \textit{size}, in octets; \textit{alignment}; its
\textit{constant} or \textit{mutable} nature; its \textit{error flag}, or lack
thereof; and its \textit{default value}, which may be undefined.

\specsubitem
The implementation shall assign a globally unique ID to every type, in a
deterministic manner, such that several subsequent translation environments,
perhaps with different inputs, will obtain the same unique ID; and such that
distinct types shall have distinct IDs.

This specification details under what circumstances two types are equivalent to
one another, and thus shall have the same ID. For all types, any two types are
distinct if their type class, their constant or mutable nature, and their error
flag or lack thereof, are distinct. Each type class may impose additional
distinguishing characteristics on their types, which are specified in their
respective sections.

\specsubitem
Some types have an undefined size. This includes \nonterminal{function-type},
and some cases of \nonterminal{slice-array-type}.

\specsubitem
Some types have an undefined default value. If the default value of such a type
would be used, the implementation shall instead print a diagnostic message and
abort the translation phase.

\specsubitem
The \terminal{const} terminal, when used in a type specifier, enables the
constant flag and prohibits write operations on any value of that type. Types
without this attribute are considered mutable by default.

\specsubitem
The \terminal{!} terminal, when used in a type specifier, sets the
error flag for this type.

\specsubitem
A scalar type, also called a \textit{built-in} or \textit{primitive} type,
stores one value at a specific, pre-defined precision. Scalar types are the
most basic unit in the Hare type system. Other types are referred to as
\textit{aggregate types}, with the exception of alias types, which may be
either scalar or aggregate.

\specsubitem
The \textit{type class} of a type is defined for scalar types as the terminal
which represents it, for example \terminal{i32}.

\specsubsection{Integer types}

\begin{grammar}
\nonterminaldef{integer-type}\oneof \\
	\terminal{i8}
	\terminal{i16}
	\terminal{i32}
	\terminal{i64}
	\terminal{u8}
	\terminal{u16}
	\terminal{u32}
	\terminal{u64}
	\terminal{int}
	\terminal{uint}
	\terminal{size}
	\terminal{uintptr}
	\terminal{char}
\end{grammar}

\specsubsubitem
Integer types represent an integer value at a specific precision. These values
are either \textit{signed} or \textit{unsigned}; which respectively
\textbf{are} and \textbf{are not} able to represent negative integers. Zero is
not negative. Integer types are considered \textit{numeric types}.

\specsubsubitem
Signed integer types shall be represented in two's complement form.

\specsubsubitem
The endianness (byte order) of integer types shall be implementation-defined.

\specsubsubitem
The precision of \nonterminal{i8}, \nonterminal{i16}, \nonterminal{i32},
\nonterminal{i64}, \nonterminal{u8}, \nonterminal{u16}, \nonterminal{u32}, and
\nonterminal{u64} are specified by the numeric suffix, which represents their
precision in bits. Of those, types prefixed with \terminal{u} are unsigned, and
those prefixed with \terminal{i} are signed.

\specsubsubitem
The precision of \nonterminal{int} and \nonterminal{uint} are
implementation-defined. \nonterminal{int} shall be signed, and
\nonterminal{uint} shall be unsigned. Both types shall be at least 32-bits in
precision. The precision in bits shall be a power of two.

\specsubsubitem
The precision of \nonterminal{size} is implementation-defined. It shall be
unsigned and shall be able to represent the maximum length of an array type.
The precision in bits shall be a power of two.

\specsubsubitem
The precision of \nonterminal{uintptr} is implementation-defined. It shall be
able to represent the value of any \nonterminal{pointer-type} as an integer.
It shall be unsigned.

\specsubsubitem
The \terminal{char} type is equivalent to the \terminal{u8} type. However, there
are limitations on its use, see \subsecref{Arithmetic expressions}
\& \subsecref{Access expressions}.

\specsubsubitem
The implementation is not required to provide the \terminal{char} type. If the
implementation does not support the \terminal{char} type, it must print a
diagnostic message and abort the translation phase for programs which attempt
to utilize it.

\specsubsubitem
The alignment of integer types shall be equal to their size in octets.

\specsubsubitem
The default value of an integer type shall be zero.

\informative{The following table is informative.}

\begin{tabular}{r | l l l}
Type & Size in bits & Minimum value & Maximum value \\
\hline
\nonterminal{i8} & 8 & -128 & 127 \\
\nonterminal{i16} & 16 & -32708 & 32707 \\
\nonterminal{i32} & 32 & -2147483648 & 2147483647 \\
\nonterminal{i64} & 64 & -9223372036854775808 & 9223372036854775807 \\
\nonterminal{u8} & 8 & 0 & 255 \\
\nonterminal{u16} & 16 & 0 & 65535 \\
\nonterminal{u32} & 32 & 0 & 4294967295 \\
\nonterminal{u64} & 64 & 0 & 18446744073709551615 \\
\nonterminal{int} & $\ge32$ & $\leq-2147483648$ & $\geq2147483647$ \\
\nonterminal{uint} & $\ge32$ & 0 & $\geq4294967295$ \\
\nonterminal{size} & $\ast$ & $\ast$ & $\ast$ \\
\nonterminal{uintptr} & $\ast$ & $+$ & $+$ \\
\end{tabular}

$\ast$ implementation-defined

$+$ undefined

\specsubsection{Floating point types}

\begin{grammar}
\nonterminaldef{floating-type} \\
	\terminal{f32} \\
	\terminal{f64} \\
\end{grammar}

\specsubsubitem
Floating-point types shall represent real numbers, i.e. numbers with both an
integer and fractional part. Floating point types are considered \textit{numeric
types}.

\specsubsubitem
The implementation shall represent floating-point types as IEEE 754-compatible
floating-point numbers. \terminal{f32} shall be stored in the binary32 format,
and \terminal{f64} shall use the binary64 format.

\specsubsubitem
The alignment of float types shall be equal to their size in octets.

\specsubsubitem
The default value of a float type shall be zero.

\specsubsection{Rune types}

\specsubsubitem
The \terminal{rune} type represents a Unicode codepoint, encoded as a
\nonterminal{u32}.

\specsubsection{Flexible constant types}

\specsubsubitem
Flexible constant types represent floating, integer, or rune constants whose
result type has not been determined. The size and alignment of flexible constant
types shall be undefined. \terminal{iconst} and \terminal{fconst} are considered
numeric types.

\specsubsubitem
An \terminal{iconst} shall have maximum and minimum values associated with it,
which shall be represented as signed integers with sufficient precision to store
an \terminal{i64}. The minimum value shall represent the smallest integer
constant which has this result type, and the maximum value shall represent the
largest. The minimum shall always be less than or equal to the maximum, and the
type shall be considered unsigned if and only if the minimum is greater than or
equal to 0.

\specsubsubitem
The \textit{default type} for \terminal{fconst} shall be \terminal{f64}. The
default type for iconst shall be \terminal{int} if the maximum and minimum are
within \terminal{int}'s range, and \terminal{i64} otherwise. The default type
for \terminal{rconst} shall be \terminal{rune}.

\specsubsubitem
A flexible constant type may be \textit{lowered} to a different type by the
\secref{Flexible constant promotion algorithm}, causing all instances of that
type within the translation environment to be replaced by the new type. If a
flexible constant type hasn't been lowered by the end of the translation phase,
it shall be lowered to its default type.

\specsubsubitem
There is no grammar for defining flexible constant types. They are for internal
use only, as the result type of \nonterminal{integer-constant},
\nonterminal{floating-constant}, and \nonterminal{rune-constant}.

\specsubsubitem
Each constant with a flexible result shall have a distinct type.

\specsubsubitem
If a flexible constant type is embedded within another type, it shall first be
lowered to its default type.

\informative{This is intended to ease implementation, in order to prevent a
type's ID, size, and alignment from changing partway through the translation
phase.}

\specsubsection{Enum types}

\begin{grammar}
\nonterminaldef{enum-type} \\
	\terminal{enum} \terminal{\{} \nonterminal{enum-values} \terminal{\}} \\
	\terminal{enum} \nonterminal{integer-type} \terminal{\{} \nonterminal{enum-values} \terminal{\}} \\

\nonterminaldef{enum-values} \\
	\nonterminal{enum-value} \optional{\terminal{,}} \\
	\nonterminal{enum-value} \terminal{,} \nonterminal{enum-values} \\

\nonterminaldef{enum-value} \\
	\nonterminal{name} \\
	\nonterminal{name} \terminal{=} \nonterminal{expression} \\
\end{grammar}

\specsubsubitem
Enum types, or \textit{enumerated types}, are a subset of integer types which
allows the user to assign a name to specific values. Enum types are considered
\textit{numeric types}.

\specsubsubitem
If \nonterminal{integer-type} is specified, the underlying storage of the enum
type is defined by the integer type specified. Otherwise, the underlying storage
is \terminal{int}.

\specsubsubitem
The size and alignment of an enum type is equivalent to those attributes of the
underlying integer type.

\specsubsubitem
If the \nonterminal{enum-value} does not specify a \nonterminal{expression},
the value assigned to that \nonterminal{name} is equal to the last value
assigned to an \nonterminal{enum-value} of this enum type plus one. If no such
previous value exists, zero is assigned.

\specsubsubitem
An implicitly assigned value shall not exceed the precision of the underlying
integer type; if it were to, a diagnostic message shall be shown instead per
\secref{Diagnostics}.

\specsubsubitem
\nonterminal{expression}, if specified, shall be evaluated in the translation
environment and the resulting value shall be assigned to the corresponding
\nonterminal{enum-value}. The \nonterminal{expression} shall be provided the
enum's type's underlying integer type as a type hint. The result type must be
assignable to the enum type's underlying integer type (ref
\subsecref{Assignment}).

\specsubsubitem
A temporary scope shall be allocated while loading an enum type, and each value
name, in order, shall be made available to that scope.

\informative{This allows the \nonterminal{expression} for each value to refer
to previously declared values.}

\specsubsubitem
\nonterminal{expression} shall be limited to the
\secref{Translation compatible expression subset}.

\specsubsubitem
Each \nonterminal{enum-value}'s name shall be unique within the set of all
names of \nonterminal{enum-value}s of the \nonterminal{enum-type}. Otherwise, a
diagnostic message shall be printed and the translation phase shall be aborted.

\specsubsubitem
Two enum types shall be considered equivalent if all of these conditions are
met:

\begin{subsubitemize}
\item
The underlying storage type is the same.
\item
The set of assigned values and the names assigned to those values is the same,
regardless of their order.
\end{subsubitemize}

\specsubsubitem
The default value of an enum type is undefined.

\specsubsection{Pointer types}

\begin{grammar}
\nonterminaldef{pointer-type} \\
	\terminal{*} \nonterminal{type} \\
	\terminal{nullable} \terminal{*} \nonterminal{type} \\
\end{grammar}

\specsubsubitem
A pointer type is an indirect reference to an object of a secondary type. The
notation of a pointer type is a \terminal{*} prefix before the secondary type.

\specsubsubitem
A normal pointer type shall \textbf{always} refers to a valid secondary object.
A pointer type prefixed with \terminal{nullable} is considered a
\textit{nullable pointer type}, and shall refer to either a valid secondary object
or to a special value called \textit{null}.

\specsubsubitem
The representation of a pointer type shall be implementation-defined, but it
shall have an implementation-defined length and alignment.

\specsubsubitem
The default value of a nullable pointer type is null. The default value of a
non-nullable pointer type is undefined.

\specsubsubitem
A pointer type shall be equivalent to another pointer type only if they share
the same secondary type and nullable status.

\specsubsection{Other primitive types}

\textbf{The bool type}

\specsubsubitem
The \terminal{bool} type represents a boolean value, which may have one of two
states: true or false.

\specsubsubitem
The boolean type representation shall be equivalent to the \terminal{uint} type.
Any non-zero value shall be interpreted as true, and zero shall be intepreted as
false.

\specsubsubitem
The default value of a boolean type is false.

\textbf{The null type}

\specsubsubitem
The \terminal{null} type shall have the same representation as a pointer and can
only store a specific, implementation-defined value (the \textit{null} value).

\specsubsubitem
There is no grammar for defining a value of type null, or a sub-type of null. It
is for internal use only, as the type of the \terminal{null} constant.

\textbf{The valist type}

\specsubsubitem
The \terminal{valist} type is provided for compatibility with the C programming
language as specified by ISO/IEC 9899:2011. Implementation support is optional:
implementations which do not provide C ABI compatibility must parse this type,
print a diagnostic message, and abort.

\specsubsubitem
The size and alignment of the \terminal{valist} shall be an
implementation-defined value which shall be at least eight, and shall be
divisible by eight.

\specsubsubitem
Copying a \terminal{valist} value via an \subsecref{Assignment} expression
shall be equivalent to the "va\_copy" macro described by ISO/IEC 9899:2011
section 7.16.1.2.

\textbf{The void type}

\specsubsubitem
The \terminal{void} type represents a non-existent value, and shall have no
storage.

\specsubsection{Struct and union types}

\begin{grammar}
\nonterminaldef{struct-union-type} \\
	\terminal{struct} \terminal{\{} \nonterminal{struct-union-fields} \terminal{\}} \\
	\terminal{union} \terminal{\{} \nonterminal{struct-union-fields} \terminal{\}} \\

\nonterminaldef{struct-union-fields} \\
	\nonterminal{struct-union-field} \optional{\terminal{,}} \\
	\nonterminal{struct-union-field} \terminal{,} \nonterminal{struct-union-fields} \\

\nonterminaldef{struct-union-field} \\
	\optional{offset-specifier} \nonterminal{name} \terminal{:} \nonterminal{type} \\
	\optional{offset-specifier} \nonterminal{struct-union-type} \\
	\optional{offset-specifier} \nonterminal{identifier} \\

\nonterminaldef{offset-specifier} \\
	\terminal{@offset} \terminal{(} \nonterminal{expression} \terminal{)}
\end{grammar}

\specsubsubitem
The \textit{struct type} and \textit{union type} are \textit{aggregate types},
which \textit{collect} multiple types, name them, and assign them
\textit{offset}s within their storage area. A struct type stores each value at a
different offset; a union type stores all of its values at the the same offset.
A type defined with the \terminal{struct} terminal is a struct type and uses the
struct type class; if the \terminal{union} terminal is used the type is a union
type with the union type class.

\specsubsubitem
The \nonterminal{struct-union-fields} list denotes, in order, the subvalues
which are collected by a struct or union, and potentially assigns a
\nonterminal{name} to each.

\specsubsubitem
For a struct type, the offset of each field is equal to the minimum
\textit{aligned} offset which would meet the alignment requirements of the
field's type and which is greater than the offset of the previous field plus the
size of the previous field. The implementation shall add \textit{padding} to
meet the alignment requirements of struct fields. For a union type, the offset
of all members is zero.

\specsubsubitem
The type of each struct or union field shall have a definite, nonzero size.

\specsubsubitem
If given, the \nonterminal{offset-specifier} shall override the computed offset
for a given field. If the user-defined offset for a field would not meet the
alignment requirements for that type, the behavior is implementation-defined.
The implementation shall either raise a diagnostic message and terminate the
translation phase, or shall support unaligned memory accesses (perhaps at a
cost to performance).

\specsubsubitem
The \nonterminal{expression} given for the \nonterminal{offset-specifier} shall
be limited to the \secref{Translation compatible expression subset}, and
shall have an integer type and a positive or zero value.

\specsubsubitem
The \nonterminal{offset-specifier} shall not be given for a \terminal{union}
type.

\specsubsubitem
A union type's size is the maximum size among its fields. A struct type's size
is the maximum value of $S$ for $S = O+Z$ among its fields, where $O$ is that
field's offset and $Z$ is that field's size.

\specsubsubitem
The default value of a struct or union type shall be defined as a value whose
fields assume the default values of their respective types. If two or more
fields have overlapping storage (as defined by the bounds of their offsets and
size), and any of their types does not have a default value, the default value
of all of these fields shall be undefined.

\specsubsubitem
If the \nonterminal{struct-union-type} form of \nonterminal{struct-union-field}
is given, the parent type shall collect the fields of the child type as its
own. The offset of each field within the child type shall be the sum of the
offset within the child type and the offset the child type occupies within the
parent struct. The \nonterminal{identifier} form shall be interpreted in the same
manner as a \nonterminal{struct-union-type} if it refers to a type alias of a
struct or union type, otherwise a diagnostic message shall be printed and the
translation phase shall abort.

Forward references: \subsecref{Type aliases}

\specsubsubitem
A struct or union type shall be equivalent to another struct or union type if
their fields are of equivalent name, type, and offset, without respect to the
order of their appearance in the program source.

\informative{The following types are equivalent: \\
\code{struct \{ a: int, b: int \}} \\
\code{struct \{ a: int, struct \{ b: int \} \}}}

\specsubsubitem
Each field name (including names of embedded fields) shall be unique within the
set of all field names of the \nonterminal{struct-union-type}.

\specsubsection{Tuple types}

\begin{grammar}
\nonterminaldef{tuple-type} \\
	\terminal{(} \nonterminal{tuple-types} \terminal{)} \\

\nonterminaldef{tuple-types} \\
	\nonterminal{type} \terminal{,} \nonterminal{type} \optional{\terminal{,}}\\
	\nonterminal{type} \terminal{,} \nonterminal{tuple-types} \\
\end{grammar}

\specsubsubitem
A tuple type stores two or more values of arbitrary types in a specific order.
It is similar to a struct type, but without names for each of its subvalues.
Each value is stored at a given offset, possibly with padding added to meet
alignment requirements.

\specsubsubitem
The offset of each value is equal to the minimum \textit{aligned} offset which
would meet the alignment requirements of the value's type and which is greater
than the offset of the previous value plus the size of the previous value type.
The implementation shall add \textit{padding} to meet the alignment
requirements of tuple values.

\specsubsubitem
The size of a tuple is the sum of the sizes of its value types plus any necessary
padding. The alignment is the maximum alignment among its value types.

\specsubsubitem
The type of each tuple value shall have a definite, nonzero size.

\specsubsubitem
The default value of a tuple type shall be defined such that its values assume
the default values of their respective types. If any of the subtypes do not
have a default value, neither does the tuple type.

\specsubsubitem
Two tuple types shall be equivalent to each other if they have the same value
types in the same order.

\specsubsection{Tagged union types}

\begin{grammar}
\nonterminaldef{tagged-union-type} \\
	\terminal{(} \nonterminal{tagged-types} \terminal{)} \\

\nonterminaldef{tagged-types} \\
	\nonterminal{type} \terminal{|} \nonterminal{type} \optional{\terminal{|}}\\
	\nonterminal{type} \terminal{|} \nonterminal{tagged-types} \\
\end{grammar}

\specsubsubitem
A tagged union stores a value of \textbf{one} of its constituent types, as well
as a \textit{tag} which indicates which of the constituent types is selected.
The constituent types are defined by \nonterminal{tagged-types}.

\specsubsubitem
The representation of a tagged union shall be a \terminal{uint}, in which the
tag value is stored, followed by sufficient space to store any of the possible
constituent types. Padding shall be inserted between the tag and the value area
and after the value area if necessary to meet the maximum alignment among the
tagged union members and the \terminal{uint} field.

\specsubsubitem
The tag value shall be the type ID of the type which is selected from the
constituent types. This value shall be stored at the \terminal{uint} field and
shall indicate which type is stored in the value area.

\specsubsubitem
The alignment of a tagged union type shall be the alignment of the
\terminal{uint} type or the maximum alignment of the constituent types,
whichever is greater.

\specsubsubitem
The size of a tagged union type shall be the maximum size of its constituent
types, plus the size of the \terminal{uint} type, plus any padding added per
\subsubitemref{Tagged union types}{2}.

\specsubsubitem
If a member type among \nonterminal{tagged-types} is a tagged union type, it
shall be reduced such that nested tagged union type is replaced with its
constituent types in the parent union.

\informative{The types \code{(A | (B | (C | D)))} and
\code{(A | B | C | D)} are equivalent.}

\specsubsubitem
The default value of a tagged union type is undefined.

\specsubsubitem
A tagged union type shall be equivalent to another tagged union type if they
share the same set of secondary types, without regard to order, and considering
the secondary types of nested tagged unions as members of the set of their
parent's secondary types.

\informative{It follows that the types \code{(A | B)} and \code{(B | A)}
are equivalent.}

\specsubsection{Slice and array types}

\begin{grammar}
\nonterminaldef{slice-array-type} \\
	\terminal{[} \terminal{]} \nonterminal{type} \\
	\terminal{[} \nonterminal{expression} \terminal{]} \nonterminal{type} \\
	\terminal{[} \terminal{*} \terminal{]} \nonterminal{type} \\
	\terminal{[} \terminal{\_} \terminal{]} \nonterminal{type} \\
\end{grammar}

\specsubsubitem
An \textit{array type} stores one or more items of a uniform secondary type.
The number of items stored in an array type is an attribute of the array type
and is specified during the translation phase. The secondary type shall have a
definite, nonzero size.

\specsubsubitem
The \nonterminal{expression} representation is used for array types of a
determinate length, that is, with a determinate number of items. Such arrays
are \textit{bounded}. The \nonterminal{expression} must evaluate to a positive
integer value, and shall be limited to the \secref{Translation compatible
expression subset}.

\specsubsubitem
An array type may be \textit{unbounded}, in which case the number of items is
not known. The \terminal{*} representation indicates an array of this type.

\specsubsubitem
An array may be bounded, but infer its size from context, using the
\terminal{\_} representation. Such an array is said to be
\textit{context-defined}.

\specsubsubitem
An array type may be \textit{expandable}. This state is not represented in the
type grammar, and is only used in specific situations. Array types are presumed
to be non-expandable unless otherwise specified.

\specsubsubitem
The representation of an \textit{array type} shall be the items concatenated one
after another, such that the offset of the \textit{N}th item is determined by
the equation $N \times S$, where \textit{S} is the size of the secondary type.

\specsubsubitem
A \textit{slice type} stores a pointer to an unbounded array type, with a given
\textit{capacity}, and \textit{length}, which respectively refer to the number
of items that the unbounded array \textbf{may} store without re-allocation, and
the number of items which are \textbf{currently valid}. The representation with
no lexical elements between \terminal{[} and \terminal{]} indicates a slice
type.

\specsubsubitem
The representation of a slice type shall be equivalent to the following struct
type:

\begin{codesample}
struct {
	data: nullable *[*]type,
	length: size,
	capacity: size,
}
\end{codesample}

The type of the \textit{data} field shall be a nullable pointer to an unbounded
array of the secondary type.

\specsubsubitem
The alignment of an array type shall be equivalent to the alignment of the
underlying type. The alignment of a slice type shall be equivalent to the
alignment of the \terminal{size} type or \subsecref{Pointer types}, whichever is
greater.

\specsubsubitem
The size of a bounded array type shall be equal to $N \times S$, where N is the
number of items and S is the size of the underlying type. The size of an
unbounded array is undefined. The size of a slice type shall be equal to the
size of the struct type defined by \subsubitemref{Slice and array types}{6}.

\specsubsubitem
The default value of an array type shall be equal to all of its members set to
the default value of the underlying type. If the default value of the
underlying type is undefined, the default value of the array type is undefined.

\specsubsubitem
The default value of a slice type shall have the capacity and length fields set
to zero and the data field set to null.

\specsubsubitem
An array type shall be equivalent to another array type only if its length and
secondary types are equivalent. A slice type shall only be equivalent to a
slice type with the same secondary type.

\specsubsection{String types}

\begin{grammar}
\nonterminaldef{string-type} \\
	\terminal{str} \\
\end{grammar}

\specsubsubitem
A string stores a reference to a sequence of Unicode codepoints, encoded as
UTF-8, along with its \textit{length} and \textit{capacity}. The length and
capacity are measured in octets, rather than codepoints.

\specsubsubitem
The representation of the string type shall be equivalent to the following
struct type:

\begin{codesample}
struct {
	data: *[*]const u8,
	length: size,
	capacity: size,
}
\end{codesample}

\specsubsection{Function types}

\begin{grammar}
\nonterminaldef{function-type} \\
	\optional{\nonterminal{fntype-attr}} \terminal{fn} \nonterminal{prototype} \\

\nonterminaldef{prototype} \\
	\terminal{(} \optional{\nonterminal{parameter-list}} \terminal{)} \nonterminal{type} \\

\nonterminaldef{fntype-attr} \\
	\terminal{@noreturn} \\

\nonterminaldef{parameter-list} \\
	\nonterminal{parameters} \optional{\terminal{,}} \\
	\nonterminal{parameters} \terminal{...} \optional{\terminal{,}} \\
	\nonterminal{parameters} \terminal{,} \terminal{...} \optional{\terminal{,}} \\

\nonterminaldef{parameters} \\
	\nonterminal{parameter} \\
	\nonterminal{parameters} \terminal{,} \nonterminal{parameter} \\

\nonterminaldef{parameter} \\
	\nonterminal{name} \terminal{:} \nonterminal{type} \\
	\terminal{\_} \terminal{:} \nonterminal{type} \\
\end{grammar}

\specsubsubitem
Function types represent a procedure which may be completed in the
\secref{Execution environment} to obtain a result and possibly cause side
effects (see \subsubitemref{Program execution}{1}).

\specsubsubitem
If the \terminal{@noreturn} form of \nonterminal{fntype-attr} is specified in
the \nonterminal{function-parameters}, the \nonterminal{type} shall be
\terminal{void} and the specified function shall not return to its caller.

\specsubsubitem
The attributes of a function type are its \textit{result type} and
\textit{input parameters}. A function type must have one result type (which may
be \terminal{void}), and zero or more parameters. Each \nonterminal{name} shall
be unique.

\specsubsubitem
If the second form of \nonterminal{parameters} is used, the final parameter of
the function type uses \textit{Hare-style variadism}. If the third form is
used, the function uses \textit{C-style variadism}. The variadism of a function
type affects the calling semantics for that function.

\begin{codesample}
// Hare-style variadism:
fn(x: int, y: int, z: int...)

// C-style variadism:
fn(x: int, y: int, ...)
\end{codesample}

Forward references: \subsecref{Calls}

\specsubsubitem
The implementation is not required to support C-style variadism. If the
implementation does not support C-style variadism, it must print a diagnostic
message and abort the translation environment for programs which attempt to
utilize it.

\specsubsubitem
The type of a parameter which uses Hare-style variadism shall be a slice of the
specified type.

\informative{Therefore, in the case of \code{fn(x: int...)}, the type of x
shall be \code{const []int}.}

\specsubsubitem
The size, alignment, default value, and storage semantics of function types is
undefined. All function types shall be \terminal{const}, without regard to the
use of \terminal{const} in the type description.

\specsubsubitem
The function's result type, list of parameter types (in order), its variadism,
and \terminal{@noreturn} status, are distinct characteristics of the function
type, for the purpose of determining equivalency.

\specsubsection{Type aliases}

\begin{grammar}
\nonterminaldef{alias-type} \\
	\nonterminal{identifier} \\

\nonterminaldef{unwrapped-alias} \\
	\terminal{...} \nonterminal{identifier} \\
\end{grammar}

\specsubsubitem
A type alias assigns an \nonterminal{identifier} a unique type which is an
alias for another type.

\informative{The grammar for an \nonterminal{alias-type} does not specify the
underlying type. The underlying type is specified at the time it is declared,
see \secref{Declarations}.}

\specsubsubitem
A type alias shall have the same storage, alignment, size, default value, and
semantics as its underlying type.

\specsubsubitem
Each type alias (uniquely identified by its \nonterminal{identifier}) shall be
a unique type, even if it shares its underlying type with another type alias.

\specsubsubitem
The \terminal{...} operator shall \textit{unwrap} the type alias, and shall
cause the statement to refer to the underlying type rather than the type alias
itself.

\informative{This notably affects the relationship between type aliases and
tagged unions. In the following example, union\_a and union\_b have different
storage semantics, the former being a tagged union of two other tagged unions,
and the latter being reduced to a single tagged union.}

\begin{codesample}
type signed = (i8 | i16 | i32 | i64 | int);
type unsigned = (u8 | u16 | u32 | u64 | uint);
type union_a = (signed | unsigned);
type union_b = (...signed | ...unsigned);
\end{codesample}
