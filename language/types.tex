\specsection{Types}

\begin{grammar}
\nonterminaldef{type} \\
	\nonterminal{scalar-type} \\
	\nonterminal{struct-union-type} \\
	\nonterminal{tagged-union-type} \\
	\nonterminal{slice-array-type} \\
	\nonterminal{function-type} \\
	\nonterminal{alias-type} \\
	\terminal{const} \nonterminal{type} \\

\nonterminaldef{scalar-type} \\
	\nonterminal{integer-type} \\
	\nonterminal{floating-type} \\
	\nonterminal{enum-type} \\
	\nonterminal{pointer-type} \\
	\terminal{bool} \\
	\terminal{null} \\
	\terminal{void} \\
\end{grammar}

\specsubitem
A type defines the storage and semantics of a value. The attributes common to
all types are its \textit{size}, in octets; \textit{alignment}; and its
\textit{constant} or \textit{mutable} nature.

\specsubitem
Some types have an undefined size. This includes \nonterminal{function-type},
and some cases of \nonterminal{slice-array-type}.

\specsubitem
The \terminal{const} terminal, when used in a type specifier, enables the
constant flag and prohibits write operations on any value of that type. Types
without this attribute are considered mutable by default.

\specsubitem
A scalar type, also called a \textit{built-in} or \textit{primitive} type,
stores one value at a specific, pre-defined precision. Scalar types are the
most basic unit in the Hare type system. Other types are referred to as
\textit{aggregate types}, with the exception of alias types, which may be
either scalar or aggregate.

\specsubsection{Integer types}

\begin{grammar}
\nonterminaldef{integer-type}\oneof \\
	\terminal{i8}
	\terminal{i16}
	\terminal{i32}
	\terminal{i64}
	\terminal{u8}
	\terminal{u16}
	\terminal{u32}
	\terminal{u64}
	\terminal{int}
	\terminal{uint}
	\terminal{size}
	\terminal{uintptr}
\end{grammar}

\specsubitem
Integer types store an integer value at a specific precision. These values are
either \textit{signed} or \textit{unsigned}; which respectively \textbf{are}
and \textbf{are not} able to represent negative integers. Zero is not negative.

\specsubitem
Signed integer types shall be represented in two's compliment form; the
most-significant bit is the sign bit.

\specsubitem
The endianness (byte order) of integer types shall be implementation-defined.

\specsubitem
The precision of \nonterminal{i16}, \nonterminal{i32}, \nonterminal{i64},
\nonterminal{u8}, \nonterminal{u16}, \nonterminal{u32}, and \nonterminal{u64}
are specified by the numeric suffix, which represents their precision in bits.

\specsubitem
The precision of \nonterminal{int} and \nonterminal{uint} are
implementation-defined. \nonterminal{int} shall be signed, and
\nonterminal{uint} shall be unsigned. Both types shall be at least 32-bits in
precision.

\specsubitem
The precision of \nonterminal{size} is implementation-defined. It shall be
unsigned and shall be able to store the maximum length of an array type.

\specsubitem
The precision of \nonterminal{uintptr} is implementation-defined. It shall be
able to represent the value of any \nonterminal{pointer-type} as an integer.
The signedness of this type is undefined.

\informative{The following table is informative.}

\begin{tabular}{r | l l l}
Type & Size in bits & Minimum value & Maximum value \\
\hline
\nonterminal{i8} & 8 & -128 & 127 \\
\nonterminal{i16} & 16 & -32708 & 32707 \\
\nonterminal{i32} & 32 & -2147483648 & 2147483647 \\
\nonterminal{i64} & 64 & -9223372036854775808 & 9223372036854775807 \\
\nonterminal{u8} & 8 & 0 & 255 \\
\nonterminal{u16} & 16 & 0 & 65535 \\
\nonterminal{u32} & 32 & 0 & 4294967295 \\
\nonterminal{u64} & 64 & 0 & 18446744073709551615 \\
\nonterminal{int} & $\ast$ & $\leq-2147483648$ & $\geq2147483647$ \\
\nonterminal{uint} & $\ast$ & 0 & $\geq4294967295$ \\
\nonterminal{size} & $\ast$ & $\ast$ & $\ast$ \\
\nonterminal{uintptr} & $\ast$ & $+$ & $+$ \\
\end{tabular}

$\ast$ implementation-defined

$+$ undefined

\specsubsection{Floating point types}

\specsubsection{Enum types}

\specsubsection{Pointer types}

\specsubsection{Other primitive types}

\specsubsection{Struct and union types}

\specsubsection{Tagged union types}

\specsubsection{Slice and array types}

\specsubsection{Function types}

\specsubsection{Type aliases}
