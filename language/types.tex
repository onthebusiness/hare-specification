\specsection{Types}

\begin{grammar}
\nonterminaldef{type} \\
	\nonterminal{scalar-type} \\
	\nonterminal{struct-union-type} \\
	\nonterminal{tagged-union-type} \\
	\nonterminal{slice-array-type} \\
	\nonterminal{function-type} \\
	\nonterminal{alias-type} \\
	\terminal{const} \nonterminal{type} \\

\nonterminaldef{scalar-type} \\
	\nonterminal{integer-type} \\
	\nonterminal{floating-type} \\
	\nonterminal{enum-type} \\
	\nonterminal{pointer-type} \\
	\terminal{bool} \\
	\terminal{void} \\
\end{grammar}

\specsubitem
A type defines the storage and semantics of a value. The attributes common to
all types are its \textit{size}, in octets; \textit{alignment}; and its
\textit{constant} or \textit{mutable} nature.

\specsubitem
Some types have an undefined size. This includes \nonterminal{function-type},
and some cases of \nonterminal{slice-array-type}.

\specsubitem
Other traits of a type include its \textit{assignability rules} and
\textit{casting rules}. The assignability rules refer to the constraints under
which a value of one type may be assigned to or from a value of another type,
causing an implicit conversion per \subsecref{Assignment}. The casting rules
refer to the constraints under which a value of one type may be converted to
another type using the explicit process of \subsecref{Casting}.

\specsubitem
The \terminal{const} terminal, when used in a type specifier, enables the
constant flag and prohibits write operations on any value of that type. Types
without this attribute are considered mutable by default.

\specsubitem
A scalar type, also called a \textit{built-in} or \textit{primitive} type,
stores one value at a specific, pre-defined precision. Scalar types are the
most basic unit in the Hare type system. Other types are referred to as
\textit{aggregate types}, with the exception of alias types, which may be
either scalar or aggregate.

\specsubitem
The \textit{type class} of a type is defined for scalar types as the terminal
which reprents it, for example \terminal{i32}.

\specsubitem
The implementation shall define a \textit{sort order} between types.

\specsubsection{Integer types}

\begin{grammar}
\nonterminaldef{integer-type}\oneof \\
	\terminal{i8}
	\terminal{i16}
	\terminal{i32}
	\terminal{i64}
	\terminal{u8}
	\terminal{u16}
	\terminal{u32}
	\terminal{u64}
	\terminal{int}
	\terminal{uint}
	\terminal{size}
	\terminal{uintptr}
	\terminal{char}
\end{grammar}

\specsubsubitem
Integer types represent an integer value at a specific precision. These values
are either \textit{signed} or \textit{unsigned}; which respectively
\textbf{are} and \textbf{are not} able to represent negative integers. Zero is
not negative. Integer types are considered \textit{numeric types}.

\specsubsubitem
Signed integer types shall be represented in two's compliment form; the
most-significant bit is the sign bit.

\specsubsubitem
The endianness (byte order) of integer types shall be implementation-defined.

\specsubsubitem
The precision of \nonterminal{i16}, \nonterminal{i32}, \nonterminal{i64},
\nonterminal{u8}, \nonterminal{u16}, \nonterminal{u32}, and \nonterminal{u64}
are specified by the numeric suffix, which represents their precision in bits.
Of those, types prefixed with \terminal{u} are unsigned, and those prefixed
with \terminal{i} are signed.

\specsubsubitem
The precision of \nonterminal{int} and \nonterminal{uint} are
implementation-defined. \nonterminal{int} shall be signed, and
\nonterminal{uint} shall be unsigned. Both types shall be at least 32-bits in
precision. The precision in bits shall be a power of two.

\specsubsubitem
The precision of \nonterminal{size} is implementation-defined. It shall be
unsigned and shall be able to represent the maximum length of an array type.
The precision in bits shall be a power of two.

\specsubsubitem
The precision of \nonterminal{uintptr} is implementation-defined. It shall be
able to represent the value of any \nonterminal{pointer-type} as an integer.
It shall be unsigned.

\specsubsubitem
The \terminal{char} type is equivalent to the \terminal{u8} type. However, there
are limitations on its use, see \subsecref{Arithmetic expressions}
\& \subsecref{Access expressions}.

\specsubsubitem
The alignment of integer types shall be equal to their size in octets.

\specsubsubitem
An integer type is assignable to another integer type if the signedness of the
types are equivalent and if the precision of the target type is greater than the
source type.

\informative{In other words, integer types are assignable if the assignment
would not cause a loss of precision.}

\specsubsubitem
The \terminal{uintptr} type is not assignable to any type other than itself.

\specsubsubitem
The \terminal{uintptr} type may be cast to and from a
\nonterminal{pointer-type}.

\specsubsubitem
All integer types are mutually castable. If a cast would incur a precision loss,
the value is truncated towards the least significant bit.

\specsubsubitem
When casting a signed type to another signed type, the sign bit shall be
preserved.

\specsubsubitem
When casting a signed type to an unsigned type or vice-versa, the sign bit shall
be interpreted as the most-significant bit of the unsigned type.

\informative{The following table is informative.}

\begin{tabular}{r | l l l}
Type & Size in bits & Minimum value & Maximum value \\
\hline
\nonterminal{i8} & 8 & -128 & 127 \\
\nonterminal{i16} & 16 & -32708 & 32707 \\
\nonterminal{i32} & 32 & -2147483648 & 2147483647 \\
\nonterminal{i64} & 64 & -9223372036854775808 & 9223372036854775807 \\
\nonterminal{u8} & 8 & 0 & 255 \\
\nonterminal{u16} & 16 & 0 & 65535 \\
\nonterminal{u32} & 32 & 0 & 4294967295 \\
\nonterminal{u64} & 64 & 0 & 18446744073709551615 \\
\nonterminal{int} & $\ge32$ & $\leq-2147483648$ & $\geq2147483647$ \\
\nonterminal{uint} & $\ge32$ & 0 & $\geq4294967295$ \\
\nonterminal{size} & $\ast$ & $\ast$ & $\ast$ \\
\nonterminal{uintptr} & $\ast$ & $+$ & $+$ \\
\end{tabular}

$\ast$ implementation-defined

$+$ undefined

\specsubsection{Floating point types}

\begin{grammar}
\nonterminaldef{floating-type} \\
	\terminal{f32} \\
	\terminal{f64} \\
\end{grammar}

\specsubsubitem
Floating-point types shall represent real numbers, i.e. numbers with both an
integer and fractional part. Floating point types are considered \textit{numeric
types}.

\specsubsubitem
The implementation shall represent floating-point types as IEEE 754-compatible
floating-point numbers. \terminal{f32} shall be stored in the binary32 format,
and \terminal{f64} shall use the binary64 format.

\specsubsubitem
The alignment of float types shall be equal to their size in octets.

\specsubsubitem
Floating point types are not mutually assignable.

\specsubsubitem
Floating point types may be cast to each other. If this conversion would cause a
loss of precision, the value is truncated towards zero.

\specsubsubitem
Floating point types may be cast to integer types. The fractional part of the
value is discarded and the integer part is truncated towards the
least-significant bit.

\specsubsection{Enum types}

\begin{grammar}
\nonterminaldef{enum-type} \\
	\terminal{enum} \terminal{\{} \nonterminal{enum-values} \terminal{\}} \\
	\terminal{enum} \nonterminal{integer-type} \terminal{\{} \nonterminal{enum-values} \terminal{\}} \\

\nonterminaldef{enum-values} \\
	\nonterminal{enum-value} \optional{\terminal{,}} \\
	\nonterminal{enum-value} \terminal{,} \nonterminal{enum-values} \\

\nonterminaldef{enum-value} \\
	\nonterminal{name} \\
	\nonterminal{name} \terminal{=} \nonterminal{simple-expression} \\
\end{grammar}

\specsubsubitem
Enum types, or \textit{enumerated types}, are a subset of integer types which
allows the user to assign a name to specific values.

\specsubsubitem
If \nonterminal{integer-type} is specified, the underlying storage of the enum
type is defined by the integer type specified. Otherwise, the underlying storage
is \terminal{int}.

\specsubsubitem
The size and alignment of an enum type is equivalent to those attributes of the
underlying integer type.

\specsubsubitem
If the \nonterminal{enum-value} does not specify a
\nonterminal{simple-expression}, the value assigned to that \nonterminal{name}
is equal to the last value assigned to an \nonterminal{enum-value} of this enum
type plus one. If no such previous value exists, the zero is assigned.

\specsubsubitem
An implicitly assigned value shall not exceed the precision of the underlying
integer type; if it were to, a diagnostic message shall be shown instead per
\secref{Diagnostics}.

\specsubsubitem
\nonterminal{simple-expression}, if specified, shall be evaluated in the
translation environment and the resulting value shall be assigned to the
corresponding \nonterminal{enum-value}. The result type must be assignable to
the enum type's underlying integer type (ref \subsecref{Assignment
expressions}).

\specsubsubitem
\nonterminal{simple-expression} shall be limited to the
\subsecref{Translation compatible expression subset}.

\specsubsubitem
Two enum types shall be considered equivalent if all of these conditions are
met:

\begin{subsubitemize}
\item
The underlying storage type is the same.
\item
The set of assigned values and the names assigned to those values is the same,
regardless of their order.
\end{subsubitemize}

% TODO: Assignment & cast rules

\specsubsection{Pointer types}

\begin{grammar}
\nonterminaldef{pointer-type} \\
	\terminal{*} \nonterminal{type} \\
	\terminal{nullable} \terminal{*} \nonterminal{type} \\
\end{grammar}

\specsubsubitem
A pointer type is an indirect reference to an object of a secondary type. The
notation of a pointer type is a \terminal{*} prefix before the secondary type.

\specsubsubitem
A normal pointer type shall \textbf{always} refers to a valid secondary object.
A pointer type prefixed with \terminal{nullable} is considered a
\textit{nullable pointer type}, and shall refer to either valid secondary object
or to a special value called \textit{null}.

\specsubsubitem
The representation of a pointer type shall be implementation-defined, but shall
meet the following constraints:

\begin{subsubitemize}
\item It shall have a well-defined length and alignment
\item It shall be castable \textit{to} and \textit{from} a \terminal{uintptr} type.
\end{subsubitemize}

\specsubsubitem
Pointer types with the same secondary type are mutually assignable. Pointer
types with different secondary types shall not be assigned to each other.

\specsubsubitem
Non-nullable pointer types may be assigned to nullable pointer types, but not
vice-versa.

\specsubsection{Other primitive types}

\textbf{The bool type}

\specsubsubitem
The \terminal{bool} type represents a boolean value, which may have one of two
states: true or false.

\specsubsubitem
The boolean type representation shall be equivalent to the \terminal{uint} type.
Any non-zero value shall be interpreted as true, and zero shall be intepreted as
false.

\specsubsubitem
The boolean type follows the same casting rules as the \terminal{uint} type. It
is only assignable to itself.

\textbf{The null type}

\specsubsubitem
The \terminal{null} type shall have the same representation as a pointer and can
only store a specific, implementation-defined value (the \textit{null} value).

\specsubsubitem
There is no grammar for defining a value of type null, or a sub-type of null. It
is for internal use only, as the type of the \terminal{null} constant.

\specsubsubitem
The \terminal{null} type may not be assigned to. Nullable \subsecref{Pointer
types} may be assigned from the \terminal{null} type, causing them to assume
their null value.

\specsubsubitem
The null type may be cast to any nullable pointer type \subsecref{Pointer
types}, resulting in a value of the desired nullable pointer type of the null
value.

\textbf{The void type}

\specsubsubitem
The \terminal{void} type represents a non-existent value, and shall have no
storage.

\specsubsubitem
The \terminal{void} type may not be assigned to or from any type, nor cast to or
from any type, except for itself.

\specsubsection{Struct and union types}

\begin{grammar}
\nonterminaldef{struct-union-type} \\
	\terminal{struct} \terminal{\{} \nonterminal{struct-fields} \terminal{\}} \\
	\terminal{union} \terminal{\{} \nonterminal{struct-fields} \terminal{\}} \\

\nonterminaldef{struct-fields} \\
	\nonterminal{struct-field} \optional{\terminal{,}} \\
	\nonterminal{struct-field} \terminal{,} \nonterminal{struct-fields} \\

\nonterminaldef{struct-field} \\
	\nonterminal{name} \terminal{:} \nonterminal{type} \\
	\nonterminal{struct-union-type} \\
	\nonterminal{identifier} \\
\end{grammar}

\specsubsubitem
The \textit{struct type} and \textit{union type} are \textit{aggregate types}.
A struct type stores multiple values, each with its own type; a union type
stores one value which may be one of several types. A type defined with the
\terminal{struct} terminal is a struct type and uses the struct type class; if
the \terminal{union} terminal is used the type is a union type with the union
type class.

\specsubsubitem
The \nonterminal{struct-fields} list denotes, in order, the subvalues which are
represented by a struct or union, and optionally assigns a \nonterminal{name} to
each.

\specsubsubitem
For a struct type, the \textit{offset} of each field is equal to the minimum
\textit{aligned} offset which would meet the alignment requirements of the
field's type. The implementation shall add \textit{padding} to meet the
alignment requirements of struct fields. For a union type, the offset of all
members is zero.

\specsubsubitem
A union type's size is the maximum size among its fields. A struct type's size
is the sum of the sizes of its fields plus any necessary padding.

\specsubsubitem
Struct and union types are assignable from values of the same struct or union
type.

\informative{Struct and union types are distinct types even if they have the
same \nonterminal{struct-fields}.}

\specsubsubitem
Struct and union types cannot be cast to other type other than themselves.

\specsubsubitem
A struct type shall be equivalent to another struct type if their fields, in
order, are of equivalent types and names. A union type shall be equal to another
union type if the set field types \& names are identical between them,
without respect to their order.

\specsubsection{Tagged union types}

\begin{grammar}
\nonterminaldef{tagged-union-type} \\
	\terminal{(} \nonterminal{tagged-types} \terminal{)} \\

\nonterminaldef{tagged-types} \\
	\nonterminal{type} \terminal{|} \nonterminal{type} \\
	\nonterminal{type} \terminal{|} \nonterminal{tagged-types} \\
\end{grammar}

\specsubsubitem
A tagged union stores a value of \textbf{one} of its constituent types, as well
as a \textit{tag} which indicates which of the constituent types is selected.
The constituent types is defined by \nonterminal{tagged-types}.

\specsubsubitem
The representation of a tagged union shall be an \terminal{int}, followed by
sufficient space to store any of the possible constituent types. Padding shall
be inserted between the tag and the value area if necessary to meet the maximum
alignment among the tagged union members.

\specsubsubitem
The tag value shall be assigned from $0$ based on the sort order of the
constituent types, per \subitemref{Types}{7}.

\informative{It follows that the types \code{(A | B)} and \code{(B | A)}
are equivalent.}

\specsubsubitem
The alignment of a tagged union type shall be the alignment of the
\terminal{int} type or the maximum alignment of the constituent types, whichever
is greater.

\specsubsubitem
The size of a tagged union type shall be maximum size of its constituent types,
plus the size of the \terminal{int} type, plus any padding added per
\subsubitemref{Tagged union types}{2}.

\specsubsubitem
If a member type among \nonterminal{tagged-types} is a tagged union type, it
shall be reduced such that nested tagged union type is replaced with its
constitent types in the parent union.

\informative{The types \code{(A | (B | (C | D)))} and
\code{(A | B | C | D)} are equivalent.}

\specsubsection{Slice and array types}

\begin{grammar}
\nonterminaldef{slice-array-type} \\
	\terminal{[} \terminal{]} \nonterminal{type} \\
	\terminal{[} \nonterminal{simple-expression} \terminal{]} \nonterminal{type} \\
	\terminal{[} \terminal{*} \terminal{]} \nonterminal{type} \\
\end{grammar}

\specsubsubitem
An \textit{array type} stores one or more items of a uniform secondary type.
The number of items stored in an array type is an attribute of the array type
and is specified during the translation phase.

\specsubsubitem
The \nonterminal{simple-expression} representation is used for array types of a
determinate length, that is, with a determinate number of items. Such arrays are
\textit{bounded}. The \nonterminal{simple-expression} must evaluate to a
positive integer value, and shall be limited to the \subsecref{Translation
compatible expression subset}.

\specsubsubitem
An array type may be \textit{unbounded}, in which case the number of items is
not known. The \terminal{*} representation indicates an array of this type.

\specsubsubitem
The representation of an \textit{array type} shall be the items concatenated one
after another, such that the offset of the \textit{N}th item is determined by
the equation $N \times S$, where \textit{S} is the size of the secondary type.

\specsubsubitem
A \textit{slice type} stores a pointer to an unbounded array type, with a given
\textit{capacity}, \textit{length}, and \textit{item size}, which respectively
refer to the number of items that the unbounded array \textbf{may} store without
re-allocation, the number of items which are \textbf{currently valid}, and the
size of the underlying type. The representation with no lexical elements between
\terminal{[} and \terminal{]} indicates a slice type.

\specsubsubitem
The representation of a slice type shall be equivalent to the following struct
type:

\begin{codesample}
struct {
	capacity: size,
	length: size,
	item_size: size,
	data: *[*]type,
}
\end{codesample}

The \textit{data} field is a pointer to an unbounded array of the secondary
type.

\specsubsubitem
The alignment of an array type shall be equivalent to the alignment of the
underlying type. The alignment of a slice type shall be equivalent to the
alignment of the \terminal{size} type or \subsecref{Pointer types}, whichever is
greater.

\specsubsubitem
The size of a bounded array type shall be equal to $N \times S$, where N is the
number of items and S is the size of the underlying type. The size of an
unbounded array is undefined. The size of a slice type shall be equal to the
size of the struct type defined by \subsubitemref{Slice and array types}{6}.

\specsubsection{Function types}

\begin{grammar}
\nonterminaldef{function-type} \\
	\terminal{fn} \nonterminal{prototype} \\
\end{grammar}

\specsubsection{Type aliases}

\begin{grammar}
\nonterminaldef{alias-type} \\
	\nonterminal{identifier} \\
\end{grammar}
