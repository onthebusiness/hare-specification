\specsection{Types}

\begin{grammar}
\nonterminaldef{type} \\
	\nonterminal{scalar-type} \\
	\nonterminal{struct-union-type} \\
	\nonterminal{tagged-union-type} \\
	\nonterminal{slice-array-type} \\
	\nonterminal{function-type} \\
	\nonterminal{alias-type} \\
	\terminal{const} \nonterminal{type} \\

\nonterminaldef{scalar-type} \\
	\nonterminal{integer-type} \\
	\nonterminal{floating-type} \\
	\nonterminal{enum-type} \\
	\nonterminal{pointer-type} \\
	\terminal{bool} \\
	\terminal{void} \\
\end{grammar}

\specsubitem
A type defines the storage and semantics of a value. The attributes common to
all types are its \textit{size}, in octets; \textit{alignment}; and its
\textit{constant} or \textit{mutable} nature.

\specsubitem
Some types have an undefined size. This includes \nonterminal{function-type},
and some cases of \nonterminal{slice-array-type}.

\specsubitem
Other traits of a type include its \textit{assignability rules} and
\textit{casting rules}. The assignability rules refer to the constraints under
which a value of one type may be assigned to or from a value of another type,
causing an implicit conversion per \subsecref{Assignment}. The casting rules
refer to the constraints under which a value of one type may be converted to
another type using the explicit process of \subsecref{Casting}.

\specsubitem
The \terminal{const} terminal, when used in a type specifier, enables the
constant flag and prohibits write operations on any value of that type. Types
without this attribute are considered mutable by default.

\specsubitem
A scalar type, also called a \textit{built-in} or \textit{primitive} type,
stores one value at a specific, pre-defined precision. Scalar types are the
most basic unit in the Hare type system. Other types are referred to as
\textit{aggregate types}, with the exception of alias types, which may be
either scalar or aggregate.

\specsubsection{Integer types}

\begin{grammar}
\nonterminaldef{integer-type}\oneof \\
	\terminal{i8}
	\terminal{i16}
	\terminal{i32}
	\terminal{i64}
	\terminal{u8}
	\terminal{u16}
	\terminal{u32}
	\terminal{u64}
	\terminal{int}
	\terminal{uint}
	\terminal{size}
	\terminal{uintptr}
\end{grammar}

\specsubsubitem
Integer types represent an integer value at a specific precision. These values
are either \textit{signed} or \textit{unsigned}; which respectively
\textbf{are} and \textbf{are not} able to represent negative integers. Zero is
not negative.

\specsubsubitem
Signed integer types shall be represented in two's compliment form; the
most-significant bit is the sign bit.

\specsubsubitem
The endianness (byte order) of integer types shall be implementation-defined.

\specsubsubitem
The precision of \nonterminal{i16}, \nonterminal{i32}, \nonterminal{i64},
\nonterminal{u8}, \nonterminal{u16}, \nonterminal{u32}, and \nonterminal{u64}
are specified by the numeric suffix, which represents their precision in bits.
Of those, types prefixed with \terminal{u} are unsigned, and those prefixed
with \terminal{i} are signed.

\specsubsubitem
The precision of \nonterminal{int} and \nonterminal{uint} are
implementation-defined. \nonterminal{int} shall be signed, and
\nonterminal{uint} shall be unsigned. Both types shall be at least 32-bits in
precision. The precision in bits shall be a power of two.

\specsubsubitem
The precision of \nonterminal{size} is implementation-defined. It shall be
unsigned and shall be able to represent the maximum length of an array type.
The precision in bits shall be a power of two.

\specsubsubitem
The precision of \nonterminal{uintptr} is implementation-defined. It shall be
able to represent the value of any \nonterminal{pointer-type} as an integer.
It shall be unsigned.

\specsubsubitem
The alignment of integer types shall be equal to their size in octets.

\specsubsubitem
An integer type is assignable to another integer type if the signedness of the
types are equivalent and if the precision of the target type is greater than the
source type.

\informative{In other words, integer types are assignable if the assignment
would not cause a loss of precision.}

\specsubsubitem
The \terminal{uintptr} type is not assignable to any type other than itself.

\specsubsubitem
The \terminal{uintptr} type may be cast to and from a
\nonterminal{pointer-type}.

\specsubsubitem
All integer types are mutually castable. If a cast would incur a precision loss,
the value is truncated towards the least significant bit.

\specsubsubitem
When casting a signed type to another signed type, the sign bit shall be
preserved.

\specsubsubitem
When casting a signed type to an unsigned type or vice-versa, the sign bit shall
be interpreted as the most-significant bit of the unsigned type.

\informative{The following table is informative.}

\begin{tabular}{r | l l l}
Type & Size in bits & Minimum value & Maximum value \\
\hline
\nonterminal{i8} & 8 & -128 & 127 \\
\nonterminal{i16} & 16 & -32708 & 32707 \\
\nonterminal{i32} & 32 & -2147483648 & 2147483647 \\
\nonterminal{i64} & 64 & -9223372036854775808 & 9223372036854775807 \\
\nonterminal{u8} & 8 & 0 & 255 \\
\nonterminal{u16} & 16 & 0 & 65535 \\
\nonterminal{u32} & 32 & 0 & 4294967295 \\
\nonterminal{u64} & 64 & 0 & 18446744073709551615 \\
\nonterminal{int} & $\ge32$ & $\leq-2147483648$ & $\geq2147483647$ \\
\nonterminal{uint} & $\ge32$ & 0 & $\geq4294967295$ \\
\nonterminal{size} & $\ast$ & $\ast$ & $\ast$ \\
\nonterminal{uintptr} & $\ast$ & $+$ & $+$ \\
\end{tabular}

$\ast$ implementation-defined

$+$ undefined

\specsubsection{Floating point types}

\begin{grammar}
\nonterminaldef{floating-type} \\
	\terminal{f32} \\
	\terminal{f64} \\
\end{grammar}

\specsubsubitem
Floating-point types shall represent real numbers, i.e. numbers with both an
integer and fractional part.

\specsubsubitem
The implementation shall represent floating-point types as IEEE 754-compatible
floating-point numbers. \terminal{f32} shall be stored in the binary32 format,
and \terminal{f64} shall use the binary64 format.

\specsubsubitem
The alignment of float types shall be equal to their size in octets.

\specsubsubitem
Floating point types are not mutually assignable.

\specsubsubitem
Floating point types may be cast to each other. If this conversion would cause a
loss of precision, the value is truncated towards zero.

\specsubsubitem
Floating point types may be cast to integer types. The fractional part of the
value is discarded and the integer part is truncated towards the
least-significant bit.

\specsubsection{Enum types}

\begin{grammar}
\nonterminaldef{enum-type} \\
	\terminal{enum} \terminal{\{} \nonterminal{enum-values} \terminal{\}} \\
	\terminal{enum} \nonterminal{integer-type} \terminal{\{} \nonterminal{enum-values} \terminal{\}} \\

\nonterminaldef{enum-values} \\
	\nonterminal{enum-value} \optional{\terminal{,}} \\
	\nonterminal{enum-value} \terminal{,} \nonterminal{enum-values} \\

\nonterminaldef{enum-value} \\
	\nonterminal{name} \\
	\nonterminal{name} \terminal{=} \nonterminal{simple-expression} \\
\end{grammar}

\specsubsubitem
Enum types, or \textit{enumerated types}, are a subset of integer types which
allows the user to assign a name to specific values.

\specsubsubitem
If \nonterminal{integer-type} is specified, the underlying storage of the enum
type is defined by the integer type specified. Otherwise, the underlying storage
is \terminal{int}.

\specsubsubitem
The size and alignment of an enum type is equivalent to those attributes of the
underlying integer type.

\specsubsubitem
If the \nonterminal{enum-value} does not specify a
\nonterminal{simple-expression}, the value assigned to that \nonterminal{name}
is equal to the last value assigned to an \nonterminal{enum-value} of this enum
type plus one. If no such previous value exists, the zero is assigned.

\specsubsubitem
An implicitly assigned value shall not exceed the precision of the underlying
integer type; if it were to, a diagnostic message shall be shown instead per
\secref{Diagnostics}.

\specsubsubitem
\nonterminal{simple-expression}, if specified, shall be evaluated in the
translation environment and the resulting value shall be assigned to the
corresponding \nonterminal{enum-value}. The result type must be assignable to
the enum type's underlying integer type (ref \subsecref{Assignment
expressions}).

\specsubsubitem
\nonterminal{simple-expression} shall be limited to the
\subsecref{Translation compatible expression subset}.

% TODO: Assignment & cast rules

\specsubsection{Pointer types}

\begin{grammar}
\nonterminaldef{pointer-type} \\
	\terminal{*} \nonterminal{type} \\
	\terminal{nullable} \terminal{*} \nonterminal{type} \\
\end{grammar}

\specsubsubitem
A pointer type is an indirect reference to an object of a secondary type. The
notation of a pointer type is a \terminal{*} prefix before the secondary type.

\specsubsubitem
A normal pointer type shall \textbf{always} refers to a valid secondary object.
A pointer type prefixed with \terminal{nullable} is considered a
\textit{nullable pointer type}, and shall refer to either valid secondary object
or to a special value called \textit{null}.

\specsubsubitem
The representation of a pointer type shall be implementation-defined, but shall
meet the following constraints:

\begin{subsubitemize}
\item It shall have a well-defined length and alignment
\item It shall be castable \textit{to} and \textit{from} a \terminal{uintptr} type.
\end{subsubitemize}

\specsubsubitem
Pointer types with the same secondary type are mutually assignable. Pointer
types with different secondary types shall not be assigned to each other.

\specsubsubitem
Non-nullable pointer types may be assigned to nullable pointer types, but not
vice-versa.

\specsubsection{Other primitive types}

\textbf{The bool type}

\specsubsubitem
The \terminal{bool} type represents a boolean value, which may have one of two
states: true or false.

\specsubsubitem
The boolean type representation shall be equivalent to the \terminal{uint} type.
Any non-zero value shall be interpreted as true, and zero shall be intepreted as
false.

\specsubsubitem
The boolean type follows the same casting rules as the \terminal{uint} type. It
is only assignable to itself.

\textbf{The null type}

\specsubsubitem
The \terminal{null} type shall have the same representation as a pointer and can
only store a specific, implementation-defined value (the \textit{null} value).

\specsubsubitem
There is no grammar for defining a value of type null, or a sub-type of null. It
is for internal use only, as the type of the \terminal{null} constant.

\specsubsubitem
The \terminal{null} type may not be assigned to. Nullable \subsecref{Pointer
types} may be assigned from the \terminal{null} type, causing them to assume
their null value.

\specsubsubitem
The null type may be cast to any nullable pointer type \subsecref{Pointer
types}, resulting in a value of the desired nullable pointer type of the null
value.

\textbf{The void type}

\specsubsubitem
The \terminal{void} type represents a non-existent value, and shall have no
storage.

\specsubsubitem
The \terminal{void} type may not be assigned to or from any type, nor cast to or
from any type, except for itself.

\specsubsection{Struct and union types}

\begin{grammar}
\nonterminaldef{struct-union-type} \\
	\terminal{struct} \terminal{\{} \nonterminal{struct-fields} \terminal{\}} \\
	\terminal{union} \terminal{\{} \nonterminal{struct-fields} \terminal{\}} \\

\nonterminaldef{struct-fields} \\
	\nonterminal{struct-field} \optional{\terminal{,}} \\
	\nonterminal{struct-field} \terminal{,} \nonterminal{struct-fields} \\

\nonterminaldef{struct-field} \\
	\nonterminal{name} \terminal{:} \nonterminal{type} \\
	\nonterminal{struct-union-type} \\
	\nonterminal{identifier} \\
\end{grammar}

\specsubsubitem
The \textit{struct type} and \textit{union type} are \textit{aggregate types}.
A struct type stores multiple values, each with its own type; a union type
stores one value which may be one of several types.

\specsubsubitem
The \nonterminal{struct-fields} list denotes, in order, the subvalues which are
represented by a struct or union, and optionally assigns a \nonterminal{name} to
each.

\specsubsubitem
For a struct type, the \textit{offset} of each field is equal to the minimum
\textit{aligned} offset which would meet the alignment requirements of the
field's type. The implementation shall add \textit{padding} to meet the
alignment requirements of struct fields. For a union type, the offset of all
members is zero.

\specsubsubitem
A union type's size is the maximum size among its fields. A struct type's size
is the sum of the sizes of its fields plus any necessary padding.

\specsubsubitem
Struct and union types are assignable from values of the same struct or union
type.

\informative{Struct and union types are distinct types even if they have the
same \nonterminal{struct-fields}.}

\specsubsubitem
Struct and union types cannot be cast to other type other than themselves.

\specsubsection{Tagged union types}

\begin{grammar}
\nonterminaldef{tagged-union-type} \\
	\terminal{(} \nonterminal{tagged-types} \terminal{)} \\

\nonterminaldef{tagged-types} \\
	\nonterminal{type} \terminal{|} \nonterminal{type} \\
	\nonterminal{type} \terminal{|} \nonterminal{tagged-types} \\
\end{grammar}

\specsubsubitem
A tagged union stores a value of \textbf{one} of its constituent types, as well
as a \textit{tag} which indicates which of the constituent types is selected.
The constituent types is defined by \nonterminal{tagged-types}.

\specsubsubitem
The representation of a tagged union shall be an \terminal{int}, followed by
sufficient space to store any of the possible constituent types. Padding shall
be inserted between the tag and the value area if necessary to meet the maximum
alignment among the tagged union members.

\specsubsubitem
The tag shall represent the index within the \nonterminal{tagged-types} which
definds the type for which the storage area value is to be interpreted as.

\specsubsubitem
The alignment of a tagged union type shall be the alignment of the
\terminal{int} type or the maximum alignment of the constituent types, whichever
is greater.

\specsubsubitem
The size of a tagged union type shall be maximum size of its constituent types,
plus the size of the \terminal{int} type, plus any padding added per
\subsubitemref{Tagged union types}{2}.

\specsubsubitem
If a member type among \nonterminal{tagged-types} is a tagged union type, it
shall be reduced such that nested tagged union type is replaced with its
constitent types in the parent union.

\informative{The types \code{(int | (uint | (bool | void)))} and
\code{(int | uint | bool | void)} are equivalent.}

\specsubsection{Slice and array types}

\begin{grammar}
\nonterminaldef{slice-array-type} \\
	\terminal{[} \terminal{]} \nonterminal{type} \\
	\terminal{[} \nonterminal{simple-expression} \terminal{]} \nonterminal{type} \\
	\terminal{[} \terminal{*} \terminal{]} \nonterminal{type} \\
\end{grammar}

\specsubsection{Function types}

\begin{grammar}
\nonterminaldef{function-type} \\
	\terminal{fn} \nonterminal{prototype} \\
\end{grammar}

\specsubsection{Type aliases}

\begin{grammar}
\nonterminaldef{alias-type} \\
	\nonterminal{identifier} \\
\end{grammar}
