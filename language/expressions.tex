\specsection{Expressions}

\specsubitem
An expression is a procedure which the implementation may perform to obtain a
\textit{result}, and possibly cause side-effects (see
\subsubitemref{Program execution}{1}). All expressions have a defined
\textit{result type}.

\specsubitem
Expression types are organized into a number of classes and subclasses of
expressions which define the contexts in which each expression type is
applicable.

\specsubitem
Some expressions may provide a \textit{type hint} to other expressions which
appear in their grammar, which those expressions may take advantage of to
refine their behavior.

\specsubsection{Constants}

\begin{grammar}
\nonterminaldef{constant} \\
	\nonterminal{integer-constant} \\
	\nonterminal{floating-constant} \\
	\nonterminal{rune-constant} \\
	\nonterminal{string-constant} \\
	\terminal{true} \\
	\terminal{false} \\
	\terminal{null} \\
	\terminal{void} \\
\end{grammar}

\specsubsubitem
Constants (also known as literals) describe a specific value of an unambiguous
type. The result of the expression is the constant value.

\specsubsubitem
The keywords \terminal{true} and \terminal{false} respectively represent
the constants of the \terminal{bool} type.

\specsubsubitem
The representation of \terminal{true} as an \terminal{uint}-equivalent (ref
\subsubitemref{Other primitive types}{2}) shall be one.

\specsubsubitem
The \terminal{null} keyword represents the \terminal{null} value of the
\terminal{null} type.

\specsubsubitem
The \terminal{void} keyword represents the \terminal{void} value of the
\terminal{void} type.

\specsubsection{Floating constants}

\begin{grammar}
\nonterminaldef{floating-constant} \exactly \\
	\nonterminal{decimal-digits} \terminal{.} \nonterminal{decimal-digits} \optional{\nonterminal{exponent}} \optional{\nonterminal{floating-suffix}} \\
	\nonterminal{decimal-digits} \optional{\nonterminal{exponent}} \nonterminal{floating-suffix} \\

\nonterminaldef{floating-suffix} \oneof \\
	\terminal{f32}
	\terminal{f64} \\

\nonterminaldef{decimal-digits} \exactly \\
	\nonterminal{decimal-digit} \optional{\nonterminal{decimal-digits}} \\

\nonterminaldef{decimal-digit} \oneof \\
	\terminal{0}
	\terminal{1}
	\terminal{2}
	\terminal{3}
	\terminal{4}
	\terminal{5}
	\terminal{6}
	\terminal{7}
	\terminal{8}
	\terminal{9} \\

\nonterminaldef{exponent} \exactly \\
	\nonterminal{exponent-char} \optional{\nonterminal{sign}} \nonterminal{decimal-digits} \\

\nonterminaldef{sign} \oneof \\
        \terminal{+}
        \terminal{-} \\

\nonterminaldef{exponent-char} \oneof \\
        \terminal{e}
        \terminal{E} \\
\end{grammar}

Floating constants represent an approximation to a real number.

\specsubitem
If the \nonterminal{floating-suffix} is not provided, the result shall be
\terminal{fconst}. Otherwise, the type shall refer to the type named by the
suffix.

\specsubitem
If the part before the decimal point is equal to zero, it shall be written as a
single digit number. If the part before the decimal point is not equal to zero,
it shall not begin with the digit \terminal{0}.

\specsubitem
If the \nonterminal{exponent} is provided, the value of the
constant shall be multiplied by 10 to the power of
\nonterminal{decimal-digits}. If \nonterminal{sign} is provided within the
\nonterminal{exponent}, \nonterminal{decimal-digits} shall assume the given
sign.

\specsubsection{Integer constants}

\begin{grammar}
\nonterminaldef{integer-constant} \exactly \\
	\terminal{0x} \nonterminal{hex-digits} \optional{\nonterminal{integer-suffix}} \\
	\terminal{0o} \nonterminal{octal-digits} \optional{\nonterminal{integer-suffix}} \\
	\terminal{0b} \nonterminal{binary-digits} \optional{\nonterminal{integer-suffix}} \\
	\nonterminal{decimal-digits} \optional{\nonterminal{exponent}}
		\optional{\nonterminal{integer-suffix}} \\

\nonterminaldef{hex-digits} \exactly \\
	\nonterminal{hex-digit} \optional{\nonterminal{hex-digits}} \\

\nonterminaldef{hex-digit} \oneof \\
	\terminal{0}
	\terminal{1}
	\terminal{2}
	\terminal{3}
	\terminal{4}
	\terminal{5}
	\terminal{6}
	\terminal{7}
	\terminal{8}
	\terminal{9}
	\terminal{A}
	\terminal{B}
	\terminal{C}
	\terminal{D}
	\terminal{E}
	\terminal{F}
	\terminal{a}
	\terminal{b}
	\terminal{c}
	\terminal{d}
	\terminal{e}
	\terminal{f} \\

\nonterminaldef{octal-digits} \exactly \\
	\nonterminal{octal-digit} \optional{\nonterminal{octal-digits}} \\

\nonterminaldef{octal-digit} \oneof \\
	\terminal{0}
	\terminal{1}
	\terminal{2}
	\terminal{3}
	\terminal{4}
	\terminal{5}
	\terminal{6}
	\terminal{7} \\

\nonterminaldef{binary-digits} \exactly \\
	\nonterminal{binary-digit} \optional{\nonterminal{binary-digits}} \\

\nonterminaldef{binary-digit} \oneof \\
	\terminal{0}
	\terminal{1} \\

\nonterminaldef{integer-suffix} \oneof \\
	\terminal{i}
	\terminal{u}
	\terminal{z}
	\terminal{i8}
	\terminal{i16}
	\terminal{i32}
	\terminal{i64}
	\terminal{u8}
	\terminal{u16}
	\terminal{u32}
	\terminal{u64} \\
\end{grammar}

Integer constants represent an integer value at a specific precision.

\specsubitem
If the \nonterminal{integer-suffix} is provided, the type is specified by the
suffix. Suffixes \terminal{i}, \terminal{u},  and \terminal{z} shall
respectively refer to the \terminal{int}, \terminal{uint}, and \terminal{size}
types; the remainder shall refer to the type named by the suffix. Otherwise,
the type shall be \terminal{iconst} with both maximum and minimum set to the
number provided.

\specsubitem
If the number provided is not within the limits of the precision of the
constant type, a diagnostic message shall be printed and the translation phase
shall fail.

\specsubitem
The prefixes \terminal{0x}, \terminal{0o}, and \terminal{0b} shall respectively
cause the number to be interpreted with a hexadecimal, octal, or binary base.
If no prefix is used, the number shall be interpreted with a decimal base.
In decimal base, zero shall be written as a single digit number. Numbers other
than zero that are given in decimal base shall not begin with the digit
\terminal{0}. \nonterminal{hex-digits} shall be interpreted in a
case-insensitive manner.

\specsubitem
If the \nonterminal{exponent} is provided, the value of the
integer shall be multiplied by 10 to the power of \nonterminal{decimal-digits}.
If \nonterminal{sign} is provided and is negative (\terminal{-}), a diagnostic
message shall be printed and the translation phase shall abort.

\specsubsection{Rune constants}
\begin{grammar}
\nonterminaldef{rune-constant} \exactly \\
	\terminal{\textquotesingle} \nonterminal{rune} \terminal{\textquotesingle} \\

\nonterminaldef{rune} \\
	\norm{Any character other than \terminal{\textbackslash} or \terminal{\textquotesingle}} \\
	\nonterminal{escape-sequence} \\

\nonterminaldef{escape-sequence} \exactly \\
	\nonterminal{named-escape} \\
	\terminal{\textbackslash{}x} \nonterminal{hex-digit} \nonterminal{hex-digit} \\
	\terminal{\textbackslash{}u} \nonterminal{fourbyte} \\
	\terminal{\textbackslash{}U} \nonterminal{eightbyte} \\


\nonterminaldef{fourbyte} \exactly \\
	\nonterminal{hex-digit} \nonterminal{hex-digit} \nonterminal{hex-digit} \nonterminal{hex-digit} \\

\nonterminaldef{eightbyte} \exactly \\
	\nonterminal{fourbyte} \nonterminal{fourbyte} \\

\nonterminaldef{named-escape} \oneof \\
	\terminal{\textbackslash0}
	\terminal{\textbackslash{}a}
	\terminal{\textbackslash{}b}
	\terminal{\textbackslash{}f}
	\terminal{\textbackslash{}n}
	\terminal{\textbackslash{}r}
	\terminal{\textbackslash{}t}
	\terminal{\textbackslash{}v}
	\terminal{\textbackslash\textbackslash}
	\terminal{\textbackslash\textquotesingle}
	\terminal{\textbackslash"} \\
\end{grammar}

\specsubsubitem
A \nonterminal{rune-constant} shall have a result type of \terminal{rconst}.

\specsubsubitem
If the \nonterminal{rune-constant} is not an \nonterminal{escape-sequence}, the
value of the rune shall be the Unicode codepoint representing
\nonterminal{rune}.

\specsubsubitem
A \nonterminal{rune-constant} beginning with \terminal{\textbackslash{}x},
\terminal{\textbackslash{}u}, or \terminal{\textbackslash{}U} shall interpet
its value as a Unicode codepoint specified in its hexadecimal representation by
\nonterminal{hex-digit}s.

\specsubsubitem
A \nonterminal{rune-constant} containing a \nonterminal{named-escape} shall have
a value based on the following chart:

\begin{tabular}{r | l | r | l}
Escape sequence & Unicode codepoint & Escape sequence & Unicode codepoint \\
\hline
\terminal{\textbackslash0} & \code{U+0000} &
\terminal{\textbackslash{}a} & \code{U+0007} \\
\terminal{\textbackslash{}b} & \code{U+0008} &
\terminal{\textbackslash{}f} & \code{U+000C} \\
\terminal{\textbackslash{}n} & \code{U+000A} &
\terminal{\textbackslash{}r} & \code{U+000D} \\
\terminal{\textbackslash{}t} & \code{U+0009} &
\terminal{\textbackslash{}v} & \code{U+000B} \\
\terminal{\textbackslash\textbackslash} & \code{U+005C} &
\terminal{\textbackslash\textquotesingle} & \code{U+0027} \\
\terminal{\textbackslash"} & \code{U+0022} \\
\end{tabular}

\specsubsection{String constants}

\begin{grammar}
\nonterminaldef{string-constant} \\
	\nonterminal{string-section} \optional{\nonterminal{string-constant}} \\

\nonterminaldef{string-section} \exactly \\
	\terminal{"} \optional{\nonterminal{string-chars}} \terminal{"} \\
	\terminal{\textasciigrave} \optional{\nonterminal{rawstring-chars}} \terminal{\textasciigrave} \\

\nonterminaldef{string-chars} \exactly \\
	\nonterminal{string-char} \optional{\nonterminal{string-chars}} \\

\nonterminaldef{string-char} \\
	\norm{Any character other than \terminal{\textbackslash} or \terminal{"}} \\
	\nonterminal{escape-sequence} \\

\nonterminaldef{rawstring-chars} \exactly \\
	\nonterminal{rawstring-char} \optional{\nonterminal{rawstring-chars}} \\

\nonterminaldef{rawstring-char} \\
	\norm{Any character other than \terminal{\textasciigrave}} \\
\end{grammar}

\specsubsubitem
A \nonterminal{string-constant} expression shall have a result type of
\terminal{const} \terminal{str}.

\specsubsubitem
If the first form of \nonterminal{string-section} is used, the string's
\textit{data} field shall refer to a \hbox{UTF-8} encoded sequence of Unicode
codepoints, ascertained by encoding the sequence of \nonterminal{string-char}s
given in order, after interpreting escape codes per
\subsubitemref{Rune constants}{17}.

\specsubsubitem
If the second form of \nonterminal{string-section} is used, the string's
\textit{data} field shall refer to a \hbox{UTF-8} encoded sequence of Unicode
codepoints, ascertained by encoding the sequence of
\nonterminal{rawstring-char}s given in order.

\specsubsubitem
If a \nonterminal{string-constant} consists of more than one
\nonterminal{string-section}, the string's \textit{data} field shall refer to
a \hbox{UTF-8} encoded sequence of Unicode codepoints, ascertained by
concatenating the \textit{data} fields of the \nonterminal{string-section}s
given in order.

\specsubsubitem
The \textit{length} and \textit{capacity} fields shall be set to the length in
octets of the encoded \hbox{UTF-8} data.

\specsubsection{Array literals}

\begin{grammar}
\nonterminaldef{array-literal} \\
	\terminal{[} \optional{\nonterminal{array-members}} \terminal{]} \\

\nonterminaldef{array-members} \\
	\nonterminal{expression} \optional{\terminal{,}} \\
	\nonterminal{expression} \terminal{...} \\
	\nonterminal{expression} \terminal{,} \nonterminal{array-members} \\
\end{grammar}

\specsubsubitem
An \nonterminal{array-literal} expression produces a value of an array type.
The type of each \nonterminal{expression} shall be uniform and shall
determine the member type of the array value, and the length of the array type
shall be defined by the number of members.

\specsubsubitem
If a type hint has been provided to an array literal which is an array type (or
a type alias which represents an array type), the member type will be inferred
from this array type. The initializer expressions for each value among
\nonterminal{array-members} shall receive this member type as a type hint. If
the \nonterminal{array-members} is not specified, a type hint must be provided.

\specsubsubitem
The \nonterminal{array-members} shall be evaluated in the order in which they
appear in the \nonterminal{array-literal}, and the \textit{N}th item shall
provide the value for the \textit{N}th array member.

\specsubsubitem
If the \terminal{...} form is used, the result's array type shall be expandable.
If a type hint is available, it shall not be of a context-defined array type.

\specsubsection{Struct literals}

\begin{grammar}
\nonterminaldef{struct-literal} \\
	\terminal{struct} \terminal{\{} \nonterminal{field-values} \optional{\terminal{,}} \terminal{\}} \\
	\nonterminal{identifier} \terminal{\{} \nonterminal{struct-initializer} \terminal{\}} \\

\nonterminaldef{struct-initializer} \\
	\nonterminal{field-values} \optional{\terminal{,}} \\
	\nonterminal{field-values} \terminal{,} \terminal{...} \\
	\terminal{...} \\

\nonterminaldef{field-values} \\
	\nonterminal{field-value} \\
	\nonterminal{field-values} \terminal{,} \nonterminal{field-value} \\

\nonterminaldef{field-value} \\
	\nonterminal{name} \terminal{=} \nonterminal{expression} \\
	\nonterminal{name} \terminal{:} \nonterminal{type} \terminal{=} \nonterminal{expression} \\
	\nonterminal{struct-literal} \\
\end{grammar}

\specsubsubitem
A \nonterminal{struct-literal} produces a value of a struct type. The first
form is the \textit{plain form}, and the second form is the \textit{named form}.

\specsubsubitem
If the plain form is given, the result type shall be a struct type defined by
the \nonterminal{field-value}s, in order, with their identifiers and types
explicitly specified. The first form of \nonterminal{field-value} shall not be
used in such a struct.

\specsubsubitem
If the named form is given, the \nonterminal{identifier} shall identify a type
alias (see \subsecref{Type aliases}) which refers to a struct or union type.
The result type shall be this alias type.

\specsubsubitem
Each \nonterminal{field-value} shall specify a field by its \nonterminal{name},
and assign that field in the result value to the result of the expression
given. The type of the named field, via the named type alias in the first form,
or the given type in the second form, shall be provided to the initializer
expression as a type hint. The \nonterminal{field-values} shall be evaluated in
the order in which they appear in the \nonterminal{struct-literal}.

\specsubsubitem
If \terminal{...} is not given, \nonterminal{field-values} shall be
\textit{exhaustive}, and include every field of the result type exactly once.
Otherwise, a diagnostic message shall be printed and the translation phase
shall abort.

\specsubsubitem
If \terminal{...} is given, any fields of the result type which are not
included in \nonterminal{field-values} shall be initialized to their default
values. Each included field shall only be named once. If a field is omitted
which does not have a default value, a diagnostic message shall be printed and
the translation phase shall abort.

\specsubsubitem
If the named type is a union type, the \nonterminal{field-values} shall be
empty and \terminal{...} provided. The union type must have a default value.

\specsubsubitem
If the \nonterminal{struct-literal} form of the \nonterminal{field-value} is
given, its fields shall be interpreted as fields of the parent struct.

\informative{The following values are equivalent: \\
\code{struct \{ a: int = 10, b: int = 20 \}} \\
\code{struct \{ a: int = 10, struct \{ b: int = 20 \} \}}}

\specsubsection{Tuple literals}

\begin{grammar}
\nonterminaldef{tuple-literal} \\
	\terminal{(} \nonterminal{tuple-items} \terminal{)} \\

\nonterminaldef{tuple-items} \\
	\nonterminal{expression} \terminal{,} \nonterminal{expression} \optional{\terminal{,}} \\
	\nonterminal{expression} \terminal{,} \nonterminal{tuple-items} \\
\end{grammar}

\specsubsubitem
A \nonterminal{tuple-literal} produces a value of a tuple type. The result type
shall be the tuple type described by the types of its \nonterminal{expression}s
in the order that they appear.

\specsubsubitem
If a type hint is available and the hint is a tuple type (or a type alias which
represents a tuple type), the tuple items shall receive as hints the types of
the respective tuple sub-types in the order that they appear.

\specsubsubitem
The \nonterminal{tuple-items} shall be evaluated in the order in which they
appear in the \nonterminal{tuple-literal}, and the \textit{N}th item shall
provide the value for the \textit{N}th tuple item.

\specsubsection{Plain expressions}

\begin{grammar}
\nonterminaldef{plain-expression} \\
	\nonterminal{identifier} \\
	\nonterminal{constant} \\
	\nonterminal{array-literal} \\
	\nonterminal{struct-literal} \\
	\nonterminal{tuple-literal} \\

\nonterminaldef{nested-expression} \\
	\nonterminal{plain-expression} \\
	\terminal{(} \nonterminal{expression} \terminal{)} \\
\end{grammar}

\specsubsubitem
\nonterminal{plain-expression} is an expression class which represents its
result value "plainly". In the case of constants and literals, the value is
represented by the result of those expressions. In the case of an
\nonterminal{identifier}, the expression produces the value of the identified
object.

\specsubsubitem
\nonterminal{nested-expression} is an expression class provided to allow the
programmer to overcome undesirable associativity between operators.

\specsubsection{Allocations}

\begin{grammar}
\nonterminaldef{allocation-expression} \\
	\terminal{alloc} \terminal{(} \nonterminal{expression} \terminal{)} \\
	\terminal{alloc} \terminal{(} \nonterminal{expression} \terminal{...} \terminal{)} \\
	\terminal{alloc} \terminal{(} \nonterminal{expression} \terminal{,} \nonterminal{expression} \terminal{)} \\
	\terminal{free} \terminal{(} \nonterminal{expression} \terminal{)} \\
\end{grammar}

\specsubsubitem
An \terminal{alloc} expression allocates an object at runtime and initializes
its value to the first \nonterminal{expression} (the \textit{initializer}). The
result type of the \textit{initializer} provides the allocation's
\textit{object type}. The result type of the allocation expression is, usually,
a pointer type whose secondary type is the object type.

\specsubsubitem
The first form is the object allocation form. If the allocation expression is
provided a type hint of a pointer type, the secondary type of this pointer type
shall be provided to the initializer as its type hint. The execution
environment will allocate sufficient storage for the object type and initialize
its value using the initializer expression, then set its result to a pointer to
the new object. The object type must have a defined size which is greater than
zero.

\specsubsubitem
The second form is the copy allocation form. In this form, the initializer will
provide an object type which is either a slice or array type (or an alias
thereof). The execution environment will allocate storage sufficient to store
an array equal in length to the initializer, then copy the initializer's slice
or array items into this array. The result value shall be set to a slice object
whose secondary type is equal to the secondary type of the initializer's result
type, whose data field refers to the new array, and whose length and capacity
fields are set to the length of the array.

\specsubsubitem
The third form is the slice allocation form. In this form, the initializer will
provide an object type which is either a slice or array type (or an alias
thereof), and the second \nonterminal{expression} provides the desired
\textit{capacity} for a new slice. The capacity shall be assignable to the
\nonterminal{size} type. The execution environment shall choose a capacity equal
to or greater than this term, then provision an array of that length and set
each $N$th value to the $N$th value of the initializer, for each value of $N$
between $0$ (inclusive) and the length of the initializer (exclusive). The
result of the \nonterminal{allocation-expression} shall be a slice whose data
field refers to this array, whose length is equal to the length of the
initializer, and whose capacity is set to the selected capacity.

\specsubsubitem
In the slice allocation form, if the array specified by the initializer is
\textit{expandable}, the second expression shall be used as the \textit{length}
instead of the capacity. The execution environment shall choose a capacity
equal to or greater than this value, then for each $N$th value of the allocated
array from the length of the initializer ($L$, inclusive) to the specified
\textit{length} ($L'$) shall be initialized to the value at $L-1$ in the
initializer. The length field of the resulting slice value shall be set to the
$L'$.

\informative{The following allocates a slice of length 10 with all values set to zero:}

\code{let x: []int = alloc([0...], 10)}

\specsubsubitem
In the \terminal{alloc} form, if the execution environment is unable to
allocate sufficient storage for the requested type, the execution environment
shall print a diagnostic message and abort. If the type hint is a nullable
pointer type, the result type of the allocation expression shall also be
nullable, and \terminal{null} shall be returned instead of aborting if
sufficient storage cannot be provided.

\specsubsubitem
The \terminal{free} form shall discard resources previously allocated with a
\terminal{alloc} expression, freeing them for future use. The
\nonterminal{expression} shall evaluate to a pointer type, in which case the
object referred to by the pointer shall be freed, or a slice type, in which
case the array referred to by its data field shall be freed.

\specsubsection{Assertions}

\begin{grammar}
\nonterminaldef{assertion-expression} \\
	\terminal{assert} \terminal{(} \nonterminal{expression} \terminal{)} \\
	\terminal{assert} \terminal{(} \nonterminal{expression} \terminal{,} \nonterminal{expression} \terminal{)} \\
	\terminal{abort} \terminal{(} \optional{\nonterminal{expression}} \terminal{)} \\

\nonterminaldef{static-assertion-expression} \\
	\terminal{static} \nonterminal{assertion-expression} \\
\end{grammar}

\specsubsubitem
An \nonterminal{assertion-expression} is used to validate an assumption by the
programmer by \textit{asserting} its truth.

\specsubsubitem
In the first two forms, the first \nonterminal{expression} shall be evaluated in
the execution environment. If the expression evalutes to false, a diagnostic
message shall be printed and the execution phase aborted. The expression shall
have type \terminal{bool}, which shall be provided to it as a type hint. The
result type of these forms is \terminal{void}.

\specsubsubitem
In the second \terminal{assert} form, and in the \terminal{abort} form if
present, the final \nonterminal{expression} shall have type \terminal{str},
which shall be provided to it as a type hint. The contents of the string shall
be included in the diagnostic message.

\specsubsubitem
In the \terminal{abort} form, the execution environment shall unconditionally
print a diagnostic message and abort. The result type of this form is
\terminal{never}.

\specsubsubitem
A \nonterminal{static-assertion-expression} is identical to an
\nonterminal{assertion-expression}, except that the assertion is run in the
translation environment rather than the execution environment, and the result
type is always \terminal{void}.

\specsubsection{Calls}

\begin{grammar}
\nonterminaldef{call-expression} \\
	\nonterminal{postfix-expression} \terminal{(} \optional{\nonterminal{argument-list}} \terminal{)} \\

\nonterminaldef{argument-list} \\
	\nonterminal{expression} \optional{\terminal{,}} \\
	\nonterminal{expression} \terminal{...} \\
	\nonterminal{expression} \terminal{,} \nonterminal{argument-list} \\
\end{grammar}

\specsubsubitem
A \nonterminal{call-expression} shall invoke a function in the execution
environment and its result shall be a value of the type specified by the
\nonterminal{postfix-expression}'s function result type. This evaluation shall
include any necessary side-effects per \subsubitemref{Program execution}{1}.

\specsubsubitem
The result type of the \nonterminal{postfix-expression} shall be restricted to a
set which includes all function types which do not have the \terminal{@init},
\terminal{@fini}, or \terminal{@test} attributes set, as well as non-nullable
pointers whose secondary type is included in the set.

\informative{The result type of the \nonterminal{postfix-expression} can be a
function, a pointer to a function, a pointer to a pointer to a function, and so
on.}

\specsubsubitem
The function invoked shall be the function object the
\nonterminal{postfix-expression} refers to, selecting that object indirectly via
any number of pointer types if appropriate.

\specsubsubitem
The \nonterminal{argument-list} shall be a list of expressions whose types
shall be assignable to the types of the invoked function's parameters, in the
order that they are declared in the invoked function's result type. The types
specified in the function's prototype shall be provided as type hints to each
argument expression as appropriate.

\specsubsubitem
The execution environment shall evaluate the \nonterminal{argument-list},
ordered such that any side-effects of evaluating the arguments occur in the
order that the arguments are listed, to obtain the parameter values required to
invoke the function.

\specsubsubitem
If the invoked function uses Hare-style variadism, the
\nonterminal{argument-list} shall provide zero or more arguments following the
last non-variadic parameter, all of which must be assignable to the type of the
variadic parameter.

\specsubsubitem
If the final argument uses the \terminal{...} form, it must occupy the position of a
variadic parameter and be of a slice or array type. The implementation shall
interpret this value as the list of variadic parameters.

\specsubsubitem
If the invoked function uses C-style variadism, the function may provide zero
or more arguments following the final parameter. These arguments shall be of a
type with a non-zero size, but are otherwise unconstrained.

\specsubsubitem
The specific means by which the invoked function assumes control of the
execution environment, and by which the arguments are provided to it, is
implementation-defined.

\informative{This is generally provided by the target's ABI specification.}

\specsubsection{Measurements}

\begin{grammar}
\nonterminaldef{measurement-expression} \\
	\nonterminal{align-expression} \\
	\nonterminal{size-expression} \\
	\nonterminal{length-expression} \\
	\nonterminal{offset-expression} \\

\nonterminaldef{align-expression} \\
	\terminal{align} \terminal{(} \nonterminal{type} \terminal{)} \\

\nonterminaldef{size-expression} \\
	\terminal{size} \terminal{(} \nonterminal{type} \terminal{)} \\

\nonterminaldef{length-expression} \\
	\terminal{len} \terminal{(} \nonterminal{expression} \terminal{)} \\

\nonterminaldef{offset-expression} \\
	\terminal{offset} \terminal{(} \nonterminal{field-access-expression} \terminal{)} \\
\end{grammar}

Forward references: \subsecref{Field access}

\specsubsubitem
A \nonterminal{measurement-expression} is used to measure objects. The result
type shall be \terminal{size}.

\specsubsubitem
The \terminal{align} expression shall compute the \textit{alignment} of the specified
\nonterminal{type}. If \nonterminal{type} is a type of undefined alignment or a
type of size 0, a diagnostic message shall be printed and translation shall
abort.

\specsubsubitem
The \terminal{size} expression shall compute the \textit{size} of the specified
\nonterminal{type}. If \nonterminal{type} is a type of undefined size, a
diagnostic message shall be printed and translation shall abort.

\specsubsubitem
The \terminal{len} expression shall compute the \textit{length} of a bounded
array, the \code{length} field of a slice object, or the \code{length} field of
a \terminal{str}, referred to by \nonterminal{expression}. If an unbounded array
object is given, the translation environment shall print a diagnostic message
and abort.

\specsubsubitem
The object used for a length expression shall be the array, slice, or
\terminal{str} object the \nonterminal{expression} refers to, selecting that
object indirectly via any number of non-nullable pointer types if appropriate.

\specsubsubitem
The \terminal{offset} expression shall determine the struct or tuple field
which would be accessed by \nonterminal{field-access-expression} and compute
its \textit{offset}.

\specsubsection{Field access}

\begin{grammar}
\nonterminaldef{field-access-expression} \\
	\nonterminal{postfix-expression} \terminal{.} \nonterminal{name} \\
	\nonterminal{postfix-expression} \terminal{.} \nonterminal{integer-constant} \\
\end{grammar}

\specsubsubitem
A \nonterminal{field-access-expression} is used to access fields of
\subsecref{Struct and union types} and \subsecref{Tuple types}. The result type
of the \nonterminal{postfix-expression} shall be constrained to a set which
includes all struct, union, and tuple types, as well as non-nullable pointers
whose secondary type is included in the set.

\informative{The result type of the \nonterminal{postfix-expression} can be a
struct or union or tuple, a pointer to a struct or union or tuple, a pointer to
a pointer to a struct or union or tuple, and so on.}

\specsubsubitem
The object from which the field is selected shall be the struct or union object
the \nonterminal{postfix-expression} refers to, selecting that object indirectly
via any number of pointer types if appropriate.

\specsubsubitem
If the \nonterminal{postfix-expression}'s result type is a union type, the
first form shall be used. The result of the
\nonterminal{field-access-expression} shall be the union's storage area
interpreted as the type of the field named by \nonterminal{name}, and the
result type of the expression shall be the type of the named field.

\specsubsubitem
If the \nonterminal{postfix-expression}'s result type is a struct type, the
first form shall be used. The result of the
\nonterminal{field-access-expression} shall be the value stored in the
\nonterminal{name} field of the result of the \nonterminal{postfix-expression},
and the result type of the expression shall be the type of the named field.

\specsubsubitem
If the \nonterminal{postfix-expression}'s result type is a tuple type,
the second form shall be used. The result of the
\nonterminal{field-access-expression} shall be the $N$th value stored in the
tuple which is the result of the \nonterminal{postfix-expression}, and the
result type of the expression shall be the type of the $N$th value.

\specsubsubitem
If the type of the struct object in the first term has the \terminal{const}
flag, the result type shall also have the \terminal{const} flag set, regardless
of the flag's value on the type of the named field.

\specsubsection{Indexing}

\begin{grammar}
\nonterminaldef{indexing-expression} \\
	\nonterminal{postfix-expression} \terminal{[} \nonterminal{expression} \terminal{]} \\
\end{grammar}

\specsubsubitem
An \nonterminal{indexing-expression} shall access a specific value of a slice
or array type. The \nonterminal{expression} shall have a result type of
\terminal{size}, which shall be provided to it as a type hint. The result type
of the \nonterminal{postfix-expression} shall be constrained to a set which
includes all slice and array types whose secondary type has definite size, as
well as non-nullable pointers whose secondary type is included in the set.

\informative{The result type of the \nonterminal{postfix-expression} can be a
slice or array, a pointer to a slice or array, a pointer to a pointer to a
slice or array, and so on.}

\specsubsubitem
The object from which the field is selected shall be the slice or array object
the \nonterminal{postfix-expression} refers to, selecting that object indirectly
via any number of pointer types if appropriate.

\specsubsubitem
The result type of an \nonterminal{indexing-expression} is the secondary type
of the slice or array type given by the \nonterminal{postfix-expression} result
type.

\specsubsubitem
If the type of the array or slice object in the first term has the
\terminal{const} flag, the result type shall also have the \terminal{const}
flag set, regardless of the flag's value on the secondary type.

\specsubsubitem
The execution environment shall compute the result of
\nonterminal{expression} to obtain $N$ for selecting the \textit{N} per the
algorithm given in \subsecref{Slice and array types}.

\specsubsubitem
The execution environment shall perform a \textit{bounds test} on the value of
$N$ to ensure it falls within the acceptable range for the given slice or array
type. It shall test that $N < Z$, where $Z$ is the length of the bounded array
type, or the \code{length} field of the slice, whichever is appropriate.  For
unbounded array types, the bounds test shall not occur. If the bounds test
fails, a diagnostic message shall be printed and the execution environment
shall abort.

The implementation may perform a bounds test in the translation environment if
it is able, and print a diagnostic message and abort the translation environment
if it fails.

\specsubsection{Slicing}

\begin{grammar}
\nonterminaldef{slicing-expression} \\
	\nonterminal{postfix-expression} \terminal{[} \optional{\nonterminal{expression}} \terminal{..} \optional{\nonterminal{expression}} \terminal{]} \\
\end{grammar}

\specsubsubitem
A \nonterminal{slicing-expression} shall have a result type of
\nonterminal{slice}, which is computed a subset of a slice or array object.
Each optional \nonterminal{expression}s shall, if present, have a result type of
\terminal{size}, which shall be provided to it as a type hint. The result type
of the \nonterminal{postfix-expression} shall be constrained to a set which
includes all slice and array types, as well as non-nullable pointers whose
secondary type is included in the set.

\informative{The result type of the \nonterminal{postfix-expression} can be a
slice or array, a pointer to a slice or array, a pointer to a pointer to a
slice or array, and so on.}

\specsubsubitem
The object from which the field is selected shall be the slice or array object
the \nonterminal{postfix-expression} refers to, selecting that object indirectly
via any number of pointer types if appropriate.

\specsubsubitem
The first \nonterminal{expression} shall compute value $L$, and the second shall
compute $H$. If absent, $L = 0$ and $H = \code{length}$, where \code{length}
shall be equal to the length of a bounded array type or the length of a slice
type, represented in either case by the result of
\nonterminal{postfix-expression}. If $H$ is not specified, and
\nonterminal{postfix-expression} is of an unbounded array type, the translation
environment shall abort.

\specsubsubitem
The resulting slice value shall have its \code{data} field set from, in the case
of an array type, the address of the array; or in the case of a slice type, the
\code{data} value of the source object; plus $L \times S$, where $S$ is the
size of the slice or array's secondary type.

\specsubsubitem
The resulting slice value shall have its \code{length} field set to $H - L$,
and its capacity field set to the \code{length} of the source object minus $L$.
If the length of the object is undefined, the capacity shall be set to $H - L$
instead.

\specsubsubitem
The execution environment shall perform a \textit{bounds test} on the values of
$L$ and $H$ to ensure they fall within the acceptable range of the given slice
or array type. It shall test that $L < H+1$. If \nonterminal{postfix-expression}
isn't of an unbounded array type, it shall also test that $H < \code{length}+1$.
If the bounds test fails, a diagnostic message shall be printed and the
execution environment shall abort.

The implementation may perform a bounds test in the translation environment if
it is able, and print a diagnostic message and abort the translation environment
if it fails.

\specsubsubitem
The secondary type of the resulting slice type shall be equivalent to the
secondary type of the slice or array type given by
\nonterminal{postfix-expression}. The resulting slice type shall inherit the
\nonterminal{const} attribute from this type.

\specsubsection{Appending}

\begin{grammar}
\nonterminaldef{slice-mutation-expression} \\
	\nonterminal{append-expression} \\
	\nonterminal{insert-expression} \\
	\nonterminal{delete-expression} \\

\nonterminaldef{append-expression} \\
	\optional{\terminal{static}} \terminal{append} \terminal{(} \nonterminal{object-selector} \terminal{,} \nonterminal{expression} \terminal{)} \\
	\optional{\terminal{static}} \terminal{append} \terminal{(} \nonterminal{object-selector} \terminal{,} \nonterminal{expression} \terminal{...} \terminal{)} \\
	\optional{\terminal{static}} \terminal{append} \terminal{(} \nonterminal{object-selector} \terminal{,} \nonterminal{expression} \terminal{,} \nonterminal{expression} \terminal{)} \\
\end{grammar}

\specsubsubitem
An \nonterminal{append-expression} shall append some number of values to the
slice object specified by the first term, which shall not be provided a type
hint. Valid result types for \nonterminal{object-selector} shall either be a
slice type, or a non-nullable pointer to a valid result type. The selected
object shall be mutable and non-const. The member type of this slice shall be
the \nonterminal{append-expression}'s \textit{member type}. The result type of
an \nonterminal{append-expression} shall be \terminal{void}.

\specsubsubitem
In the first form, the type of the second term shall be assignable to the member
type, which shall be provided to it as a type hint.

\specsubsubitem
In the second form, the second term shall have a valid result type which
shall be a bounded array or slice whose member type is the
\nonterminal{append-expression}'s member type, or a non-nullable pointer to a
valid result type. The second term shall be provided the object type as a type
hint.

\specsubsubitem
In the third form, the second term shall be an expandable array whose member
type is the \nonterminal{append-expression}'s member type, and the third term
shall be assignable to \terminal{size}. The second term shall be provided the
object type as a type hint, and the third term shall be provided \terminal{size}
as a type hint. The length of the expandable array shall be given by the third
term.

\specsubsubitem
The second term of an \terminal{append} expression is used to obtain the
\textit{append values}, of which there may be none. In the first form, the
value of the second term shall be used as the sole append value. In the second
and third forms, the data of the array or slice given in the second term shall
be used as the append values.

\specsubsubitem
The second term shall be evaluated after all other terms. If present, the third
term shall be evaluated after the \nonterminal{object-selector}.

\specsubsubitem
The append values shall be obtained after the second term is evaluated. Once
obtained, the append values shall not change as a result of any side-effects.

\specsubsubitem
After the append values are obtained, the execution environment shall ensure
that the capacity of the object is at least $N \geq L_1 + L_2$, where $L_1$ is
the object length and $L_2$ is the number of append values, reallocating the
underlying storage if necessary. If sufficient storage cannot be allocated, the
execution environment shall print a diagnostic message and abort. The
\code{length} field of the slice object shall be set to $L_1 + L_2$.

\specsubsubitem
After ensuring sufficient space is available for the new items, the execution
environment shall assign values of the slice object from index $N = L_1$
(inclusive) to $N = L_1 + L_2$ (exclusive) from each consecutive append value.

\specsubsubitem
The \terminal{static} forms shall be equivalent to the non-static forms except
that they shall never cause the underlying slice to be reallocated. If the
operation would require more space than the capacity of the slice provides, the
execution environment shall print a diagnostic message and abort.

\specsubsection{Inserting}

\begin{grammar}
\nonterminaldef{insert-expression} \\
	\optional{\terminal{static}} \terminal{insert} \terminal{(} \nonterminal{indexing-expression} \terminal{,} \nonterminal{expression} \terminal{)} \\
	\optional{\terminal{static}} \terminal{insert} \terminal{(} \nonterminal{indexing-expression} \terminal{,} \nonterminal{expression} \terminal{...} \terminal{)} \\
\end{grammar}

% TODO: Do we want/need insert(x[5], [0...], 10)?

\specsubsubitem
An \nonterminal{insert-expression} shall insert some number of values into the
slice object specified by the first term, which shall not be provided a type
hint. The \nonterminal{indexing-expression} specifies both the slice object and
an index at which the new values shall be inserted (the \textit{insertion
index}). The selected object shall be mutable and non-const, and shall not have
an array type. The member type of this slice shall be the expression's
\textit{member type}. The result type of an \nonterminal{insert-expression}
shall be \terminal{void}.

\specsubsubitem
The bounds test described in \subsecref{Indexing} shall be performed on the
first term, except it shall instead test that $N < Z+1$.

\specsubsubitem
In the first form, the type of the second term shall be assignable to the member
type, which shall be provided to it as a type hint.

\specsubsubitem
In the second form, the second term shall have a valid result type which
shall be a bounded array or slice whose member type is the
\nonterminal{insert-expression}'s member type, or a non-nullable pointer to a
valid result type. The second term shall be provided the object type as a type
hint.

\specsubsubitem
The second term of an \nonterminal{insert-expression} is used to obtain the
\textit{insert values}, of which there may be none. In the first form, the
value of the second term shall be used as the sole insert value. In the second
form, the data of the array or slice given in the second term shall be used as
the insert values.

\specsubsubitem
The second term shall be evaluated after the first term.

\specsubsubitem
The insert values shall be obtained after the second term is evaluated. Once
obtained, the insert values shall not change as a result of any side-effects.

\specsubsubitem
After the insert values are obtained, the execution environment shall ensure
that the capacity of the object is at least $N \geq L_1 + L_2$, where $L_1$ is
the object length and $L_2$ is the number of insert values, reallocating the
underlying storage if necessary. If sufficient storage cannot be allocated, the
execution environment shall print a diagnostic message and abort. The
\code{length} field of the slice object shall be set to $L_1 + L_2$.

\specsubsubitem
After ensuring sufficient space is available for the new items, the execution
environment shall copy or move each item $N$ such that from $N=I$ (inclusive)
to $N=I+L_2$ (exclusive), where $I$ is the insertion index, each item is placed
at $N+L_2$.

\specsubsubitem
The execution environment shall then assign values of the object slice from
index $N = I$ (inclusive) to $N = I+L_2$ (exclusive) from each consecutive
insert value.

\specsubsubitem
The \terminal{static} forms shall be equivalent to the non-static forms except
that they shall never cause the underlying slice to be reallocated. If the
operation would require more space than the capacity of the slice provides, the
execution environment shall print a diagnostic message and abort.

\specsubsection{Deleting}

\begin{grammar}
\nonterminaldef{delete-expression} \\
	\optional{\terminal{static}} \terminal{delete} \terminal{(} \nonterminal{indexing-expression} \terminal{)} \\
	\optional{\terminal{static}} \terminal{delete} \terminal{(} \nonterminal{slicing-expression} \terminal{)} \\
\end{grammar}

\specsubsubitem
A \nonterminal{delete-expression} shall remove some number of values from the
specified slice object. The selected object shall be mutable and non-const, and
shall not have an array type. The result type of a
\nonterminal{delete-expression} shall be \terminal{void}.

\specsubsubitem
Should a \nonterminal{indexing-expression} be used, it shall specify both the
slice object and an index $L$, and $H$ shall be set to $L+1$. Should a
\nonterminal{slicing-expression} be used, it shall specify both the slice object
and a range spanning from $L$ to $H$. In either case, the appropriate bounds
test shall be performed, as described in \subsecref{Indexing} and
\subsecref{Slicing}.

\specsubsubitem
The execution environment shall then copy or move each item $N$ in the slice
such that from $N=H$ (inclusive) to $N=Z$ (exclusive), where $Z$ is the value of
the slice object's \code{length} field, each item is placed at $N+L-H$. It shall
then subtract $H-L$ from the value of the slice object's \code{length} field.

\specsubsubitem
Unless the \terminal{static} form is used, the execution environment may
decrease the slice object's capacity, re-allocating its data field if necessary,
in order to reclaim unused memory. This re-allocation, if performed, shall not
fail. The slice object shall be updated to reflect the new capacity if
necessary.

\specsubsection{Error propagation}

\begin{grammar}
\nonterminaldef{error-propagation} \\
	\nonterminal{postfix-expression} \terminal{?} \\
	\nonterminal{postfix-expression} \terminal{!} \\
\end{grammar}

\specsubsubitem
\terminal{?} and \terminal{!} are the error propagation operators. The
\nonterminal{postfix-expression} shall have a result type which is
a tagged union type which has a type with the error flag set
among its member types.

\specsubsubitem
The result type of an error propagation expression shall be the same as the
type of the \nonterminal{postfix-expression}, without its error cases, or
\terminal{void} if no non-error types remain. The result is a tagged union
whose member types are the subset of the original type which do not include the
error flag; or, if there is only one such type, that type without a tagged
union; or, if there are no such types, \terminal{void}. If the original type is
not a tagged union type, the translation phase shall abort with a diagnostic
message.

\specsubsubitem
An error propagation expression shall perform an \textit{error test} which
checks if the result value of the \nonterminal{postfix-expression} is of a
non-error type. If so, that value shall be the result of the error propagation
expression.

\specsubsubitem
In the \terminal{?} form, if the error test fails (i.e. an error is found), the
error type shall be assignable to the current function's return type, and that
value shall be returned from the function. This form shall not be used within
the expression tree formed by a \nonterminal{defer-expression}.

\specsubsubitem
In the \terminal{!} form, if the error test fails (i.e. an error is found), the
execution environment shall print a diagnostic message and abort.

\specsubsubitem
If a type hint is provided to the error propagation expression, the same type
shall be provided to the \nonterminal{postfix-expression}.

\specsubsection{Postfix expressions}

\begin{grammar}
\nonterminaldef{postfix-expression} \\
	\nonterminal{nested-expression} \\
	\nonterminal{call-expression} \\
	\nonterminal{field-access-expression} \\
	\nonterminal{indexing-expression} \\
	\nonterminal{slicing-expression} \\
	\nonterminal{error-propagation} \\

\nonterminaldef{object-selector} \\
	\nonterminal{identifier} \\
	\nonterminal{indexing-expression} \\
	\nonterminal{field-access-expression} \\
\end{grammar}

\specsubsubitem
\nonterminal{postfix-expression} is an expression class for expressions whose
operators use postfix notation.

\specsubsubitem
\nonterminal{object-selector} defines a subset of postfix expressions which
refer to objects, for use in other parts of the grammar.

\specsubsection{Variadic expressions}

\begin{grammar}
\nonterminaldef{variadic-expression} \\
	\terminal{vastart} \terminal{(} \terminal{)} \\
	\terminal{vaarg} \terminal{(} \nonterminal{object-selector} \terminal{)} \\
	\terminal{vaend} \terminal{(} \nonterminal{object-selector} \terminal{)} \\
\end{grammar}

\specsubsubitem
Variadic expressions are provided for compatibility with the C programming
language as specified by ISO/IEC 9899. Implementation support is optional:
implementations which do not provide C ABI compatibility must parse these
expressions, print a diagnostic message, and abort.

\informative{These expressions are used only for C compatibility. "Hare-style"
variadism is handled separately.}

\specsubsubitem
The \terminal{vastart} expression shall have a result type of
\terminal{valist}, and may only be used within a function body which uses
C-style variadism. It will initialize a \terminal{valist} in an
implementation-defined manner, such that the first use of \terminal{vaarg} on
the new object would return the first variadic parameter.

\specsubsubitem
The \terminal{vaarg} expression accepts an \nonterminal{object-selector} which
must be of the \terminal{valist} type. The expression shall also be provided a
type hint, which shall have a defined size and alignment.

\specsubsubitem
When the \terminal{vaarg} expression is evaluated, the following conditions
(\textit{runtime constraints}) must hold:

\begin{enumerate}
\item Any previous evaluation of a \terminal{vaarg} expression on the same
	\nonterminal{object-selector} didn't violate any runtime constraints
\item There exists a variadic parameter that has yet to be consumed by the
	\nonterminal{object-selector}
\item The type of the next variadic parameter and the type hint have the same
	size and alignment
\item The type of the next variadic parameter is assignable to the type hint
	(ignoring type flags), or the type of the next variadic parameter and
	the type hint are both integer types, or the type of the next variadic
	parameter is either a pointer type or \terminal{null} and the type hint
	is a pointer type
\end{enumerate}

\specsubsubitem
If no runtime constraints are violated, the result of the \terminal{vaarg}
expression shall be the next variadic parameter from the \terminal{valist}
object, and the parameter shall be consumed by the object such that another
\terminal{vaarg} expression on the same \nonterminal{object-selector} would
yield the successive variadic parameter, if one exists. If any runtime
constraint is violated, behavior of the \terminal{vaarg} expression is
undefined.

\specsubsubitem
The \terminal{vaend} expression accepts an \nonterminal{object-selector} which
must be of the \terminal{valist} type. The object must have previously been
initialized with \terminal{vastart}. The implementation shall finalize the
\terminal{valist} object in an implementation-defined manner. Any further
evaluated \terminal{vaarg} expression on the object is invalid, unless the
object is first re-initialized with \terminal{vastart}. The result type of this
expression is \terminal{void}.

\specsubsection{Builtin expressions}

\begin{grammar}
\nonterminaldef{builtin-expression} \\
	\nonterminal{allocation-expression} \\
	\nonterminal{assertion-expression} \\
	\nonterminal{measurement-expression} \\
	\nonterminal{slice-mutation-expression} \\
	\nonterminal{postfix-expression} \\
	\nonterminal{static-assertion-expression} \\
	\nonterminal{variadic-expression} \\
\end{grammar}

\specsubsection{Unary arithmetic}

\begin{grammar}
\nonterminaldef{unary-expression} \\
	\nonterminal{builtin-expression} \\
	\nonterminal{compound-expression} \\
	\nonterminal{match-expression} \\
	\nonterminal{switch-expression} \\
	\nonterminal{unary-operator} \nonterminal{unary-expression} \\

\nonterminaldef{unary-operator} \oneof \\
	\terminal{-}
	\terminal{\textasciitilde}
	\terminal{!}
	\terminal{*}
	\terminal{\&}
\end{grammar}

\specsubsubitem
A unary expression applies a \nonterminal{unary-operator} to a single value.

\specsubsubitem
The \terminal{-} operator shall perform a unary negation operation. The result
type shall be equivalent to the type of \nonterminal{unary-expression}, which
shall be of a numeric type.

\specsubsubitem
The \terminal{\textasciitilde} operator shall perform a bitwise NOT operation,
inverting each bit of the value. Its result type shall be equivalent to the
type of \nonterminal{unary-expression}, which shall be of an integer type.

\specsubsubitem
The \terminal{!} operator shall perform a logical NOT operation. The result
type, and the type of \nonterminal{unary-expression}, shall both be
\terminal{bool}. If the \nonterminal{unary-expression} is \terminal{true}, the
result shall be \terminal{false}, and vice-versa.

\specsubsubitem
The \terminal{*} operator shall dereference a pointer, and return the object it
references.  The type of \nonterminal{unary-expression} shall be a pointer
type, and the result type shall be the pointer's secondary type. The pointer
type shall not be \textit{nullable}, and the pointer's secondary type shall have
a defined size.

\specsubsubitem
The \terminal{\&} operator shall take the address of an object. The result type
shall be a pointer whose secondary type is the type of the object selected by
the \nonterminal{unary-expression}. If the \nonterminal{unary-expression} is not
an \nonterminal{object-selector}, the ensuing pointer shall only be valid within
the current function.

\informative{The following table is informative.}

\begin{tabular}{r | l }
Operator & Meaning \\
\hline
\terminal{-} & Negation \\
\terminal{\textasciitilde} & Bitwise NOT \\
\terminal{!} & Logical NOT \\
\terminal{*} & Dereference pointer \\
\terminal{\&} & Take address \\
\end{tabular}

\specsubsection{Casts and type assertions}

\begin{grammar}
\nonterminaldef{cast-expression} \\
	\nonterminal{unary-expression} \\
	\nonterminal{cast-expression} \terminal{:} \nonterminal{type} \\
	\nonterminal{cast-expression} \terminal{as} \nonterminal{assertion-target} \\
	\nonterminal{cast-expression} \terminal{is} \nonterminal{assertion-target} \\

\nonterminaldef{assertion-target} \\
	\nonterminal{type} \\
	\terminal{null}
\end{grammar}

\specsubsubitem
A cast expression interrogates or converts the type of an object. The first
form illustrates the precedence. The second and third forms (\terminal{:} and
\terminal{as}) have a result type specified by the \nonterminal{type}; and the
fourth form (\terminal{is}) has a result type of \terminal{bool}.

\specsubsubitem
Each form shall provide the specified \nonterminal{type} as a type hint to its
\nonterminal{cast-expression}.

\specsubsubitem
The second form is a \textit{type cast}, and shall not fail. It shall cause the
execution environment to convert or interpret the value as another type.

\specsubsubitem
A type which may be cast to another type is considered \textit{castable} to
that type.

\specsubsubitem
All types are castable to themselves. The set of other types which are castable
to a given type are given by the following table:

\begin{tabular}{l | l}
Result & Castable from \\
\hline
Any numeric type & Floating types \\
Any numeric type or enum type & Integer and enum types \\
Any pointer type or \terminal{null} & \terminal{uintptr} \\
Any pointer type, \terminal{uintptr}, or \terminal{null} & Any pointer type \\
Any array or slice type & Array types \\
Any slice type or pointer to an array type & Slice types \\
Any type the underlying type of the source could cast to & Type aliases \\
Any type alias with an underlying type the source may be cast to & Any type \\
Any integer type & \terminal{rune} \\
\terminal{rune} & Any integer type \\
Any pointer type or \terminal{uintptr} & \terminal{null} \\
See below & Tagged unions \\
Tagged unions & See below \\
See below & Flexible constant types \\
\end{tabular}

\specsubsubitem
Tagged union types are mutually castable with any type which is found among its
members, including otherwise non-castable types and other tagged union types.

\specsubsubitem
When a flexible constant type is cast to another type, the
\secref{Flexible constant promotion algorithm} shall be applied to them, and
the flexible constant shall be castable to the other type if the promotion
succeeds.

\specsubsubitem
When an integer type is cast to an integer of less precision, it shall be
truncated towards the least significant bit.

\specsubsubitem
When a signed type is cast to a unsigned type, the sign bit shall be copied to
the most significant bit of the unsigned type, and vice versa.

\specsubsubitem
When a floating type is cast to an integer, the resulting value shall be equal
to the nearest integer with smaller or equal absolute value. If the destination
type has insufficient precision to represent the resulting integer, it shall be
truncated towards the least significant bit.

\specsubsubitem
When casting an integer to a floating point type, if the destination type
lacks the precision to represent the value, it shall be truncated towards zero.

\specsubsubitem
Casting a pointer type to \nonterminal{uintptr}, and then back to the pointer
type, shall yield the same pointer. Likewise, casting \nonterminal{null} to a
\nonterminal{uintptr} and then back to a nullable pointer type shall yield
\nonterminal{null}.

\informative{However, casting \nonterminal{uintptr} to any other integer type
and back again may truncate towards the least significant bit and is not
guaranteed to yield the same pointer.}

\specsubsubitem
The \terminal{const} flag shall not affect the rules for casting one type to
another. The same holds for the error flag as well.

\specsubsubitem
The third form is a \textit{type assertion}. In this form,
\nonterminal{cast-expression} shall be of a tagged union type or a nullable
pointer type.

In the former case, \nonterminal{assertion-target} shall be \nonterminal{type}
and shall be one of constituent types of type of that tagged union. The
\nonterminal{cast-expression} shall be computed, and if the tag does not match
\nonterminal{type}, a diagnostic message shall be printed and the execution
environment shall abort. Otherwise, the result type is \nonterminal{type}.

In the latter case \nonterminal{assertion-target} shall either be a
\nonterminal{type} that is a nullable pointer type or \terminal{null}. If it is
\terminal{null} and the value of \nonterminal{cast-expression} does not equal
null, a diagnostic message shall be printed and execution environment shall
abort. If \nonterminal{assertion-target} is not \terminal{null} and the value
of \nonterminal{cast-expression} equals null, a diagnostic message shall be
printed and the execution environment shall abort. The result type of a type
assertion with \terminal{null} as \nonterminal{assertion-target} shall be null.
The result type of other type assertions shall be \nonterminal{type}.

\specsubsubitem The fourth form is a \textit{type test}. In this form, The
result type is \terminal{bool}, and shall be \terminal{true} if and only if the
type assertion from \nonterminal{cast-expression} to
\nonterminal{assertion-target} would succeed, or \terminal{false} otherwise.

\specsubsection{Multiplicative arithmetic}

\begin{grammar}
\nonterminaldef{multiplicative-expression} \\
	\nonterminal{cast-expression} \\
	\nonterminal{multiplicative-expression} \terminal{*} \nonterminal{cast-expression} \\
	\nonterminal{multiplicative-expression} \terminal{/} \nonterminal{cast-expression} \\
	\nonterminal{multiplicative-expression} \terminal{\%} \nonterminal{cast-expression} \\
\end{grammar}

\specsubsubitem
A \nonterminal{multiplicative-expression} multiplies (\terminal{*}), divides
(\terminal{/}), or obtains the remainder between (\terminal{\%}) two
expressions. The first form illustrates the precedence. The operands and result
type shall be subject to the \secref{Type promotion} rules.

\specsubsubitem
In the case of division or modulus, the first term is the dividend, and the
second term is the divisor. The result of the modulus shall have the same sign
as the dividend.

\specsubsubitem
A modulus (\terminal{\%}) operation shall be performed with operands of integer
types only.

\specsubsubitem
If an operation would cause the result to overflow the result type, it is
truncated towards the least significant bits in the case of integer types, and
towards zero in the case of float types. Integer divisions which would produce
a fractional part are rounded towards zero.

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Additive arithmetic}

\begin{grammar}
\nonterminaldef{additive-expression} \\
	\nonterminal{multiplicative-expression} \\
	\nonterminal{additive-expression} \terminal{+} \nonterminal{multiplicative-expression} \\
	\nonterminal{additive-expression} \terminal{-} \nonterminal{multiplicative-expression} \\
\end{grammar}

\specsubsubitem
An \nonterminal{additive-expression} adds (\terminal{+}) two operands, or
subtracts (\terminal{-}) one from another. The first form illustrates the
precedence. The operands and result type shall be subject to the \secref{Type
promotion} rules.

\specsubsubitem
In the case of subtraction, the first term is the minuend, and the second term
is the subtrahend.

\specsubsubitem
If an operation would cause the result to overflow or underflow the result
type, it is truncated towards the least significant bits in the case of integer
types, and towards zero in the case of float types. In the case of signed
types, this truncation will cause the sign bit to change.

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Bit shifting arithmetic}

\begin{grammar}
\nonterminaldef{shift-expression} \\
	\nonterminal{additive-expression} \\
	\nonterminal{shift-expression} \terminal{\textless{}\textless{}} \nonterminal{additive-expression} \\
	\nonterminal{shift-expression} \terminal{\textgreater{}\textgreater{}} \nonterminal{additive-expression} \\
\end{grammar}

\specsubsubitem
A \nonterminal{shift-expression} performs a bitwise left-shift
(\terminal{\textless{}\textless{}}) or right-shift (\terminal{\textgreater{}\textgreater{}}). The first
form illustrates the precedence. The result type shall be the type of the first
operand. Both operands shall be of unsigned integer types.

\specsubsubitem
\code{\nonterminal{shift-expression} \terminal{\textless{}\textless{}} $N$} shall shift
each bit towards the most significant bit $N$ places, and set the least
significant $N$ bits to zero. The $N$ most significant bits shall be silently
discarded. If $N$ is greater than the size in bits of the type, the result shall
be zero.

\specsubsubitem
\code{\nonterminal{shift-expression} \terminal{\textgreater{}\textgreater{}}
$N$} shall shift each bit towards the least significant bit $N$ places. The most
significant bits shall be set to either zero or one depending on the signedness
of \nonterminal{shift-expression}: If it is signed, then the $N$ most
significant bits shall be set to the value of the sign bit. If it unsigned, then
the $N$ most significant bits shall be set to zero. The $N$ least significant
bits shall be silently discarded. If $N$ is greater than the size in bits of the
type, the result shall be zero.

\informative{This operation is equivalent to dividing
\nonterminal{shift-expression} by $2^N$}

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Bitwise arithmetic}

\begin{grammar}
\nonterminaldef{and-expression} \\
	\nonterminal{shift-expression} \\
	\nonterminal{and-expression} \terminal{\&} \nonterminal{shift-expression} \\

\nonterminaldef{exclusive-or-expression} \\
	\nonterminal{and-expression} \\
	\nonterminal{exclusive-or-expression} \terminal{\^} \nonterminal{and-expression} \\

\nonterminaldef{inclusive-or-expression} \\
	\nonterminal{exclusive-or-expression} \\
	\nonterminal{inclusive-or-expression} \terminal{|} \nonterminal{exclusive-or-expression} \\
\end{grammar}

\specsubsubitem
An \nonterminal{and-expression} performs a bitwise and operation.

\specsubsubitem
An \nonterminal{exclusive-or-expression} performs a bitwise exclusive or
operation.

\specsubsubitem
An \nonterminal{inclusive-or-expression} performs a bitwise inclusive or
operation.

\specsubsubitem
The operands and result type shall be subject to the \secref{Type promotion}
rules.

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Logical comparisons}

\begin{grammar}
\nonterminaldef{comparison-expression} \\
	\nonterminal{inclusive-or-expression} \\
	\nonterminal{comparison-expression} \terminal{<} \nonterminal{inclusive-or-expression} \\
	\nonterminal{comparison-expression} \terminal{>} \nonterminal{inclusive-or-expression} \\
	\nonterminal{comparison-expression} \terminal{<=} \nonterminal{inclusive-or-expression} \\
	\nonterminal{comparison-expression} \terminal{>=} \nonterminal{inclusive-or-expression} \\

\nonterminaldef{equality-expression} \\
	\nonterminal{comparison-expression} \\
	\nonterminal{equality-expression} \terminal{==} \nonterminal{comparison-expression} \\
	\nonterminal{equality-expression} \terminal{!=} \nonterminal{comparison-expression} \\
\end{grammar}

\specsubsubitem
A \nonterminal{comparison-expression} determines which operand is lesser than
(\terminal{<}), greater than (\terminal{>}), less than or equal to
(\terminal{<=}), or greater than or equal to (\terminal{>=}) the other. The
operands shall be numeric, and are subject to the \secref{Type promotion}
rules.  The result type shall be \terminal{bool}.

\specsubsubitem
The result of the \terminal{<} operator shall be \terminal{true} if the first
operand is mathematically less than the second operand and \terminal{false}
otherwise.

\specsubsubitem
The result of the \terminal{>} operator shall be \terminal{true} if the first
operand is mathematically greater than the second operand and \terminal{false}
otherwise.

\specsubsubitem
The result of the \terminal{<=} operator shall be \terminal{true} if the
first operand is mathematically less than or equal to second operand
and \terminal{false} otherwise.

\specsubsubitem
The result of the \terminal{>=} operator shall be \terminal{true} if the first
operand is mathematically greater than or equal to second operand
and \terminal{false} otherwise.

\specsubsubitem
An \nonterminal{equality-expression} determines if two operands are equal to one
another. The result type is \terminal{bool}. If the types of the \terminal{==}
or \terminal{!=} operators are numeric, they shall be subject to
\secref{Type promotion}. Otherwise, each operand must be of the same type, and
that type must both be either \terminal{str}, \terminal{bool}, \terminal{rune},
or a pointer type.

\specsubsubitem
The result of the \terminal{==} operator shall be \terminal{true} if the first
operand is equal to second operand in value, and \terminal{false} otherwise.

\specsubsubitem
The result of the \terminal{!=} operator shall be \terminal{true} if the first
operand is not equal to second operand in value, and \terminal{false} otherwise.

\specsubsubitem
Two \terminal{str} types shall be equal if both strings have the same length and
octets. Otherwise, they shall not be equal.

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Logical arithmetic}

\begin{grammar}
\nonterminaldef{logical-and-expression} \\
	\nonterminal{equality-expression} \\
	\nonterminal{logical-and-expression} \terminal{\&\&} \nonterminal{equality-expression} \\

\nonterminaldef{logical-xor-expression} \\
	\nonterminal{logical-and-expression} \\
	\nonterminal{logical-xor-expression} \terminal{\textasciicircum\textasciicircum} \nonterminal{logical-and-expression} \\

\nonterminaldef{logical-or-expression} \\
	\nonterminal{logical-xor-expression} \\
	\nonterminal{logical-or-expression} \terminal{||} \nonterminal{logical-xor-expression} \\
\end{grammar}

\specsubsubitem
For all cases of logical arithmetic, both terms shall be of the \terminal{bool}
type, and the result type shall be \terminal{bool}.

\specsubsubitem
\terminal{\&\&} shall compute a logical and operation, and shall be
\terminal{true} if both terms are \terminal{true}, and \terminal{false}
otherwise.

\specsubsubitem
\terminal{\textasciicircum\textasciicircum} shall be a logical exclusive or
operation, and shall be \terminal{true} if the terms are not equal to each
other, and \terminal{false} otherwise.

\specsubsubitem
\terminal{||} shall be a logical or operation, and shall be \terminal{true} if
either term is \terminal{true}, and \terminal{false} otherwise.

\specsubsubitem
If the first term of \nonterminal{logical-and-expression} is \terminal{false},
or the first term of \nonterminal{logical-or-expression} is \terminal{true},
the implementation shall ensure that the side-effects of the second term do not
occur.

\specsubsection{If expressions}

\begin{grammar}
\nonterminaldef{if-expression} \\
	\terminal{if} \nonterminal{conditional-branch} \\
	\terminal{if} \nonterminal{conditional-branch} \terminal{else} \nonterminal{expression} \\

\nonterminaldef{conditional-branch} \\
	\terminal{(} \nonterminal{expression} \terminal{)} \nonterminal{expression} \\
\end{grammar}

\specsubsubitem
An \nonterminal{if-expression} chooses which, if any, expression to evaluate
based on a logical criteria. In \nonterminal{conditional-branch}, the result type of
the first \nonterminal{expression} shall be \terminal{bool}.

\specsubsubitem
When executing a \nonterminal{conditional-branch}, the implementation shall
evaluate the first \nonterminal{expression} (the \textit{condition}), and if
\terminal{true}, the implementation shall execute the corresponding second
\nonterminal{expression} (the \textit{true branch}), ensuring that all
side-effects occur. If the condition is \terminal{false}, the true branch shall
not be executed and shall not cause side-effects.

\specsubsubitem
In the second form, the \nonterminal{conditional-branch} shall be executed. If
the condition is \terminal{false}, the \nonterminal{expression} (the
\textit{false branch}) shall be executed, ensuring that all side-effects occur.
If the condition is \terminal{true}, the false branch shall not be executed and
shall not cause side-effects. The result value shall be selected from the result
of the branch which is executed. If the \nonterminal{if-expression} is provided
a type hint, the executed branch shall receive it as a type hint.

\specsubsubitem
The first form shall behave exactly as though the second form were used with
\terminal{void} as the false branch.

\specsubsubitem
If a type hint is provided and all branches are assignable to that type, the
result type shall be the type given by the type hint. Otherwise, the result type
shall be the \secref{Result type reduction algorithm} applied to the result
types of all branches.

\specsubsection{For loops}

\begin{grammar}
\nonterminaldef{for-loop} \\
	\terminal{for} \terminal{(} \nonterminal{for-predicate} \terminal{)} \nonterminal{expression} \\

\nonterminaldef{for-predicate} \\
	\nonterminal{expression} \\
	\nonterminal{binding-list} \terminal{;} \nonterminal{expression} \\
	\nonterminal{expression} \terminal{;} \nonterminal{expression} \\
	\nonterminal{binding-list} \terminal{;} \nonterminal{expression} \terminal{;} \nonterminal{expression} \\
\end{grammar}
% XXX: We may want to narrow the afterthought's expression class

\specsubsubitem
A \nonterminal{for-loop} executes its \nonterminal{expression}, the
\textit{body} of the loop, zero or more times, so long as a condition is true.
Its result type is \terminal{void}.

\specsubsubitem
In the first form, \nonterminal{for-predicate} specifies the \textit{condition}
with its \nonterminal{expression}. In the second form, the
\nonterminal{binding-list} is the \textit{binding} and the expression is the
condition. In the third form, the first expression is the condition, and the
second expression is the \textit{afterthought}. In the fourth form, the
\nonterminal{binding-list} is the binding, and the two expressions are
respectively the condition and afterthought. The result type of the condition
shall be \terminal{bool}, and this shall be provided as a type hint.

\specsubsubitem
The implementation shall establish a new scope for the
\nonterminal{expression}, then, if present, it shall evaluate the
\nonterminal{binding} in this scope. The implementation shall then evaluate the
condition. If it is \terminal{true}, the \nonterminal{expression} shall be
evaluated and all of its side-effects shall occur; this process is an
\textit{iteration}. When the iteration is complete, the implementation shall
evaluate the afterthought, if present, and then repeat the process, until the
condition evaluates to \terminal{false}.

\specsubsection{Switch expressions}

\begin{grammar}
\nonterminaldef{switch-expression} \\
	\terminal{switch} \terminal{(} \nonterminal{expression} \terminal{)} \terminal{\{} \nonterminal{switch-cases} \terminal{\}} \\

\nonterminaldef{switch-cases} \\
	\nonterminal{switch-case} \optional{\nonterminal{switch-cases}} \\

\nonterminaldef{switch-case} \\
	\terminal{case} \nonterminal{case-options} \terminal{=>} \nonterminal{expression-list} \\
	\terminal{case} \terminal{=>} \nonterminal{expression-list} \\

\nonterminaldef{case-options} \\
	\nonterminal{expression} \optional{\terminal{,}} \\
	\nonterminal{expression} \terminal{,} \nonterminal{case-options} \\
\end{grammar}

Forward references: \subsecref{Compound expressions}

\specsubsubitem
A switch expression evaluates a value (\nonterminal{expression}, the
\textit{switching expression}), then compares it with a number of
\nonterminal{switch-cases}, taking whichever branch compares equal to the value.
The switching expression's result type must either be of an integer type or be a
\terminal{str}, \terminal{bool}, \terminal{rconst}, \terminal{rune}, or a
pointer type.

\specsubsubitem
Each of the \nonterminal{case-options} specifies a value to compare with, given
by \nonterminal{expression}. This expression shall be limited to the
\secref{Translation compatible expression subset}, and its result type shall be
equivalent to the result type of the switching expression.

\specsubsubitem
Each \nonterminal{switch-case} introduces an implicit
\nonterminal{compound-expression} which the provided
\nonterminal{expression-list} gives the expressions of. The implementation
shall evaluate the \nonterminal{expression-list} of the corresponding
\nonterminal{switch-case} if any of the \nonterminal{case-options} is equal to
the switching expression's result, setting the result of the overall switch
expression to the result of the selected \nonterminal{switch-case}.

\informative{As such, the appropriate way to set the result of a switch
expression is with a \nonterminal{yield-expression}. The semantics of
\nonterminal{defer-expression}, \nonterminal{bindings}, and so on, are also
implicated.}

\specsubsubitem
The form of \nonterminal{switch-case} without \nonterminal{case-options}
indicates any case which is not selected by the other cases. Only one case of
this form shall appear in the switch expression.

\specsubsubitem
The switch cases shall be \textit{exhaustive}, meaning that every possible
value of the switching expression is accounted for by a
\nonterminal{switch-case}. It shall also be precisely exhaustive: no two cases
shall select for the same value.

\specsubsubitem
If the value of the switching expression doesn't compare equal to any of the
\nonterminal{switch-cases}, a diagnostic message shall be printed and the
execution environment shall abort.

\informative{This isn't possible under normal circumstances, but certain
operations such as invalid casts can cause this to occur.}

\specsubsubitem
The implementation shall ensure that side-effects of the switch value
expression occur before those of the selected case, and that side-effects of
non-selected cases do not occur.

\specsubsubitem
If a type hint is provided, each branch shall receive it as a type hint.

\specsubsubitem
If a type hint is provided and all branches are assignable to that type, the
result type shall be the type given by the type hint. Otherwise, the result type
shall be the \secref{Result type reduction algorithm} applied to the result
types of all branches.

\specsubsection{Match expressions}

\begin{grammar}
\nonterminaldef{match-expression} \\
	\terminal{match} \terminal{(} \nonterminal{expression} \terminal{)} \terminal{\{} \nonterminal{match-cases} \terminal{\}} \\

\nonterminaldef{match-cases} \\
	\nonterminal{match-case} \optional{\nonterminal{match-cases}} \\

\nonterminaldef{match-case} \\
	\terminal{case} \terminal{let} \nonterminal{name} \terminal{:} \nonterminal{type} \terminal{=>} \nonterminal{expression-list} \\
	\terminal{case} \terminal{let} \terminal{(} \nonterminal{binding-names} \terminal{)} \terminal{:} \nonterminal{type} \terminal{=>} \nonterminal{expression-list} \\
	\terminal{case} \nonterminal{type} \terminal{=>} \nonterminal{expression-list} \\
	\terminal{case} \terminal{=>} \nonterminal{expression-list} \\
\end{grammar}

Forward references: \subsecref{Compound expressions}, \subsecref{Variable
binding}

\specsubsubitem
A match expression evaluates a value (\nonterminal{expression}, the
\textit{matching expression}), then selects and evaluates another expression
based on its result type. The result type of the matching expression must be a
tagged union or nullable pointer type, or an alias of either.

\specsubsubitem
If the matching expression has a tagged union type, each
\nonterminal{match-case} shall specify a type which is either a member of that
tagged union, or another tagged union which supports a subset of the matching
expression's type, or a type alias which refers to a qualifying type.

\specsubsubitem
If the matching expression has a nullable pointer type, one match case shall be
\terminal{null}, and another shall be the equivalent non-nullable pointer type,
or a type alias which refers to a qualifying type.

\specsubsubitem
Each \nonterminal{match-case} introduces an implicit
\nonterminal{compound-expression} which the provided
\nonterminal{expression-list} gives the expressions of. The implementation
shall evaluate the \nonterminal{expression-list} of the corresponding
\nonterminal{match-case} if the value of the matching expression is of the type
specified by this match case, or can be assigned from it, setting the result of
the overall match expression to the result of the selected
\nonterminal{match-case}.

% TODO: Write up new matching algorithm

\informative{As such, the appropriate way to set the result of a match
expression is with a \nonterminal{yield-expression}. The semantics of
\nonterminal{defer-expression}, \nonterminal{bindings}, and so on, are also
implicated.}

\specsubsubitem
The form of \nonterminal{match-case} without a \nonterminal{type} indicates any
case which is not selected by the other cases. Only one case of this form shall
appear in the match expression.

\specsubsubitem
The first form of \nonterminal{match-case}, if selected, shall cause the
implementation to cast the match expression to the selected type and assign the
resulting value to \nonterminal{name}. It shall insert this binding into the
scope of the implicit \nonterminal{compound-expression} of the selected case.

\specsubsubitem
The second form of \nonterminal{match-case} is the \textit{tuple unpacking}
form, and in this case, the \nonterminal{type} shall be of a tuple type
with a number of values equal to the number of items given in
\nonterminal{binding-names}. The implementation shall cast the match expression
to the selected type and create separate bindings for each name in
\nonterminal{binding-names}, of the type of the corresponding tuple value, and
initialize them to that value from the tuple. It shall insert this binding into
the scope of the implicit \nonterminal{compound-expression} of the selected
case. If any \nonterminal{binding-name} is \terminal{\_} (an underscore),
a binding for that name shall not be created, but bindings
to any \nonterminal{name}s within the tuple shall be created.

\specsubsubitem
The match cases shall be \textit{exhaustive}, meaning that every possible type
of the matching expression is accounted for by a \nonterminal{match-case}. It
shall also be precisely exhaustive: no two cases shall select for the same
type.

\specsubsubitem
If the type of the matching expression isn't accounted for by any of the
\nonterminal{match-cases}, a diagnostic message shall be printed and the
execution environment shall abort.

\informative{This isn't possible under normal circumstances, but certain
operations such as invalid casts can cause this to occur.}

\specsubsubitem
The implementation shall ensure that side-effects of the match value
expression occur before those of the selected case, and that side-effects of
non-selected cases do not occur.

\specsubsubitem
If a type hint is provided, each branch shall receive it as a type hint.

\specsubsubitem
If a type hint is provided and all branches are assignable to that type, the
result type shall be the type given by the type hint. Otherwise, the result type
shall be the \secref{Result type reduction algorithm} applied to the result
types of all branches.

\specsubsection{Assignment}

\begin{grammar}
\nonterminaldef{assignment} \\
	\nonterminal{object-selector} \nonterminal{assignment-op} \nonterminal{expression} \\
	\terminal{*} \nonterminal{unary-expression} \nonterminal{assignment-op} \nonterminal{expression} \\
	\nonterminal{slicing-expression} \terminal{=} \nonterminal{expression} \\
	\terminal{(} \nonterminal{binding-names} \terminal{)} \terminal{=} \nonterminal{expression} \\

\nonterminaldef{assignment-op} \oneof \\
	\terminal{=}
	\terminal{+=}
	\terminal{-=}
	\terminal{*=}
	\terminal{/=}
	\terminal{\%=}
	\terminal{\textless{}\textless{}=}
	\terminal{\textgreater{}\textgreater{}=}
	\terminal{\&=}
	\terminal{|=}
	\terminal{\textasciicircum=}
	\terminal{\&\&=}
	\terminal{||=}
	\terminal{\textasciicircum\textasciicircum=}
\end{grammar}

Forward references: \subsecref{Variable binding}

\specsubsubitem
An \nonterminal{assignment} expression shall cause the object given by the
first term to be assigned a new value based on the value given by the second
term. The type of the object shall be provided as a type hint to the secondary
expression. The result type of an assignment shall be \terminal{void}.

\specsubsubitem
If the \nonterminal{assignment-op} is \terminal{=}, the first term shall be
assigned the value given by the second term. Otherwise, the assignment
\code{\nonterminal{e1} \nonterminal{op}\terminal{=} \nonterminal{e1}} shall be
equivalent to the assignment
\code{\nonterminal{e1} \terminal{=} \nonterminal{e1} \nonterminal{op} (\nonterminal{e2})},
but the side-effects of \nonterminal{e1} shall only occur once.

\specsubsubitem
In the first form, the \nonterminal{object-selector} selects the object to be
modified. The type of this object shall not be a \terminal{const} type.

\specsubsubitem
In the second form, the \nonterminal{unary-expression} shall have a result
of a non-nullable, non-const pointer type, and the object which is assigned
shall be the secondary object to which the pointer object refers. The second
term shall be assignable to the pointer's secondary type.

\specsubsubitem
In the third form, the \nonterminal{expression} shall be either of a slice
type and have a length equal to the slice given by \nonterminal{slicing-expression},
or an expandable array. The first term shall not be of a \terminal{const} type,
and the lengths of the two slices shall be equal. The contents of the slice or
expandable array given by the second term shall be copied into the slice given
by the first term.

\specsubsubitem
In the fourth form, the \nonterminal{expression} shall be of a tuple type, and
shall have length equal to the number of \nonterminal{binding-name}s specified.
The implementation shall assign each value of the \nonterminal{expression}
to the object given by the respective left-hand term. All left-hand terms shall
be of a non-\terminal{const} type. If any \nonterminal{binding-name}
is \terminal{\_} (an underscore), a binding for that name shall not be created,
but bindings to any \nonterminal{name}s within the tuple shall be created
and any side-effects of the initializer shall still occur.

\specsubsubitem
The type of the object being assigned to shall have definite size and alignment.

\specsubsubitem
The second term shall be \textit{assignable} to the object. Assignability rules
are different than castability rules. All types are assignable to themselves.
The set of other types which are assignable to a given type are given by the
following table:

\begin{tabular}{r | l}
Object type & May be assigned from \\
\hline
Mutable type & Constant types assignable to the object type \\
Signed integer types & Signed integer types of equal or lower precision \\
Unsigned integer types & Unsigned integer types of equal or lower precision \\
Floating point types & Any floating point type of equal or lower precision \\
Nullable pointer types & Non-nullable pointer type of the same secondary type \\
Nullable pointer types & \terminal{null} \\
Slice types & Array type of the same secondary type and definite length \\
Slice types & Pointer to array type of the same secondary type and definite length \\
\terminal{[}\terminal{]}\terminal{opaque} & Slice types \\
Array types of undefined size & Array types of defined size \\
Tagged union types & See notes \\
Type aliases & Any type assignable to the secondary type \\
\terminal{void} & Any type \\
\terminal{*} \terminal{opaque} & Any non-nullable pointer type \\
\terminal{nullable} \terminal{*} \terminal{opaque} & Any pointer type \\
Pointers to array types & See notes \\
Any type & \terminal{never} \\
\end{tabular}

The implementation shall perform any necessary conversion from the source type
to the destination type.

\specsubsubitem
Pointers to array types are mutually assignable if their secondary types are
mutually assignable.

\specsubsubitem
A pointer to a type is assignable to a pointer to a secondary type if
the primary type is a struct type which contains the secondary type at
offset zero, or if the type at offset zero is a type which would be assignable
under these rules.

\specsubsubitem
Tagged union types may be assigned from any of their constituent types. Tagged
unions may also be assigned from any type which is assignable to exactly one of
its constituent types. Additionally, tagged unions may be assigned from any
other tagged union type, provided that the set of constituent types of the
destination type is a superset of the set of constituent types of the source
type.

\specsubsubitem
\terminal{const} types have the same assignability rules as the equivalent
non-const type. Types with the error flag set have the same assignability rules
as the equivalent type with the flag unset.

\specsubsubitem
If at least one of the types is a flexible constant, the
\secref{Flexible constant promotion algorithm} shall be applied to them, and
they shall be considered mutually assignable if the promotion succeeds.

\informative{In the context of an assignment expression,
\subsubitemref{Assignment}{2} prevents the modification of objects with a const
type. However, the \textit{assignability} rules are referred to in many other
contexts throughout the specification, and in these contexts, unless otherwise
specified, non-const types are assignable to const types. For example, a
\nonterminal{binding} which specifies a const \nonterminal{type} may use a
non-const type for its \nonterminal{expression}.}

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Variable binding}

\begin{grammar}
\nonterminaldef{binding-list} \\
	\optional{\terminal{static}} \terminal{let} \nonterminal{bindings} \\
	\optional{\terminal{static}} \terminal{const} \nonterminal{bindings} \\

\nonterminaldef{bindings} \\
	\nonterminal{binding} \optional{\terminal{,}} \\
	\nonterminal{binding} \terminal{,} \nonterminal{bindings} \\

\nonterminaldef{binding} \\
	\nonterminal{name} \terminal{=} \nonterminal{expression} \\
	\nonterminal{name} \terminal{:} \nonterminal{type} \terminal{=} \nonterminal{expression} \\
	\terminal{(} \nonterminal{binding-names} \terminal{)}  \terminal{=} \nonterminal{expression} \\
	\terminal{(} \nonterminal{binding-names} \terminal{)} \terminal{:} \nonterminal{type} \terminal{=} \nonterminal{expression} \\

\nonterminaldef{binding-names} \\
	\nonterminal{binding-name} \terminal{,} \nonterminal{binding-name} \\
	\nonterminal{binding-name} \terminal{,} \nonterminal{binding-names} \\

\nonterminaldef{binding-name} \\
	\nonterminal{name} \\
	\terminal{\_} \\
\end{grammar}

\specsubsubitem
A \nonterminal{binding-list} shall cause one or more objects to become
available in the present scope. Each object shall be identified by its
\nonterminal{name}, and shall have its initial value set to the result of the
\nonterminal{expression}. The result
type of a binding list expression is \terminal{void}.

\specsubsubitem
In the first form of \nonterminal{binding}, the type of the object shall
be equivalent to the result type of the \nonterminal{expression}. In the
second form, the type shall be as indicated, and the result type of the
\nonterminal{expression} shall be assignable to this type. In this second form,
the type specified is used as a type hint for the \nonterminal{expression}.

\specsubsubitem
The third and fourth forms of \nonterminal{binding} are the \textit{tuple
unpacking} form, and in this case, the \nonterminal{type} and
\nonterminal{expression} shall be of a tuple type with a number of values equal
to the number of times \nonterminal{binding-name} is given. The implementation shall
create separate bindings for each name, of the type of the corresponding tuple
value, and initialize them to that value from the tuple. If any
\nonterminal{binding-name} is \terminal{\_} (an underscore), a binding for that
name shall not be created, but bindings to any \nonterminal{name}s within the tuple
shall be created and any side-effects of the initializer shall still occur.

\specsubsubitem
If the \terminal{const} form is used, the type of each binding shall be
modified to \textit{include} the \terminal{const} flag. If the \terminal{let}
form is used, the type of each binding which uses the first form of
\nonterminal{binding} shall be modified to \textit{omit} the \terminal{const}
flag.

\specsubsubitem
If the \terminal{static} form is used, the variables shall be allocated
\textit{statically}, such that they are only initialized once and their
previous value, accounting for any later mutations, is preserved each time
the binding expression is encountered, including across repeated or recursive
calls to the enclosing function. In this case, the initializer must use the
\secref{Translation compatible expression subset}.

\specsubsubitem
If a \nonterminal{binding} gives a \nonterminal{name} which is already defined
in the current scope, the new binding shall \textit{shadow} the earlier
binding, causing any later references to this name to resolve to the newer
binding.

\specsubsubitem
The type of the binding shall not use a type which has a zero or undefined size.
If the type of a binding is a flexible constant type, it shall first be lowered
to its default type.

\specsubsection{Defer expressions}

\begin{grammar}
\nonterminaldef{defer-expression} \\
	\terminal{defer} \nonterminal{expression} \\
\end{grammar}

\specsubsubitem
A \nonterminal{defer-expression} causes another expression to be
\textit{deferred} until the current scope \textit{terminates}. The result type
is \terminal{void}.

\specsubsubitem
The implementation shall cause the \nonterminal{expression} to be evaluated
upon the termination of the current scope, either due to normal program flow,
or due to encountering a terminating expression.

\specsubsubitem
If several expressions are deferred in a single scope, their side-effects shall
occur in the reverse of the order that they appear in the program source.

\specsubsubitem
If a scope is terminated before a \nonterminal{defer-expression} within the
scope (\informative{but not an expression which was already deferred}) would be
evaluated, the side-effects of the \nonterminal{expression} shall not occur.

\specsubsubitem
Before a scope terminates, all active nested scopes shall also be terminated, in
order, from inner-most to outer-most.

\specsubsubitem
Before a \nonterminal{control-expression} is evaluated (but after its provided
\nonterminal{expression} is evaluated, if present), the scope associated with
its selected expression is terminated.

Forward references: \subsecref{Control expressions}

\specsubsubitem
Before a function with a result type of \terminal{never} is called by a
\nonterminal{call-expression} (but after all arguments have been evaluated), as
well as before the execution environment aborts for any reason, the inner-most
function scope is terminated.

\specsubsubitem
As a special case, if a deferred expression is currently being executed, then if
a scope outside of the inner-most deferred expression would terminate, the
outer-most scope within the inner-most deferred expression shall terminate
instead.

\informative{This is intended to prevent exponential code generation when
deferred expressions may abort.}

\specsubsection{Compound expressions}

\begin{grammar}
\nonterminaldef{expression-list} \\
	\nonterminal{expression} \terminal{;} \optional{\nonterminal{expression-list}} \\
	\nonterminal{binding-list} \terminal{;} \optional{\nonterminal{expression-list}} \\
	\nonterminal{defer-expression} \terminal{;} \optional{\nonterminal{expression-list}} \\

\nonterminaldef{compound-expression} \\
	\optional{\nonterminal{label}} \terminal{\{} \nonterminal{expression-list} \terminal{\}} \\

\nonterminaldef{label} \\
	\terminal{:} \nonterminal{name} \\
\end{grammar}

\specsubsubitem
A \nonterminal{compound-expression} evaluates a list of
\nonterminal{expression}s in sequence. If a \nonterminal{label} is present, the
expression is considered \textit{labelled}.

\specsubsubitem
If a type hint is provided to a \nonterminal{compound-expression}, the hint shall
be provided to the expression of any \nonterminal{yield-expression} which
selects that \nonterminal{compound-expression}.

\specsubsubitem
The expressions shall be evaluated such that the side-effects of each all occur
in the order that each expression appears.

\specsubsubitem
Only the final item in the \nonterminal{expression-list} is permitted to have
the result type \terminal{never}.

\specsubsubitem
If the final item in the \nonterminal{expression-list} doesn't have the result
type \terminal{never}, the \nonterminal{compound-expression} shall behave
exactly as though \code{yield void;} were appended to the end of the
\nonterminal{expression-list}.

\informative{The implicitly added \nonterminal{yield-expression} guarantees that
all \nonterminal{compound-expression}s will end with an expression whose result
type is \terminal{never}.}

\specsubsubitem
The result type of a \nonterminal{compound-expression} shall be the
\secref{Result type reduction algorithm} applied to the result types of the
expressions used in all all \nonterminal{yield-expression}s which select this
\nonterminal{compound-expression}.

\informative{If no \nonterminal{yield-expression} selects this
\nonterminal{compound-expression} (and a \nonterminal{yield-expression} wasn't
implicitly appended to the \nonterminal{expression-list}), the result type is
\terminal{never}.}

\specsubsubitem
The \nonterminal{compound-expression} shall establish a new scope whose parent is
the scope in which the \nonterminal{compound-expression} resides.

\specsubsection{Control expressions}

\begin{grammar}
\nonterminaldef{control-expression} \\
	\terminal{break} \optional{\nonterminal{label}} \\
	\terminal{continue} \optional{\nonterminal{label}} \\
	\terminal{return} \optional{\nonterminal{expression}} \\
	\nonterminal{yield-expression} \\

\nonterminaldef{yield-expression} \\
	\terminal{yield} \\
	\terminal{yield} \nonterminal{expression} \\
	\terminal{yield} \nonterminal{label} \\
	\terminal{yield} \nonterminal{label} \terminal{,} \nonterminal{expression} \\
\end{grammar}

\specsubsubitem
A \nonterminal{control-expression} causes control to jump to another part of the
program, possibly affecting the value and/or result of the \textit{selected}
expression. The result type is \terminal{never}.

\specsubsubitem
The rules for selection of an applicable \nonterminal{expression} vary based on
the kind of control expression used. If a label is used, it shall select the
corresponding labelled \nonterminal{compound-expression} from the ancestors of
the \nonterminal{control-expression}, and the selected expression shall meet the
requirements for the appropriate control expression type. Otherwise, the first
qualifying \nonterminal{compound-expression}, body of a \nonterminal{for-loop},
or body of a \nonterminal{function-declaration} is used, ordered such that the
nearest ancestor is considered first. If no suitable \nonterminal{expression} is
selected, a diagnostic message will be displayed and the translation phase shall
terminate.

\specsubsubitem
In the \terminal{break} and \terminal{continue} forms, the selected expression
shall be the body of a \nonterminal{for-loop}. The \terminal{break} form shall
cause the loop to end without evaluating the \textit{condition} or the
\textit{afterthought}. The \terminal{continue} form shall cause the loop to
repeat immediately, running the \textit{afterthought} if present, re-testing the
\textit{condition}, and repeating the loop if \terminal{true}.

\specsubsubitem
The \terminal{return} form shall select the body of a
\nonterminal{function-declaration}. The \nonterminal{expression} shall be used
as the result value for the function, or, if absent, \terminal{void} shall be
used. This expression shall receive the function's result type as a type hint,
and the result shall be assignable to that type.

\specsubsubitem
The \nonterminal{yield-expression} form shall select a
\nonterminal{compound-expression}. A \nonterminal{yield-expression} that isn't
provided an \nonterminal{expression} is equivalent to a
\nonterminal{yield-expression} provided the expression \terminal{void}. The
provided expression shall be used as the result value for the selected
\nonterminal{compound-expression}.

\specsubsubitem
If a \nonterminal{control-expression} is used within the expression tree formed
by a \nonterminal{defer-expression}, and the selected expression isn't a
descendent of the same tree, the translation environment shall print a
diagnostic message and abort.

\specsubsection{High-level expression class}

\begin{grammar}
\nonterminaldef{expression} \\
	\nonterminal{assignment} \\
	\nonterminal{logical-or-expression} \\
	\nonterminal{if-expression} \\
	\nonterminal{for-loop} \\
	\nonterminal{control-expression} \\
\end{grammar}

\specsection{Type promotion}

\specsubitem
The operands of some arithmetic expressions are subject to \textit{type
promotion}, to allow for arithmetic between disjoint types. The operand of
lower precision may be \textit{promoted}, or implicitly cast, to the precision
of the more precise operand. Unless explicitly covered by the following cases,
operands shall not be promoted, and the translation environment shall print a
diagnostic message and abort for incompatible combinations of operand types.

\specsubitem
For expressions where the result type is determined by type promotion, the
result type shall be equivalent to the type of the operand which has the
highest precision.

\specsubitem
For expressions involving at least one flexible constant type, the result type
shall be determined by the \secref{Flexible constant promotion algorithm}.

\specsubitem
For expressions involving two integer types, the type of lower precision may be
promoted to the type of higher precision only if the signedness is the same for
each operand.

\specsubitem
Expressions involving \terminal{uintptr} and \terminal{size} promote to
\terminal{uintptr}, expressions involving \terminal{uintptr} and \terminal{null}
promote to \terminal{uintptr}, and expressions involving \terminal{uintptr} and
a pointer type promote to that pointer type. All other expressions involving
\terminal{uintptr} shall cause the translation environment to print a diagnostic
message and abort.

\specsubitem
An integer type may be promoted to an enum type whose storage is the
same as the integer's storage.

\specsubitem
For expressions involving floating point types, \terminal{f32} may be promoted
to \terminal{f64}.

\specsubitem
For expressions involving pointer types, \terminal{null} may be promoted to any
nullable pointer type, and a non-nullable pointer type may be promoted to
a nullable pointer type with the same secondary type. Any pointer type may be
promoted to an \terminal{opaque} pointer.

\specsubitem
A mutable type may be promoted to a constant type which is otherwise equivalent
to the mutable type, or any other type which that constant type may promote to.

\specsubitem
A pointer type may be promoted to another pointer type if the secondary type of
the pointer may be promoted to the secondary type of the second pointer.

\specsubitem
An array type may promote to an array type with undefined size with an
equivalent member type.

\specsubitem
A non-aliased type A may promote to a type alias B if type A may promote to the
underlying type of type B.

\specsection{Translation compatible expression subset}

The translation compatible expression subset is a subset of expression types
which the implementation must be able to evaluate during the translation phase.

\specsubitem
The following expressions are included:

\begin{minipage}[t][7cm][b]{\textwidth}
\begin{multicols}{2}
\begin{itemize}
\item \nonterminal{logical-or-expression}
\item \nonterminal{logical-xor-expression}
\item \nonterminal{logical-and-expression}
\item \nonterminal{equality-expression}
\item \nonterminal{comparison-expression}
\item \nonterminal{inclusive-or-expression}
\item \nonterminal{exclusive-or-expression}
\item \nonterminal{and-expression}
\item \nonterminal{shift-expression}
\item \nonterminal{additive-expression}
\item \nonterminal{multiplicative-expression}
\item \nonterminal{cast-expression}
\item \nonterminal{unary-expression}
\item \nonterminal{field-access-expression}
\item \nonterminal{indexing-expression}
\item \nonterminal{measurement-expression}
\item \nonterminal{nested-expression}
\item \nonterminal{plain-expression}
\end{itemize}
\end{multicols}
\end{minipage}

\vspace{0.25cm}
\specsubitem
All terminals which are descendants of any of the listed terminals are
included, and all non-terminals and terminals which are descendants of
\nonterminal{plain-expression} are included.

\specsubitem
The pointer dereference \nonterminal{unary-expression} (the \terminal{*}
operator) shall be excluded from the translation compatible expression subset.
Additionally, the implicit pointer type dereference semantics of
\nonterminal{field-access-expression} and \nonterminal{indexing-expression} are
not available.

\specsubitem
The expression used for a \nonterminal{length-expression} is not required to be
translation compatible as long as the result type is either an array type or an
array type's alias, indirected via any number of non-nullable pointer types or
their aliases if appropriate.

\specsubitem
The implementation is not required to use a conformant implementation of the
storage semantics of types in the translation environment, provided that there
are not observable side-effects in the execution environment as a result of any
differences.

\specsubitem
In a context where an expression is constrained to this subset, the use of an
expression type outside of this set shall cause the translation environment to
print a diagnostic message and abort.

\specsection{Result type reduction algorithm}

\specsubitem
The result type reduction algorithm shall operate on a list of types. It shall
perform the following reductions in order:

\begin{enumerate}
\item Replace all tagged unions with their members
\item Remove all duplicate types
\item Remove all pointer types such that an equivalent nullable pointer type
	exists
\item Remove all mutable types such that an equivalent constant type exists
\item If \terminal{null} and exactly one pointer type remain, replace both with
	an equivalent nullable pointer type
\end{enumerate}

\specsubitem
If \terminal{null} and at least one other type remain after these reductions,
the translation phase shall print a diagnostic message and abort.

\specsubitem
If exactly one type remains, it shall be the result of the result type reduction
algorithm. If more than one type remains, the result of the result type
reduction algorithm shall be a tagged union containing the remaining types.

\specsection{Flexible constant promotion algorithm}

\specsubitem
The flexible constant promotion algorithm shall operate on two types, at least
one of which shall be a flexible constant type.

\specsubitem
If both operands are \terminal{iconst}, they shall both be lowered to
\terminal{iconst} with the minimum value set to the smaller of their
minimum values and the maximum value set to the larger of their maximum values,
and that type shall be the result.

\specsubitem
Otherwise, if both operands are \terminal{fconst} or both are \terminal{rconst},
they shall both be lowered to a new \terminal{fconst} or \terminal{rconst}
respectively, and that type shall be the result. If both operands are flexible
constant types with different storages, the promotion shall fail.

\specsubitem
If one operand is a tagged union type and promotion between exactly one of its
members and the flexible constant type succeeds, the side-effects of that
promotion shall occur and that member shall be the result of the promotion.
Otherwise, if the constant's default type is a member of the tagged union, the
constant shall be lowered to its default type and the promotion shall succeed.
Otherwise, the promotion shall fail.

\specsubitem
If one operand is \terminal{fconst} and the other is a floating type, the
\terminal{fconst} shall be lowered to the floating type, which shall be the
result of the promotion. Otherwise, the promotion shall fail.

% XXX: Should prevent eg. promoting -1337 to u8

\specsubitem
If one operand is \terminal{iconst} and the other is a signed integer type, the
promotion shall succeed if both the minimum and maximum values fields of the
\terminal{iconst} are within the limits of the other type. If one operand is
\terminal{iconst} and the other is an unsigned integer type, the promotion shall
succeed if the maximum value of the iconst is within the limits of the other
type. If the promotion succeeds, the \terminal{iconst} shall be lowered to the
other type, which shall be the result of the promotion.

\specsubitem
If one operand is \terminal{rconst} and the other is \terminal{rune}, the
\terminal{rconst} shall be lowered into a \terminal{rune}. If one operand is
\terminal{rconst} and the other is an integer type, the promotion shall succeed
if the \terminal{rconst} value can be represented as the specified integer type
without any data loss.

