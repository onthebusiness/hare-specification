\specsection{Expressions}

\specsubitem
An expression is a procedure which the implementation may perform to obtain a
\textit{result}, and possibly cause side-effects (see
\subsubitemref{Program execution}{1}).

\specsubitem
Expression types are organized into a number of classes and subclasses of
expressions which define the contexts in which each expression type is
applicable.

\specsubitem
All expressions have a defined \textit{result type}. It may be \terminal{void}.

\specsubitem
Some expressions \textit{terminate}. The semantics of terminating expressions
vary between different expression types, and will be detailed as appropriate.
If unspecified, expressions described by this expression are presumed to be
non-terminating. Expression classes inherit their termination qualities from the
more specific sub-expressions which they classify.

\specsubsection{Constants}

\begin{grammar}
\nonterminaldef{constant} \\
	\nonterminal{integer-constant} \\
	\nonterminal{floating-constant} \\
	\nonterminal{rune-constant} \\
	\nonterminal{string-constant} \\
	\terminal{true} \\
	\terminal{false} \\
	\terminal{null} \\
	\terminal{void} \\
\end{grammar}

\specsubsubitem
Constants (also known as literals) shall describe a specific value of an
unambiguous type. The result of the expression is the constant value.

\specsubsubitem
The keywords \terminal{true} and \terminal{false} respectively represent
the constants of the \terminal{bool} type.

\specsubsubitem
The representation of \terminal{true} as an \terminal{uint}-equivalent (ref
\subsubitemref{Other primitive types}{2}) shall be one.

\specsubsubitem
The \terminal{null} keyword represents the \terminal{null} value of the
\terminal{null} type.

\specsubsubitem
The \terminal{void} keyword represents the \terminal{void} value of the
\terminal{void} type.

\specsubsection{Floating constants}

\begin{grammar}
\nonterminaldef{floating-constant} \\
	\nonterminal{decimal-digits} \terminal{.} \nonterminal{decimal-digits} \optional{\nonterminal{exponent}} \optional{\nonterminal{floating-suffix}} \\
	\nonterminal{decimal-digits} \optional{\nonterminal{exponent}} \nonterminal{floating-suffix} \\

\nonterminaldef{floating-suffix} \oneof \\
	\terminal{f32}
	\terminal{f64} \\

\nonterminaldef{decimal-digits} \\
	\nonterminal{decimal-digit} \optional{\nonterminal{decimal-digits}} \\

\nonterminaldef{decimal-digit} \oneof \\
	\terminal{0}
	\terminal{1}
	\terminal{2}
	\terminal{3}
	\terminal{4}
	\terminal{5}
	\terminal{6}
	\terminal{7}
	\terminal{8}
	\terminal{9} \\

\nonterminaldef{exponent} \\
	\terminal{e} \nonterminal{decimal-digits} \\
\end{grammar}

% TODO: consider using magic precision numeric constants which assume
% their type from context

Floating constants represent an IEEE 754-compatible floating-point
number in either the binary32 or binary64 format.

\specsubitem
If the \nonterminal{floating-suffix} is not provided, the type shall be
\terminal{f64}. Otherwise, the type shall refer to the type named by the suffix.

\specsubitem
If the \nonterminal{exponent} is provided, the value of the
constant shall be multiplied by 10 to the power of
\nonterminal{decimal-digits}.

\specsubsection{Integer constants}

\begin{grammar}
\nonterminaldef{integer-constant} \\
	\terminal{0x} \nonterminal{hex-digits} \optional{\nonterminal{integer-suffix}} \\
	\terminal{0o} \nonterminal{octal-digits} \optional{\nonterminal{integer-suffix}} \\
	\terminal{0b} \nonterminal{binary-digits} \optional{\nonterminal{integer-suffix}} \\
	\nonterminal{decimal-digits} \optional{\nonterminal{exponent}}
		\optional{\nonterminal{integer-suffix}} \\

\nonterminaldef{hex-digits} \\
	\nonterminal{hex-digit} \optional{\nonterminal{hex-digits}} \\

\nonterminaldef{hex-digit} \oneof \\
	\terminal{0}
	\terminal{1}
	\terminal{2}
	\terminal{3}
	\terminal{4}
	\terminal{5}
	\terminal{6}
	\terminal{7}
	\terminal{8}
	\terminal{9}
	\terminal{A}
	\terminal{B}
	\terminal{C}
	\terminal{D}
	\terminal{E}
	\terminal{F}
	\terminal{a}
	\terminal{b}
	\terminal{c}
	\terminal{d}
	\terminal{e}
	\terminal{f} \\

\nonterminaldef{octal-digits} \\
	\nonterminal{octal-digit} \optional{\nonterminal{octal-digits}} \\

\nonterminaldef{octal-digit} \oneof \\
	\terminal{0}
	\terminal{1}
	\terminal{2}
	\terminal{3}
	\terminal{4}
	\terminal{5}
	\terminal{6}
	\terminal{7} \\

\nonterminaldef{binary-digits} \\
	\nonterminal{binary-digit} \optional{\nonterminal{binary-digits}} \\

\nonterminaldef{binary-digit} \oneof \\
	\terminal{0}
	\terminal{1} \\

\nonterminaldef{integer-suffix} \oneof \\
	\terminal{i}
	\terminal{u}
	\terminal{z}
	\terminal{i8}
	\terminal{i16}
	\terminal{i32}
	\terminal{i64}
	\terminal{u8}
	\terminal{u16}
	\terminal{u32}
	\terminal{u64} \\
\end{grammar}

% TODO: Consider using magic precision numeric constants which assume their
% type from context

Integer constants represent an integer value at a specific precision.

\specsubitem
If the \nonterminal{integer-suffix} is not provided, the type shall be
\terminal{int}.  Otherwise, the type is specified by the suffix. Suffixes
\terminal{i}, \terminal{u},  and \terminal{z} shall respectively refer to the
\terminal{int}, \terminal{uint}, and \terminal{size} types; the remainder shall
refer to the type named by the suffix.

\specsubitem
If the number provided is not within the limits of the precision of the
constant type, a diagnostic message shall be printed and the translation phase
shall fail.

\specsubitem
The prefixes \terminal{0x}, \terminal{0o}, and \terminal{0b} shall respectively
cause the number to be interpreted with a hexadecimal, octal, or binary base.
If no prefix is used, the number shall be interpreted with a decimal base.

\specsubitem
If the \nonterminal{exponent} is provided, the value of the
integer shall be multiplied by 10 to the power of \nonterminal{decimal-digits}.

\specsubsection{Rune constants}
\begin{grammar}
\nonterminaldef{rune-constant} \\
	\terminal{'} \nonterminal{rune} \terminal{'} \\

\nonterminaldef{rune} \\
	\norm{Any character other than \terminal{\textbackslash} or \terminal{'}} \\
	\nonterminal{escape-sequence} \\

\nonterminaldef{escape-sequence} \\
	\nonterminal{named-escape} \\
	\terminal{\textbackslash{}x} \nonterminal{hex-digit} \nonterminal{hex-digit} \\
	\terminal{\textbackslash{}u} \nonterminal{hex-digit} \nonterminal{hex-digit} \nonterminal{hex-digit} \nonterminal{hex-digit} \\

\nonterminaldef{named-escape} \oneof \\
	\terminal{\textbackslash0}
	\terminal{\textbackslash{}a}
	\terminal{\textbackslash{}b}
	\terminal{\textbackslash{}f}
	\terminal{\textbackslash{}n}
	\terminal{\textbackslash{}r}
	\terminal{\textbackslash{}t}
	\terminal{\textbackslash{}v}
	\terminal{\textbackslash\textbackslash}
	\terminal{\textbackslash'}
	\terminal{\textbackslash"} \\
\end{grammar}

\specsubsubitem
If the \nonterminal{rune-constant} is not an \nonterminal{escape-sequence}, the
value of the rune shall be the Unicode codepoint representing
\nonterminal{rune}.

\specsubsubitem
A \nonterminal{rune-constant} beginning with \terminal{\textbackslash{}x} or
\terminal{\textbackslash{}u} shall interpet its value as a Unicode codepoint
specified in its hexadecimal representation by \nonterminal{hex-digit}s.

\specsubsubitem
A \nonterminal{rune-constant} containing a \nonterminal{named-escape} shall have
a value based on the following chart:

\begin{tabular}{r | l | r | l}
Escape sequence & Unicode codepoint & Escape sequence & Unicode codepoint \\
\hline
\terminal{\textbackslash0} & \code{U+0000} &
\terminal{\textbackslash{}a} & \code{U+0007} \\
\terminal{\textbackslash{}b} & \code{U+0008} &
\terminal{\textbackslash{}f} & \code{U+000C} \\
\terminal{\textbackslash{}n} & \code{U+000A} &
\terminal{\textbackslash{}r} & \code{U+000D} \\
\terminal{\textbackslash{}t} & \code{U+0009} &
\terminal{\textbackslash{}v} & \code{U+000B} \\
\terminal{\textbackslash\textbackslash} & \code{U+005C} &
\terminal{\textbackslash'} & \code{U+002C} \\
\terminal{\textbackslash"} & \code{U+0022} \\
\end{tabular}

\specsubsection{String constants}

\begin{grammar}
\nonterminaldef{string-constant} \\
	\terminal{"} \nonterminal{string-chars} \terminal{"} \\

\nonterminaldef{string-chars} \\
	\nonterminal{string-char} \optional{\nonterminal{string-chars}} \\

\nonterminaldef{string-char} \\
	\norm{Any character other than \terminal{\textbackslash} or \terminal{"}} \\
	\nonterminal{escape-sequence} \\
\end{grammar}

\specsubsubitem
A \nonterminal{string-constant} expression shall have a result type of
\terminal{const} \terminal{str}.

\specsubsubitem
The string's \textit{data} field shall refer to a UTF-8 encoded sequence of
Unicode codepoints, ascertained by encoding the sequence of
\nonterminal{string-char}s given in order, after interpreting escape codes per
\subsubitemref{Rune constants}{17}.

\specsubsubitem
The \textit{length} and \textit{capacity} fields shall be set to the length in
octets of the encoded UTF-8 data.

\specsubsection{Array literals}

\begin{grammar}
\nonterminaldef{array-literal} \\
	\terminal{[} \nonterminal{array-members} \terminal{]} \\

\nonterminaldef{array-members} \\
	\nonterminal{simple-expression} \optional{\terminal{,}} \\
	\nonterminal{simple-expression} \terminal{...} \optional{\terminal{,}} \\
	\nonterminal{simple-expression} \terminal{,} \nonterminal{array-members} \\
\end{grammar}

Forward references: \subsecref{Simple, complex, and compound expressions}

\specsubsubitem
An \nonterminal{array-literal} expression produces a value of an array type.
The type of each \nonterminal{simple-expression} shall be uniform and shall
determine the member type of the array value, and the length of the array type
shall be defined by the number of members.

\specsubsubitem
The execution environment shall evaluate the \nonterminal{array-members},
ordered such that any side-effects of evaluating the arguments occur in the
order that the members are listed, such that the \textit{N}th member provides
the value for the \textit{N}th array member.

\specsubsubitem
If the \terminal{...} form is used, the result's array type shall be expandable.

\specsubsection{Struct literals}

\begin{grammar}
\nonterminaldef{struct-literal} \\
	\terminal{struct} \terminal{\{} \nonterminal{field-values} \optional{\terminal{,}} \terminal{\}} \\
	\nonterminal{identifier} \terminal{\{} \nonterminal{struct-initializer} \optional{\terminal{,}} \terminal{\}} \\

\nonterminaldef{struct-initializer} \\
	\nonterminal{field-values} \\
	\nonterminal{field-values} \terminal{,} \terminal{...} \\
	\terminal{...} \\

\nonterminaldef{field-values} \\
	\nonterminal{field-value} \\
	\nonterminal{field-values} \terminal{,} \nonterminal{field-value} \\

\nonterminaldef{field-value} \\
	\nonterminal{identifier} \terminal{=} \nonterminal{simple-initializer} \\
	\nonterminal{identifier} \terminal{:} \nonterminal{type} \terminal{=} \nonterminal{initializer} \\
	\nonterminal{struct-literal} \\
\end{grammar}
% TODO: Define initializer and simple-initializer

\specsubsubitem
A \nonterminal{struct-literal} produces a value of a struct type. The first
form is the \textit{plain form}, and the second form is the \textit{named form}.

\specsubsubitem
If the plain form is given, the result type shall be a struct type defined by
the \nonterminal{field-value}s, in order, with their identifiers and types
explicitly specified. The first form of \nonterminal{field-value} shall not be
used in such a struct.

\specsubsubitem
If the named form is given, the \nonterminal{identifier} shall identify a type
alias (see \subsecref{Type aliases}) which refers to a struct type. The result
type shall be this alias type.

\specsubsubitem
If \terminal{...} is not given, \nonterminal{field-values} shall be
\textit{exhaustive}, and include every field of the result type exactly once.
Otherwise, a diagnostic message shall be printed and the translation phase
shall abort.

\specsubsubitem
If \terminal{...} is given, any fields of the result type which are not
included in \nonterminal{field-values} shall be initialized to their default
values.

\specsubsubitem
If the \nonterminal{struct-literal} form of the \nonterminal{field-value} is
given, its fields shall be interpreted as fields of the parent struct.

\informative{The following values are equivalent: \\
\code{struct \{ a: int = 10, b: int = 20 \}} \\
\code{struct \{ a: int = 10, struct \{ b: int = 20 \} \}}}

\specsubsection{Plain expressions}

\begin{grammar}
\nonterminaldef{plain-expression} \\
	\nonterminal{identifier} \\
	\nonterminal{constant} \\
	\nonterminal{array-literal} \\
	\nonterminal{struct-literal} \\

\nonterminaldef{nested-expression} \\
	\nonterminal{plain-expression} \\
	\terminal{(} \nonterminal{complex-expression} \terminal{)} \\
\end{grammar}

Forward references: \subsecref{Simple, complex, and compound expressions}

\specsubsubitem
\nonterminal{plain-expression} is an expression class which represents its
result value "plainly". In the case of constants and literals, the value is
represented by the result of those expressions. In the case of an
\nonterminal{identifier}, the expression produces the value of the identified
object.

\specsubsubitem
\nonterminal{nested-expression} is an expression class provided to allow the
programmer to overcome constraints placed on the valid range of expression
types in certain parts of the grammar, and to overcome undesirable
associativity between operators.

\specsubsection{Calls}

\begin{grammar}
\nonterminaldef{call-expression} \\
	\nonterminal{postfix-expression} \terminal{(} \optional{\nonterminal{argument-list}} \terminal{)} \\

\nonterminaldef{argument-list} \\
	\nonterminal{complex-expression} \optional{\terminal{,}} \\
	\terminal{...} \nonterminal{complex-expression} \optional{\terminal{,}} \\
	\nonterminal{complex-expression} \terminal{,} \nonterminal{argument-list} \\
\end{grammar}

Forward references: \subsecref{Simple, complex, and compound expressions}

\specsubsubitem
A \nonterminal{call-expression} shall invoke a function in the execution
environment and its result shall be a value of the type specified by the
\nonterminal{postfix-expression}'s function result type. This evaluation shall
include any necessary side-effects per \subsubitemref{Program execution}{1}.

\specsubsubitem
The \nonterminal{postfix-expression} shall have a function type which does not
have the \terminal{@init}, \terminal{@fini}, or \terminal{@test} attributes set.

\specsubsubitem
The \nonterminal{argument-list} shall be a list of expressions whose types
shall be assignable to the types of the function's parameters, in the order
that they are declared in the function type.

\specsubsubitem
The execution environment shall evaluate the \nonterminal{argument-list},
ordered such that any side-effects of evaluating the arguments occur in the
order that the arguments are listed, to obtain the parameter values required to
invoke the function.

\specsubsubitem
If the invoked function uses Hare-style variadism, the
\nonterminal{argument-list} shall provide zero or more arguments following the
last non-variadic parameter, all of which must be assignable to the type of the
variadic parameter.

\specsubsubitem
If the final argument uses the \terminal{...} form, it must occupy the position of a
variadic parameter and be of a slice or array type. The implementation shall
interpret this value as the list of variadic parameters.

\specsubsubitem
If the invoked function uses C-style variadism, the function may provide zero
or more arguments following the final parameter. These arguments shall be of a
type with a non-zero size, but are otherwise unconstrained.

\specsubsubitem
The specific means by which the invoked function assumes control of the
execution environment, and by which the arguments are provided to it, is
implementation-defined.

\informative{This is generally provided by the target's ABI specification.}

\specsubsubitem
If the function type which is called has the \terminal{@noreturn} attribute,
the call expression is considered to terminate.

\specsubsection{Assertions}

\begin{grammar}
\nonterminaldef{assertion-expression} \\
	\terminal{assert} \terminal{(} \nonterminal{simple-expression} \terminal{)} \\
	\terminal{assert} \terminal{(} \nonterminal{simple-expression} \terminal{,} \nonterminal{string-constant} \terminal{)} \\
	\terminal{static} \terminal{assert} \terminal{(} \nonterminal{simple-expression} \terminal{)} \\
	\terminal{static} \terminal{assert} \terminal{(} \nonterminal{simple-expression} \terminal{,} \nonterminal{string-constant} \terminal{)} \\
	\terminal{abort} \terminal{(} \terminal{)} \\
\end{grammar}

Forward references: \subsecref{Simple, complex, and compound expressions}

\specsubsubitem
An \nonterminal{assertion-expression} is used to validate an assumption by the
programmer by \textit{asserting} its truth. The result type of a
\nonterminal{assertion-expression} is \terminal{void}.

\specsubsubitem
\nonterminal{simple-expression} shall be an expression of type
\nonterminal{bool}.

\specsubsubitem
In the first two forms, this expression shall be evaluated
in the execution environment, and if false, a diagnostic message shall be
printed and the execution phase aborted. The programmer may provide the
\nonterminal{string-constant} to be included in the diagnostic message.

\specsubsubitem
In the \terminal{static} form, \nonterminal{simple-expression} shall be limited
to the \subsecref{Translation compatible expression subset}, shall be evaluated
in the translation environment, and is otherwise equivalent to the other forms.

\specsubsubitem
The \terminal{abort} form shall cause the execution environment to print a
diagnostic message and abort. An abort is a terminating expression.

\specsubsection{Measurements}

\begin{grammar}
\nonterminaldef{measurement-expression} \\
	\nonterminal{size-expression} \\
	\nonterminal{length-expression} \\
	\nonterminal{offset-expression} \\

\nonterminaldef{size-expression} \\
	\terminal{size} \terminal{(} \nonterminal{type} \terminal{)} \\

\nonterminaldef{length-expression} \\
	\terminal{len} \terminal{(} \nonterminal{identifier} \terminal{)} \\

\nonterminaldef{offset-expression} \\
	\terminal{offset} \terminal{(} \nonterminal{field-access-expression} \terminal{)} \\
\end{grammar}

Forward references: \subsecref{Field access}

\specsubsubitem
A \nonterminal{measurement-expression} is used to measure objects. The result
type shall be \terminal{size}.

\specsubsubitem
The \terminal{size} expression shall compute the \textit{size} of the specified
\nonterminal{type}.

\specsubsubitem
The \terminal{len} expression shall compute the \textit{length} of a bounded
array, or the \code{length} field of a slice object, referred to by
\nonterminal{identifier}. If an unbounded array object is given, the
translation environment shall print a diagnostic message and abort.

\specsubsubitem
The \terminal{offset} expression shall determine the struct field which would be
accessed by \nonterminal{field-access-expression} and compute its
\textit{offset}.

\specsubsection{Field access}

\begin{grammar}
\nonterminaldef{field-access-expression} \\
	\nonterminal{postfix-expression} \terminal{.} \nonterminal{name} \\
\end{grammar}

\specsubsubitem
A \nonterminal{field-access-expression} is used to access fields of
\subsecref{Struct and union types}. The result type of the
\nonterminal{postfix-expression} shall be a struct type or a union type.

\specsubsubitem
If the \nonterminal{postfix-expression}'s result type is a union type, the
result of the \nonterminal{field-access-expression} shall be the union's storage
area interpreted as the type of the field named by \nonterminal{name}, and the
result type of the expression shall be the type of the named field.

\specsubsubitem
If the type of the struct object in the first term has the \terminal{const}
flag, the result type shall also have the \terminal{const} flag set, regardless
of the flag's value on the type of the named field.

\specsubsubitem
If the \nonterminal{postfix-expression}'s result type is a struct type,
the result of the \nonterminal{field-access-expression} shall be the value
stored in the \nonterminal{name} field of the result of the
\nonterminal{postfix-expression}, and the result type of the expression shall be
the type of the named field.

\specsubsection{Indexing}

\begin{grammar}
\nonterminaldef{indexing-expression} \\
	\nonterminal{postfix-expression} \terminal{[} \nonterminal{simple-expression} \terminal{]} \\
\end{grammar}

\specsubsubitem
An \nonterminal{indexing-expression} shall access a specific value of a slice
or array type. The \nonterminal{postfix-expression} shall have a result type of
slice or array, and the \nonterminal{simple-expression} shall have a result
type which is assignable to \nonterminal{size}.

\specsubsubitem
The result type of an \nonterminal{indexing-expression} is the secondary type
of the slice or array type given by the \nonterminal{postfix-expression} result
type.

\specsubsubitem
If the type of the array or slice object in the first term has the
\terminal{const} flag, the result type shall also have the \terminal{const}
flag set, regardless of the flag's value on the secondary type.

\specsubsubitem
The execution environment shall compute the result of
\nonterminal{simple-expression} to obtain $N$ for selecting the \textit{N} per
the algorithm given in \subsecref{Slice and array types}.

\specsubsubitem
The execution environment shall perform a \textit{bounds test} on the value of
$N$ to ensure it falls within the acceptable range for the given slice or array
type. It shall test that $N < Z$, where $Z$ is the length of the bounded array
type, or the \code{length} field of the slice, whichever is appropriate.  For
unbounded array types, the bounds test shall not occur. If the bounds test
fails, a diagnostic message shall be printed and the execution environment
shall abort.

The implementation may perform a bounds test in the translation environment if
is able, print a diagnostic message, and abort the translation environment if
it fails.

\specsubsection{Slicing}

\begin{grammar}
\nonterminaldef{slicing-expression} \\
	\nonterminal{postfix-expression} \terminal{[} \optional{\nonterminal{simple-expression}} \terminal{..} \optional{\nonterminal{simple-expression}} \terminal{]} \\
\end{grammar}

\specsubsubitem
A \nonterminal{slicing-expression} shall have a result type of
\nonterminal{slice}, which is computed a subset of a slice or array object.
\nonterminal{postfix-expression} shall be of a slice or array type, and the
optional \nonterminal{simple-expression}s shall be assignable to
\nonterminal{size}.

\specsubsubitem
The first \nonterminal{simple-expression} shall compute value $L$, and the
second shall compute $H$. If absent, $L = 0$ and $H = \code{length}$, where
\code{length} shall be equal to the length of a bounded array type or the
length of a slice type, represented in either case by the result of
\nonterminal{postfix-expression}. If $H$ is not specified, and
\nonterminal{postfix-expression} is of an unbounded array type, the translation
environment shall abort.

\specsubsubitem
The resulting slice value shall have its \code{data} field set from, in the case
of an array type, the address of the array; or in the case of a slice type, the
\code{data} value of the source object; plus $L \times S$, where $S$ is the
size of the slice or array's secondary type.

\specsubsubitem
The resulting slice value shall have its \code{length} and \code{capacity}
fields set to $H - L$.

\specsubsubitem
The secondary type of the resulting slice type shall be equivalent to the
secondary type of the slice or array type given by
\nonterminal{postfix-expression}. The resulting slice type shall inherit the
\nonterminal{const} attribute from this type.

\specsubsection{Postfix expressions}

\begin{grammar}
\nonterminaldef{postfix-expression} \\
	\nonterminal{nested-expression} \\
	\nonterminal{assertion-expression} \\
	\nonterminal{call-expression} \\
	\nonterminal{field-access-expression} \\
	\nonterminal{indexing-expression} \\
	\nonterminal{measurement-expression} \\
	\nonterminal{slicing-expression} \\
\end{grammar}

\specsubsubitem
\nonterminal{postfix-expression} is an expression class for expressions whose
operators use postfix notation.

\specsubsection{Unary arithmetic}

\begin{grammar}
\nonterminaldef{unary-expression} \\
	\nonterminal{postfix-expression} \\
	\nonterminal{unary-operator} \nonterminal{unary-expression} \\

\nonterminaldef{unary-operator} \oneof \\
	\terminal{+}
	\terminal{-}
	\terminal{\textasciitilde}
	\terminal{!}
	\terminal{*}
	\terminal{\&}
\end{grammar}

% TODO: Consider removing unary +

\specsubsubitem
A unary expression applies a \nonterminal{unary-operator} to a single value.

\specsubsubitem
The \terminal{+} and \terminal{-} operators shall respectively perform unary
positive and unary negation operations. The result type shall be equivalent to
the type of \nonterminal{unary-expression}, which shall be of a signed numeric
type.

\specsubsubitem
The \terminal{\textasciitilde} operator shall perform a binary NOT operation,
inverting each bit of the value. Its result type shall be equivalent to the
type of \nonterminal{unary-expression}, which shall be of an unsigned integer
type.

\specsubsubitem
The \terminal{!} operator shall perform a logical NOT operation. The result
type, and the type of \nonterminal{unary-expression}, shall both be
\terminal{bool}. If the \nonterminal{unary-expression} is \terminal{true}, the
result shall be \terminal{false}, and vice-versa.

\specsubsubitem
The \terminal{*} operator shall dereference a pointer, and return the object it
references.  The type of \nonterminal{unary-expression} shall be a pointer
type, and the result type shall be the pointer's secondary type. The pointer
type shall not be \textit{nullable}.

\specsubsubitem
The \terminal{\&} operator shall take the address of an object. The result type
shall be a pointer whose secondary type is the type of
\nonterminal{unary-expression}.

\informative{The following table is informative.}

\begin{tabular}{r | l }
Operator & Meaning \\
\hline
\terminal{+} & Positive \\
\terminal{-} & Negation \\
\terminal{\textasciitilde} & Binary NOT \\
\terminal{!} & Logical NOT \\
\terminal{*} & Dereference pointer \\
\terminal{\&} & Take address \\
\end{tabular}

\specsubsection{Casts and type assertions}

\begin{grammar}
\nonterminaldef{cast-expression} \\
	\nonterminal{unary-expression} \\
	\nonterminal{cast-expression} \terminal{:} \nonterminal{type} \\
	\nonterminal{cast-expression} \terminal{as} \nonterminal{type} \\
	\nonterminal{cast-expression} \terminal{is} \nonterminal{type} \\
\end{grammar}

\specsubsubitem
A cast expression interrogates or converts the type of an object. The first
form illustrates the precedence. The second and third forms (\terminal{:} and
\terminal{as}) have a result type specified by the \nonterminal{type}; and the
fourth form (\terminal{is}) has a result type of \terminal{bool}.

\specsubsubitem
The second form is a \textit{type cast}, and is only valid for a combination of
\textit{source types} and \textit{destination types} which are specified by the
following table:

\begin{tabular}{r | l}
Source type & Casts to \\
\hline
Floating types & Any numeric type \\
Integer types & Any numeric type or enum type, or \terminal{uintptr} \\
\terminal{bool}, \terminal{null}, \terminal{void} & Cannot be cast \\
\terminal{char} & \terminal{u8} \\
\terminal{str} & \terminal{*} \terminal{char} \\
\terminal{uintptr} & Any pointer type or any integer type \\
Any pointer type & Any pointer type or \terminal{uintptr} \\
Enum types & Any enum type or numeric type \\
Struct \& union types & Cannot be cast \\
Tagged unions & See notes \\
Type alias & Any type the underlying type could cast to \\
\end{tabular}

Tagged union types are mutually castable with any type which is found among its
members, including the otherwise non-castable types of \terminal{bool} and
\terminal{void}.

A type which may be cast to another type is considered \textit{castable} to
that type.

\specsubsubitem
When an integer type is cast to an integer of less precision, it shall be
truncated towards the least significant bit.

\specsubsubitem
When a signed type is cast to a unsigned type, the sign bit shall be copied to
the most significant bit of the unsigned type, and vice versa.

\specsubsubitem
When a floating type is cast to an integer, the resulting value shall be equal
to $I = \lfloor F \rfloor$, where F is the source value. If the destination type
has insufficient precision to represent $I$, it shall be truncated towards the
least significant bit.

\specsubsubitem
When casting an integer to a floating point type, if the destination type
lacks the precision to represent the value, it shall be truncated towards zero.

\specsubsubitem
Casting a pointer type to \nonterminal{uintptr}, and then back to the pointer
type, shall yield the same pointer.

\informative{However, casting \nonterminal{uintptr} to any other integer type
and back again may truncate towards the least significant bit and is not
guaranteed to yield the same pointer.}

\specsubsubitem
Casting a \terminal{str} to \terminal{*} \terminal{char} is a special case; it
is equivalent to casting the string's \textit{data} field to \terminal{*}
\terminal{char}.

\specsubsubitem
The third form is a \textit{type assertion}. In this form,
\nonterminal{cast-expression} shall be of a tagged union type, and
\nonterminal{type} shall be a constituent type of that tagged union. The
\nonterminal{cast-expression} shall be computed, and if the tag does not match
\nonterminal{type}, a diagnostic message shall be printed and the execution
environment shall abort. Otherwise, the result type is \nonterminal{type}.

\specsubsubitem
The fourth form is a \textit{type test}. In this form,
\nonterminal{cast-expression} shall be of a tagged union type, and
\nonterminal{type} shall be a constituent type of that tagged union. The result
type is \terminal{bool}, and shall be \terminal{true} if the selected tag of
\nonterminal{cast-expression} is \nonterminal{type}, or \terminal{false}
otherwise.

\specsubsection{Multiplicative arithmetic}

\begin{grammar}
\nonterminaldef{multiplicative-expression} \\
	\nonterminal{cast-expression} \\
	\nonterminal{multiplicative-expression} \terminal{*} \nonterminal{cast-expression} \\
	\nonterminal{multiplicative-expression} \terminal{/} \nonterminal{cast-expression} \\
	\nonterminal{multiplicative-expression} \terminal{\%} \nonterminal{cast-expression} \\
\end{grammar}

\specsubsubitem
A \nonterminal{multiplicative-expression} multiplies (\terminal{*}), divides
(\terminal{/}), or obtains the remainder between (\terminal{\%}) two
expressions. The first form illustrates the precedence. The types of the
operands, and the result type, are determined per the \subsecref{Type promotion}
rules.

\specsubsubitem
In the case of division or modulus, the first term is the dividend, and the
second term is the divisor.

\specsubsubitem
A modulus (\terminal{\%}) operation shall be performed with operands of integer
types only.

\specsubsubitem
If an operation would cause the result to overflow the result type, it is
truncated towards the least significant bits in the case of integer types, and
towards zero in the case of float types. Integer divisions which would produce
a fractional part are floored.

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Additive arithmetic}

\begin{grammar}
\nonterminaldef{additive-expression} \\
	\nonterminal{multiplicative-expression} \\
	\nonterminal{additive-expression} \terminal{+} \nonterminal{multiplicative-expression} \\
	\nonterminal{additive-expression} \terminal{-} \nonterminal{multiplicative-expression} \\
\end{grammar}

\specsubsubitem
An \nonterminal{additive-expression} adds (\terminal{+}) two operands, or
subtracts (\terminal{-}) one from another. The first form illustrates the
precedence. The types of the operands, and the result type, are determined per
the \subsecref{Type promotion} rules.

\specsubsubitem
In the case of subtraction, the first term is the minuend, and the second term
is the subtrahend.

\specsubsubitem
If an operation would cause the result to overflow or underflow the result
type, it is truncated towards the least significant bits in the case of integer
types, and towards zero in the case of float types. In the case of signed
types, this truncation will cause the sign bit to change.

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Bit shifting arithmetic}

\begin{grammar}
\nonterminaldef{shift-expression} \\
	\nonterminal{additive-expression} \\
	\nonterminal{shift-expression} \terminal{\textless{}\textless{}} \nonterminal{additive-expression} \\
	\nonterminal{shift-expression} \terminal{\textgreater{}\textgreater{}} \nonterminal{additive-expression} \\
\end{grammar}

\specsubsubitem
A \nonterminal{shift-expression} performs a bitwise left-shift
(\terminal{\textless{}\textless{}}) or right-shift (\terminal{\textgreater{}\textgreater{}}). The first
form illustrates the precedence. The result type shall be the type of the first
operand. Both operands shall be of unsigned integer types.

\specsubsubitem
\code{\nonterminal{shift-expression} \terminal{\textless{}\textless{}} $N$} shall shift
each bit towards the most significant bit $N$ places, and set the least
significant $N$ bits to zero. The $N$ most significant bits shall be silently
discarded. If $N$ is greater than the size in bits of the type, the result shall
be zero.

\informative{This operation is equivalent to multiplying
\nonterminal{shift-expression} by $2^N$}

\specsubsubitem
\code{\nonterminal{shift-expression} \terminal{\textgreater{}\textgreater{}} $N$} shall shift
each bit towards the least significant bit $N$ places, and set the most
significant $N$ bits to zero. The $N$ least significant bits shall be silently
discarded. If $N$ is greater than the size in bits of the type, the result shall
be zero.

\informative{This operation is equivalent to dividing
\nonterminal{shift-expression} by $2^N$}

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Bitwise arithmetic}

\begin{grammar}
\nonterminaldef{and-expression} \\
	\nonterminal{shift-expression} \\
	\nonterminal{and-expression} \terminal{\&} \nonterminal{shift-expression} \\

\nonterminaldef{exclusive-or-expression} \\
	\nonterminal{and-expression} \\
	\nonterminal{exclusive-or-expression} \terminal{\^} \nonterminal{and-expression} \\

\nonterminaldef{inclusive-or-expression} \\
	\nonterminal{exclusive-or-expression} \\
	\nonterminal{inclusive-or-expression} \terminal{|} \nonterminal{exclusive-or-expression} \\
\end{grammar}

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Logical comparisons}

\begin{grammar}
\nonterminaldef{comparision-expression} \\
	\nonterminal{inclusive-or-expression} \\
	\nonterminal{comparision-expression} \terminal{<} \nonterminal{inclusive-or-expression} \\
	\nonterminal{comparision-expression} \terminal{>} \nonterminal{inclusive-or-expression} \\
	\nonterminal{comparision-expression} \terminal{<=} \nonterminal{inclusive-or-expression} \\
	\nonterminal{comparision-expression} \terminal{>=} \nonterminal{inclusive-or-expression} \\

\nonterminaldef{equality-expression} \\
	\nonterminal{comparison-expression} \\
	\nonterminal{equality-expression} \terminal{==} \nonterminal{comparison-expression} \\
	\nonterminal{equality-expression} \terminal{!=} \nonterminal{comparison-expression} \\
\end{grammar}

\specsubsubitem
A \nonterminal{comparison-expression} determines which operand is lesser than
(\terminal{<}), greater than (\terminal{>}), less than or equal to
(\terminal{<=}), or greater than or equal to (\terminal{>=}) the other. The
types of both operands shall both be numeric, and shall be subject to the
\subsecref{Type promotion} rules. The result type shall be \terminal{bool}.

\specsubsubitem
The result of the \terminal{<} operator shall be \terminal{true} if the first
operand is mathematically less than the second operand and \terminal{false}
otherwise.

\specsubsubitem
The result of the \terminal{>} operator shall be \terminal{true} if the first
operand is mathematically greater than the second operand and \terminal{false}
otherwise.

\specsubsubitem
The result of the \terminal{<=} operator shall be \terminal{true} if the
first operand is mathematically less than or equal to second operand
and \terminal{false} otherwise.

\specsubsubitem
The result of the \terminal{>=} operator shall be \terminal{true} if the first
operand is mathematically greater than or equal to second operand
and \terminal{false} otherwise.

\specsubsubitem
An \nonterminal{equalty-expression} determines if two operands are equal to one
another. The result type is \terminal{bool}. If the types of the \terminal{==}
or \terminal{!=} operators are numeric, they shall be subject to
\subsecref{Type promotion}. Otherwise, each operand must be of the same type.

\specsubsubitem
The result of the \terminal{==} operator shall be \terminal{true} if the first
operand is equal to second operand in value, and \terminal{false} otherwise.

\specsubsubitem
The result of the \terminal{!=} operator shall be \terminal{true} if the first
operand is not equal to second operand in value, and \terminal{false} otherwise.

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Logical arithmetic}

\begin{grammar}
\nonterminaldef{logical-and-expression} \\
	\nonterminal{equality-expression} \\
	\nonterminal{logical-and-expression} \terminal{\&\&} \nonterminal{equality-expression} \\

\nonterminaldef{logical-xor-expression} \\
	\nonterminal{logical-and-expression} \\
	\nonterminal{logical-xor-expression} \terminal{\textasciicircum\textasciicircum} \nonterminal{logical-and-expression} \\

\nonterminaldef{logical-or-expression} \\
	\nonterminal{logical-xor-expression} \\
	\nonterminal{logical-or-expression} \terminal{||} \nonterminal{logical-xor-expression} \\
\end{grammar}

\specsubsubitem
For all cases of logical arithmetic, both terms shall be of the \terminal{bool}
type, and the result type shall be \terminal{bool}.

\specsubsubitem
\terminal{\&\&} shall compute a logical and operation, and shall be
\terminal{true} if both terms are \terminal{true}, and false otherwise.

\specsubsubitem
\terminal{\textasciicircum\textasciicircum} shall be a logical exclusive or
operation, and shall be \terminal{true} if the terms are not equal to each
other, and \terminal{false} otherwise.

\specsubsubitem
\terminal{||} shall be a logical or operation, and shall be \terminal{true} if
either term is \terminal{true}, and \terminal{false} otherwise.

\specsubsubitem
If the first term of \nonterminal{logical-and-expression} is \terminal{false},
or the first term of \nonterminal{logical-or-expression} is \terminal{true},
the implementation shall ensure that the side-effects of the second term do not
occur.

\specsubsection{If expressions}

\begin{grammar}
\nonterminaldef{if-expression} \\
	\terminal{if} \nonterminal{conditional-branch} \\
	\terminal{if} \nonterminal{conditional-branch} \terminal{else} \nonterminal{if-expression} \\
	\terminal{if} \nonterminal{conditional-branch} \terminal{else} \nonterminal{compound-expression} \\

\nonterminaldef{conditional-branch} \\
	\terminal{(} \nonterminal{complex-expression} \terminal{)} \nonterminal{compound-expression} \\
\end{grammar}

\specsubsubitem
An \nonterminal{if-expression} chooses which, if any, expression to evaluate
based on a logical criteria. In all forms, the result type of
\nonterminal{complex-expression} shall be \terminal{bool}.

\specsubsubitem
When executing a \nonterminal{conditional-branch}, the implementation shall
evaluate the \\ \nonterminal{complex-expression} (the \textit{condition}), and
if \terminal{true}, the implementation shall execute the corresponding
\nonterminal{compound-expression} (the \textit{branch}), ensuring that all
side-effects occur. If the condition is \terminal{false}, the branch shall not
be executed and shall not cause side-effects.

\specsubsubitem
In the second form, the first \nonterminal{conditional-branch} shall be
executed. If it was \terminal{false}, the second-order
\nonterminal{if-expression} shall be executed; otherwise not. In the latter
case, any side-effects of the second condition or branch shall not occur.

\specsubsubitem
In the third form, the \nonterminal{conditional-branch} shall be executed. If
it was \terminal{false}, the \nonterminal{compound-expression} shall be
executed, and all of its side-effects shall occur.

\specsubsubitem
In the first form, the result type is \terminal{void}. In the second form, the
result type is \terminal{void} unless the third form is present in the
$N^{th}$-order sub-expression for any value of $N$. In this case, and in the
case of the third form used in the first order, if the result types of each
branch are uniform, the result type of the expression as a whole shall be of
that type. If the types are not uniform, the result type shall be a tagged
union of the set of possible result types. The result value shall be selected
from the result of the branch which is executed.

\specsubsubitem
If any of the branch expressions terminate, that branch is not considered for
the purpose of determining the result type. If all branches terminate, the
result type is \terminal{void} and the if statement itself is considered
terminal.

\specsubsection{For loops}

\begin{grammar}
\nonterminaldef{for-loop} \\
	\optional{\nonterminal{label}} \terminal{for} \terminal{(} \nonterminal{for-predicate} \terminal{)} \nonterminal{compound-expression} \\

\nonterminaldef{for-predicate} \\
	\nonterminal{complex-expression} \\
	\nonterminal{complex-expression} \terminal{;} \nonterminal{scope-expression} \\
	\nonterminal{binding} \terminal{;} \nonterminal{complex-expression} \terminal{;} \nonterminal{scope-expression} \\

\nonterminaldef{label}\exactly \\
	\terminal{:} \nonterminal{name} \\
\end{grammar}
% XXX: We may want to narrow the afterthought's expression class

\specsubsubitem
A \nonterminal{for-loop} executes its \nonterminal{compound-expression} zero or
more times, so long as a condition is true. Its result type is \terminal{void}.
If the \nonterminal{label} is present, the expression is \textit{labelled}, and
the label must be unique among all anscestors of the for loop which are
labelled.

\specsubsubitem
In the first form, \nonterminal{for-predicate} specifies the \textit{condition}
with its \nonterminal{complex-expression}. In the second form, the first
expression is the condition, and the second expression is the
\textit{afterthought}. In the third form, the \nonterminal{binding} is the
\textit{binding}, and the two expressions are respectively the condition and
afterthought. The result type of the condition shall be \terminal{bool}.

\specsubsubitem
The implementation shall establish a new scope for the
\nonterminal{compound-expression}, then, if present, it shall evaluate the
\nonterminal{binding} in this scope. The implementation shall then evaluate the
condition. If it is \terminal{true}, the \nonterminal{compound-expression}
shall be evaluated and all of its side-effects shall occur; this process is an
\textit{iteration}. When the iteration is complete, the implementation shall
evaluate the afterthought, if present, and then repeat the process, until the
condition evaluates to \terminal{false}.

\specsubsection{Match expressions}

\specsubsection{Switch expressions}

\specsubsection{Variable binding}

\begin{grammar}
\nonterminaldef{binding-list} \\
	\optional{\terminal{static}} \terminal{let} \nonterminal{bindings} \\
	\terminal{const} \nonterminal{bindings} \\

\nonterminaldef{bindings} \\
	\nonterminal{binding} \optional{\terminal{,}} \\
	\nonterminal{binding} \terminal{,} \nonterminal{bindings} \\

\nonterminaldef{binding} \\
	\nonterminal{name} \terminal{=} \nonterminal{simple-expression} \\
	\nonterminal{name} \terminal{:} \nonterminal{type} \terminal{=} \nonterminal{complex-expression} \\
\end{grammar}

\specsubsubitem
A \nonterminal{binding-list} shall cause one or more objects to become
available in the present scope. Each object shall be identified by its
\nonterminal{name}, and shall have its initial value set to the result of the
\nonterminal{simple-expression} or \nonterminal{complex-expression}. The result
type of a binding list expression is \terminal{void}.

\specsubsubitem
In the first form of \nonterminal{binding-list}, the type of the object shall
be equivalent to the result type of the \nonterminal{simple-expression}. In the
second form, the type shall be as indicated, and the result type of the
\nonterminal{complex-expression} shall be assignable to this type.

\specsubsubitem
If the \terminal{const} form is used, the type of each binding shall be
modified to include the \terminal{const} flag.

\specsubsubitem
If the \terminal{static} form is used, the variables shall be allocated
\textit{statically}, such that they are only initialized once and their
previous value, accounting for any later mutations, is preserved each time
the binding expression is encountered, including across repeated or recursive
calls to the enclosing function.

\specsubsection{Assignment}

\begin{grammar}
\nonterminaldef{object-selector} \\
	\nonterminal{identifier} \\
	\nonterminal{indexing-expression} \\
	\nonterminal{field-access-expression} \\

\nonterminaldef{assignment} \\
	\nonterminal{object-selector} \terminal{=} \nonterminal{complex-expression} \\
	\terminal{*} \nonterminal{unary-expression} \terminal{=} \nonterminal{complex-expression} \\
\end{grammar}
% TODO: += -= etc

\specsubsubitem
An \nonterminal{assignment} expression shall cause the object given by the
first term to be assigned the value given by the second term.

\specsubsubitem
In the first form, the \nonterminal{object-selector} selects the object to be
modified. The type of this object shall not be of a \terminal{const} type.

\specsubsubitem
In the second form, the \nonterminal{unary-expression} shall have a result type
of a non-nullable, non-const pointer type, and the object which is assigned
shall be the secondary object to which the pointer object refers. The second
term shall be assignable to the pointer's secondary type.

\specsubsubitem
The second term shall be \textit{assignable} to the object. Assignability rules
are stricter than \textit{castability} rules. Unless otherwise specified, all
types are assignable only to themselves. The set of other types which are
assignable to a given type are given by the following table:

\begin{tabular}{r | l}
Object type & May be assigned from \\
\hline
Signed integer types & Signed integer types of equal or higher precision \\
Unsigned integer types & Unsigned integer types of equal or higher precision \\
Floating-point types & Any floating-point type of equal or higher precision \\
Nullable pointer types & Non-nullable pointer type of the same secondary type \\
Nullable pointer types & \terminal{null} \\
Tagged union types & Any of its constituent types \\
Type aliases & Any type assignable to the secondary type \\
\end{tabular}

The implementation shall perform any necessary conversion from the source type
to the destination type.

\specsubsection{Expression lists}

\begin{grammar}
\nonterminaldef{expression-list} \\
	\terminal{\{} \nonterminal{expressions} \terminal{\}} \\

\nonterminaldef{expressions} \\
	\nonterminal{scope-expression} \terminal{;} \\
	\nonterminal{scope-expression} \terminal{;} \nonterminal{expressions} \\
\end{grammar}

\specsubsubitem
A \nonterminal{expression-list} evaluates any number of
\nonterminal{scope-expression}s in sequence. The result of the
\nonterminal{expression-list} shall be the result of the final
\nonterminal{scope-expression}.

\specsubsubitem
The expressions shall be evaluated such that the side-effects of each all occur
in the order that each expression appears.

\specsubsubitem
If any of the \nonterminal{scope-expression}s terminate, the
\nonterminal{expression-list} is considered to terminate.

\specsubsubitem
The \nonterminal{expression-list} shall establish a new scope whose parent is
the scope in which the \nonterminal{expression-list} resides.

\specsubsection{Control statements}

\begin{grammar}
\nonterminaldef{control-statement} \\
	\terminal{break} \optional{\nonterminal{label}} \\
	\terminal{continue} \optional{\nonterminal{label}} \\
	\terminal{return} \optional{\nonterminal{complex-expression}} \\
\end{grammar}

\specsubsubitem
\nonterminal{control-statement} causes an \nonterminal{expression-list} to
terminate in a specific way. A control statement is a terminating expression
and its result type is \terminal{void}.

\specsubsubitem
The first and second forms shall be valid only if used within a
\nonterminal{for-loop}. The first form shall cause the loop to abort without
evaluating the \textit{condition} or the \textit{afterthought}. The second form
shall cause the loop to repeat immediately, running the \textit{afterthought},
re-testing the \textit{condition}, and repeating the loop if \terminal{true}.

\specsubsubitem
If the \nonterminal{label} is provided for either the first or second forms, it
shall be used to specify which \nonterminal{for-loop} the statement shall
influence, and shall match a labelled for loop which is an ancestor of the
statement. If the label is not specified, the control statement shall refer to
the most immediate anscestor of the control statement which is a
\nonterminal{for-loop}. If no qualifying loop can be identified, a diagnostic
message shall be shown and the translation phase shall abort.

\specsubsubitem
The third form shall terminate the function the expression is a descendant of.
If the function's result type is not \terminal{void}, the
\nonterminal{complex-expression} shall be provided, and shall be assignable to
the function's result type. It shall provide the result for the function. If
the function's result type is void, the \nonterminal{complex-expression} shall
not be present.

\specsubsubitem
In any of these cases, the implementation shall ensure that side-effects do not
occur for any expressions which are lexically situated \textit{after} the
\nonterminal{control-statement} within the scope of the loop or function they
influence.

\specsubsection{High-level expression classes}

\begin{grammar}
\nonterminaldef{simple-expression} \\
	\nonterminal{logical-or-expression} \\

\nonterminaldef{complex-expression} \\
	\nonterminal{simple-expression} \\
	\nonterminal{if-expression} \\
	\nonterminal{for-loop} \\
	\nonterminal{match-expression} \\
	\nonterminal{switch-expression} \\

\nonterminaldef{scope-expression} \\
	\nonterminal{assignment} \\
	\nonterminal{binding-list} \\
	\nonterminal{complex-expression} \\

\nonterminaldef{compound-expression} \\
	\nonterminal{simple-expression} \\
	\terminal{\{} \nonterminal{expression-list} \terminal{\}} \\
	\terminal{\{} \nonterminal{control-statement} \terminal{;} \terminal{\}} \\
	\terminal{\{} \nonterminal{expression-list} \terminal{;} \nonterminal{control-statement} \terminal{;} \terminal{\}} \\
\end{grammar}
% TODO: Consider moving the final semicolon into control-statement for that
% case. Because the return value is optional, the parser has to scan forward to
% read the semicolon; if present, it is unlexed, if not, the return value is
% parsed. The parser author has to infer themselves, from reading the grammar,
% that the semicolon is the only token which can terminate a control-statement,
% and cannot implement control-statement parsing without the context of its
% users (that is, its user - it's only used by compound-expression).
%
% The disadvantage of moving the terminal in the grammar is that it still needs
% to be here for the other cases, so it'll become inconsistent.

\specsubsubitem
\nonterminal{simple-expression}, \nonterminal{complex-expression},
\nonterminal{scope-expression}, and \nonterminal{compound-expression} are
high-level expression classes which are used to classify the kinds of
expressions which are available in specific situations.

\informative{
\nonterminal{simple-expression} and \nonterminal{complex-expression} are
available in most circumstances. A simple expression can encapsulate a
complex-expression via \nonterminal{nested-expression} should the programmer
consider themselves wiser than the language designer, but generally speaking a
simple-expression will not branch or alter control flow.
}

\informative{
\nonterminal{scope-expression} is available in context where new objects may
be defined (\nonterminal{binding}, \nonterminal{allocation-expression}) and
mutated (\nonterminal{assignment-expression}).
}

\informative{
\nonterminal{compound-expression} is used for lists of expressions evaluated in
sequence, and expands the classification to include
\nonterminal{control-statements}, which are used to influence the flow of
expression evaluation within the sequence.
}
