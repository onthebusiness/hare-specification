\specsection{Expressions}

\specsubitem
An expression is a procedure which the implementation may perform to obtain a
\textit{result}, and possibly cause side-effects (see
\subsubitemref{Program execution}{1}).

\specsubitem
Expression types are organized into a number of classes and subclasses of
expressions which define the contexts in which each expression type is
applicable.

\specsubitem
All expressions have a defined \textit{result type}. It may be \terminal{void}.

\specsubitem
Some expressions \textit{terminate}. The semantics of terminating expressions
vary between different expression types, and will be detailed as appropriate.
If unspecified, expressions described by this expression are presumed to be
non-terminating. Expression classes inherit their termination qualities from the
more specific sub-expressions which they classify.

\specsubsection{Constants}

\begin{grammar}
\nonterminaldef{constant} \\
	\nonterminal{integer-constant} \\
	\nonterminal{floating-constant} \\
	\nonterminal{rune-constant} \\
	\nonterminal{string-constant} \\
	\terminal{true} \\
	\terminal{false} \\
	\terminal{null} \\
	\terminal{void} \\
\end{grammar}

\specsubsubitem
Constants (also known as literals) shall describe a specific value of an
unambiguous type. The result of the expression is the constant value.

\specsubsubitem
The keywords \terminal{true} and \terminal{false} respectively represent
the constants of the \terminal{bool} type.

\specsubsubitem
The representation of \terminal{true} as an \terminal{uint}-equivalent (ref
\subsubitemref{Other primitive types}{2}) shall be one.

\specsubsubitem
The \terminal{null} keyword represents the \terminal{null} value of the
\terminal{null} type.

\specsubsubitem
The \terminal{void} keyword represents the \terminal{void} value of the
\terminal{void} type.

\specsubsection{Floating constants}

\begin{grammar}
\nonterminaldef{floating-constant} \exactly \\
	\nonterminal{decimal-digits} \terminal{.} \nonterminal{decimal-digits} \optional{\nonterminal{exponent}} \optional{\nonterminal{floating-suffix}} \\
	\nonterminal{decimal-digits} \optional{\nonterminal{exponent}} \nonterminal{floating-suffix} \\

\nonterminaldef{floating-suffix} \oneof \\
	\terminal{f32}
	\terminal{f64} \\

\nonterminaldef{decimal-digits} \exactly \\
	\nonterminal{decimal-digit} \optional{\nonterminal{decimal-digits}} \\

\nonterminaldef{decimal-digit} \oneof \\
	\terminal{0}
	\terminal{1}
	\terminal{2}
	\terminal{3}
	\terminal{4}
	\terminal{5}
	\terminal{6}
	\terminal{7}
	\terminal{8}
	\terminal{9} \\

\nonterminaldef{exponent} \exactly \\
	\terminal{e} \nonterminal{decimal-digits} \\
\end{grammar}

% TODO: consider using magic precision numeric constants which assume
% their type from context

Floating constants represent an IEEE 754-compatible floating-point
number in either the binary32 or binary64 format.

\specsubitem
If the \nonterminal{floating-suffix} is not provided, the type shall be
\terminal{f64}. Otherwise, the type shall refer to the type named by the suffix.

\specsubitem
If the \nonterminal{exponent} is provided, the value of the
constant shall be multiplied by 10 to the power of
\nonterminal{decimal-digits}.

\specsubsection{Integer constants}

\begin{grammar}
\nonterminaldef{integer-constant} \exactly \\
	\terminal{0x} \nonterminal{hex-digits} \optional{\nonterminal{integer-suffix}} \\
	\terminal{0o} \nonterminal{octal-digits} \optional{\nonterminal{integer-suffix}} \\
	\terminal{0b} \nonterminal{binary-digits} \optional{\nonterminal{integer-suffix}} \\
	\nonterminal{decimal-digits} \optional{\nonterminal{exponent}}
		\optional{\nonterminal{integer-suffix}} \\

\nonterminaldef{hex-digits} \exactly \\
	\nonterminal{hex-digit} \optional{\nonterminal{hex-digits}} \\

\nonterminaldef{hex-digit} \oneof \\
	\terminal{0}
	\terminal{1}
	\terminal{2}
	\terminal{3}
	\terminal{4}
	\terminal{5}
	\terminal{6}
	\terminal{7}
	\terminal{8}
	\terminal{9}
	\terminal{A}
	\terminal{B}
	\terminal{C}
	\terminal{D}
	\terminal{E}
	\terminal{F}
	\terminal{a}
	\terminal{b}
	\terminal{c}
	\terminal{d}
	\terminal{e}
	\terminal{f} \\

\nonterminaldef{octal-digits} \exactly \\
	\nonterminal{octal-digit} \optional{\nonterminal{octal-digits}} \\

\nonterminaldef{octal-digit} \oneof \\
	\terminal{0}
	\terminal{1}
	\terminal{2}
	\terminal{3}
	\terminal{4}
	\terminal{5}
	\terminal{6}
	\terminal{7} \\

\nonterminaldef{binary-digits} \exactly \\
	\nonterminal{binary-digit} \optional{\nonterminal{binary-digits}} \\

\nonterminaldef{binary-digit} \oneof \\
	\terminal{0}
	\terminal{1} \\

\nonterminaldef{integer-suffix} \oneof \\
	\terminal{i}
	\terminal{u}
	\terminal{z}
	\terminal{i8}
	\terminal{i16}
	\terminal{i32}
	\terminal{i64}
	\terminal{u8}
	\terminal{u16}
	\terminal{u32}
	\terminal{u64} \\
\end{grammar}

% TODO: Consider using magic precision numeric constants which assume their
% type from context

Integer constants represent an integer value at a specific precision.

\specsubitem
If the \nonterminal{integer-suffix} is not provided, the type shall be
\terminal{int}.  Otherwise, the type is specified by the suffix. Suffixes
\terminal{i}, \terminal{u},  and \terminal{z} shall respectively refer to the
\terminal{int}, \terminal{uint}, and \terminal{size} types; the remainder shall
refer to the type named by the suffix.

\specsubitem
If the number provided is not within the limits of the precision of the
constant type, a diagnostic message shall be printed and the translation phase
shall fail.

\specsubitem
The prefixes \terminal{0x}, \terminal{0o}, and \terminal{0b} shall respectively
cause the number to be interpreted with a hexadecimal, octal, or binary base.
If no prefix is used, the number shall be interpreted with a decimal base.

\specsubitem
If the \nonterminal{exponent} is provided, the value of the
integer shall be multiplied by 10 to the power of \nonterminal{decimal-digits}.

\specsubsection{Rune constants}
\begin{grammar}
\nonterminaldef{rune-constant} \\
	\terminal{'} \nonterminal{rune} \terminal{'} \\

\nonterminaldef{rune} \\
	\norm{Any character other than \terminal{\textbackslash} or \terminal{'}} \\
	\nonterminal{escape-sequence} \\

\nonterminaldef{escape-sequence} \\
	\nonterminal{named-escape} \\
	\terminal{\textbackslash{}x} \nonterminal{hex-digit} \nonterminal{hex-digit} \\
	\terminal{\textbackslash{}u} \nonterminal{hex-digit} \nonterminal{hex-digit} \nonterminal{hex-digit} \nonterminal{hex-digit} \\

\nonterminaldef{named-escape} \oneof \\
	\terminal{\textbackslash0}
	\terminal{\textbackslash{}a}
	\terminal{\textbackslash{}b}
	\terminal{\textbackslash{}f}
	\terminal{\textbackslash{}n}
	\terminal{\textbackslash{}r}
	\terminal{\textbackslash{}t}
	\terminal{\textbackslash{}v}
	\terminal{\textbackslash\textbackslash}
	\terminal{\textbackslash'}
	\terminal{\textbackslash"} \\
\end{grammar}

\specsubsubitem
If the \nonterminal{rune-constant} is not an \nonterminal{escape-sequence}, the
value of the rune shall be the Unicode codepoint representing
\nonterminal{rune}.

\specsubsubitem
A \nonterminal{rune-constant} beginning with \terminal{\textbackslash{}x} or
\terminal{\textbackslash{}u} shall interpet its value as a Unicode codepoint
specified in its hexadecimal representation by \nonterminal{hex-digit}s.

\specsubsubitem
A \nonterminal{rune-constant} containing a \nonterminal{named-escape} shall have
a value based on the following chart:

\begin{tabular}{r | l | r | l}
Escape sequence & Unicode codepoint & Escape sequence & Unicode codepoint \\
\hline
\terminal{\textbackslash0} & \code{U+0000} &
\terminal{\textbackslash{}a} & \code{U+0007} \\
\terminal{\textbackslash{}b} & \code{U+0008} &
\terminal{\textbackslash{}f} & \code{U+000C} \\
\terminal{\textbackslash{}n} & \code{U+000A} &
\terminal{\textbackslash{}r} & \code{U+000D} \\
\terminal{\textbackslash{}t} & \code{U+0009} &
\terminal{\textbackslash{}v} & \code{U+000B} \\
\terminal{\textbackslash\textbackslash} & \code{U+005C} &
\terminal{\textbackslash'} & \code{U+002C} \\
\terminal{\textbackslash"} & \code{U+0022} \\
\end{tabular}

\specsubsection{String constants}

\begin{grammar}
\nonterminaldef{string-constant} \\
	\terminal{"} \nonterminal{string-chars} \terminal{"} \\
	\nonterminal{string-constant} \nonterminal{string-constant} \\

\nonterminaldef{string-chars} \\
	\nonterminal{string-char} \optional{\nonterminal{string-chars}} \\

\nonterminaldef{string-char} \\
	\norm{Any character other than \terminal{\textbackslash} or \terminal{"}} \\
	\nonterminal{escape-sequence} \\
\end{grammar}

\specsubsubitem
A \nonterminal{string-constant} expression shall have a result type of
\terminal{const} \terminal{str}.

\specsubsubitem
If the first form of \nonterminal{string-constant} is used, the string's
\textit{data} field shall refer to a UTF-8 encoded sequence of Unicode
codepoints, ascertained by encoding the sequence of \nonterminal{string-char}s
given in order, after interpreting escape codes per
\subsubitemref{Rune constants}{17}, plus a NUL terminator.

\specsubsubitem
If the second form of \nonterminal{string-constant} is used, the string's
\textit{data} field shall refer to a UTF-8 encoded sequence of Unicode
codepoints, ascertained by concatenating the \textit{data} field of the first
\nonterminal{string-constant} and the \textit{data} field of the second
\nonterminal{string-constant}.

\specsubsubitem
The \textit{length} and \textit{capacity} fields shall be set to the length in
octets of the encoded UTF-8 data, not including the NUL terminator.

\specsubsection{Array literals}

\begin{grammar}
\nonterminaldef{array-literal} \\
	\terminal{[} \nonterminal{array-members} \terminal{]} \\

\nonterminaldef{array-members} \\
	\nonterminal{simple-expression} \optional{\terminal{,}} \\
	\nonterminal{simple-expression} \terminal{...} \optional{\terminal{,}} \\
	\nonterminal{simple-expression} \terminal{,} \nonterminal{array-members} \\
\end{grammar}

Forward references: \subsecref{Simple, complex, and compound expressions}

\specsubsubitem
An \nonterminal{array-literal} expression produces a value of an array type.
The type of each \nonterminal{simple-expression} shall be uniform and shall
determine the member type of the array value, and the length of the array type
shall be defined by the number of members.

\specsubsubitem
If an array literal appears as the initializer for a binding expression, the
member type may be inferred from the type of the binding, if specified. Each
value shall be assignable to this type. Otherwise, the type is inferred from
the type of the first value.

\specsubsubitem
The execution environment shall evaluate the \nonterminal{array-members},
ordered such that any side-effects of evaluating the arguments occur in the
order that the members are listed, such that the \textit{N}th member provides
the value for the \textit{N}th array member.

\specsubsubitem
If the \terminal{...} form is used, the result's array type shall be expandable.

\specsubsection{Enum literals}

\begin{grammar}
\nonterminaldef{enum-literal} \exactly \\
	\nonterminal{identifier} \terminal{::} \nonterminal{name} \\
\end{grammar}

\specsubsubitem
An \nonterminal{enum-literal} expression produces a value of an enum type. The
\nonterminal{identifier} shall be a type alias (see \subsecref{Type aliases})
which refers to an enum type. The result type shall be the type alias to which
the \nonterminal{identifier} refers.

\specsubsubitem
The enum type to which the type alias refers shall have an
\nonterminal{enum-value} whose name is the \nonterminal{enum-literal}'s
\nonterminal{name}. The result of the \nonterminal{enum-literal}
shall be the value assigned to this \nonterminal{enum-value}. If there is no
such \nonterminal{enum-value}, a diagnostic message shall be printed and the
translation phase shall abort. 

\specsubsection{Struct literals}

\begin{grammar}
\nonterminaldef{struct-literal} \\
	\terminal{struct} \terminal{\{} \nonterminal{field-values} \optional{\terminal{,}} \terminal{\}} \\
	\nonterminal{identifier} \terminal{\{} \nonterminal{struct-initializer} \optional{\terminal{,}} \terminal{\}} \\

\nonterminaldef{struct-initializer} \\
	\nonterminal{field-values} \\
	\nonterminal{field-values} \terminal{,} \terminal{...} \\
	\terminal{...} \\

\nonterminaldef{field-values} \\
	\nonterminal{field-value} \\
	\nonterminal{field-values} \terminal{,} \nonterminal{field-value} \\

\nonterminaldef{field-value} \\
	\nonterminal{name} \terminal{=} \nonterminal{simple-expression} \\
	\nonterminal{name} \terminal{:} \nonterminal{type} \terminal{=} \nonterminal{complex-expression} \\
	\nonterminal{struct-literal} \\
\end{grammar}

\specsubsubitem
A \nonterminal{struct-literal} produces a value of a struct type. The first
form is the \textit{plain form}, and the second form is the \textit{named form}.

\specsubsubitem
If the plain form is given, the result type shall be a struct type defined by
the \nonterminal{field-value}s, in order, with their identifiers and types
explicitly specified. The first form of \nonterminal{field-value} shall not be
used in such a struct.

\specsubsubitem
If the named form is given, the \nonterminal{identifier} shall identify a type
alias (see \subsecref{Type aliases}) which refers to a struct type. The result
type shall be this alias type.

\specsubsubitem
If \terminal{...} is not given, \nonterminal{field-values} shall be
\textit{exhaustive}, and include every field of the result type exactly once.
Otherwise, a diagnostic message shall be printed and the translation phase
shall abort.

\specsubsubitem
If \terminal{...} is given, any fields of the result type which are not
included in \nonterminal{field-values} shall be initialized to their default
values.

\specsubsubitem
If the \nonterminal{struct-literal} form of the \nonterminal{field-value} is
given, its fields shall be interpreted as fields of the parent struct.

\informative{The following values are equivalent: \\
\code{struct \{ a: int = 10, b: int = 20 \}} \\
\code{struct \{ a: int = 10, struct \{ b: int = 20 \} \}}}

\specsubsection{Plain expressions}

\begin{grammar}
\nonterminaldef{plain-expression} \\
	\nonterminal{identifier} \\
	\nonterminal{constant} \\
	\nonterminal{array-literal} \\
	\nonterminal{enum-literal} \\
	\nonterminal{struct-literal} \\

\nonterminaldef{nested-expression} \\
	\nonterminal{plain-expression} \\
	\terminal{(} \nonterminal{complex-expression} \terminal{)} \\
\end{grammar}

Forward references: \subsecref{Simple, complex, and compound expressions}

\specsubsubitem
\nonterminal{plain-expression} is an expression class which represents its
result value "plainly". In the case of constants and literals, the value is
represented by the result of those expressions. In the case of an
\nonterminal{identifier}, the expression produces the value of the identified
object.

\specsubsubitem
\nonterminal{nested-expression} is an expression class provided to allow the
programmer to overcome constraints placed on the valid range of expression
types in certain parts of the grammar, and to overcome undesirable
associativity between operators.

\specsubsection{Allocations}

\begin{grammar}
\nonterminaldef{allocation-expression} \\
	\terminal{alloc} \terminal{(} \nonterminal{type} \terminal{,} \nonterminal{simple-expression} \terminal{)} \\
	\terminal{alloc} \terminal{(} \nonterminal{type} \terminal{,} \nonterminal{simple-expression} \terminal{,} \nonterminal{simple-expression} \terminal{)} \\
	\terminal{append} \terminal{(} \nonterminal{simple-expression} \terminal{,} \nonterminal{append-values} \terminal{)} \\
	\terminal{free} \terminal{(} \nonterminal{simple-expression} \terminal{)} \\

\nonterminaldef{append-values} \\
	\nonterminal{simple-expression} \optional{\terminal{,}} \\
	\terminal{...} \nonterminal{simple-expression} \optional{\terminal{,}} \\
	\nonterminal{simple-expression} \terminal{,} \nonterminal{append-values} \\
\end{grammar}

\specsubsubitem
An \nonterminal{allocation-expression} is used to manipulate objects allocated
in the execution environment.

\specsubsubitem
In the \terminal{alloc} form, the \nonterminal{type} shall specify a pointer
type or slice type, and this type shall be the result type of the expression.
The first \nonterminal{simple-expression} term is the initializer.

\specsubsubitem
In the case of an \terminal{alloc} of a pointer type, the execution environment
shall allocate storage sufficient to store a value of the referent type, and
initialize it to the value provided by \nonterminal{simple-expression}, which
shall be assignable to that type. The pointer's referent type shall have a
defined, nonzero size.

% TODO: Double check that slice/array types are only valid for defined, nonzero
% sized secondary types

\specsubsubitem
In the case of an \terminal{alloc} of a slice type, the initializer shall be of
a slice or array type whose secondary type is equivalent to the
\nonterminal{type}'s secondary type. The execution environment shall choose a
capacity which shall be greater than or equal to the number of items in the
initializer, then allocate an array of that capacity and set its $N$th value to
the $N$th value of the initializer, for each value of $N$ between $0$
(inclusive) and the length of the initializer (exclusive).  The result shall be
a slice whose data field refers to this array, whose length is equal to the
length of the initializer, and whose capacity is set to the allocated capacity.

% TODO: Allow implementation to over-allocate with a given capacity
\specsubsubitem
If the second form of \terminal{alloc} is used, the \nonterminal{type} shall
specify a slice type, and the third term shall be assignable to \terminal{size}.
The third term shall specify the capacity, which shall be greater than or equal
to the length of the initializer. The execution environment shall use this
capacity rather than one of its own choosing, and in other respects the
semantics shall be the same as the first form.

\specsubsubitem
In the \terminal{alloc} form, if the execution environment is unable to
allocate sufficient storage for the requested type, the execution environment
shall print a diagnostic message and abort. If the type is a nullable pointer
type, \terminal{null} shall be returned instead of aborting.

\specsubsubitem
The \terminal{append} form shall append a new value, or values, to a slice
object.

\specsubsection{Assertions}

\begin{grammar}
\nonterminaldef{assertion-expression} \\
	\terminal{assert} \terminal{(} \nonterminal{simple-expression} \terminal{)} \\
	\terminal{assert} \terminal{(} \nonterminal{simple-expression} \terminal{,} \nonterminal{string-constant} \terminal{)} \\
	\terminal{static} \terminal{assert} \terminal{(} \nonterminal{simple-expression} \terminal{)} \\
	\terminal{static} \terminal{assert} \terminal{(} \nonterminal{simple-expression} \terminal{,} \nonterminal{string-constant} \terminal{)} \\
	\terminal{abort} \terminal{(} \optional{\nonterminal{string-constant}} \terminal{)} \\
\end{grammar}
% TODO: Specify the calling semantics for sys::assert and sys::abort
% Blocked until we start specifying the runtime library details

Forward references: \subsecref{Simple, complex, and compound expressions}

\specsubsubitem
An \nonterminal{assertion-expression} is used to validate an assumption by the
programmer by \textit{asserting} its truth. The result type of a
\nonterminal{assertion-expression} is \terminal{void}.

\specsubsubitem
\nonterminal{simple-expression} shall be an expression of type
\nonterminal{bool}.

\specsubsubitem
In the first two forms, this expression shall be evaluated
in the execution environment, and if false, a diagnostic message shall be
printed and the execution phase aborted. The programmer may provide the
\nonterminal{string-constant} to be included in the diagnostic message.

\specsubsubitem
In the \terminal{static} form, \nonterminal{simple-expression} shall be limited
to the \secref{Translation compatible expression subset}, shall be evaluated
in the translation environment, and is otherwise equivalent to the other forms.

\specsubsubitem
The \terminal{abort} form shall cause the execution environment to print a
diagnostic message and abort. The programmer may provide the
\nonterminal{string-constant} to be included in the diagnostic message. An
abort is a terminating expression.

\specsubsection{Calls}

\begin{grammar}
\nonterminaldef{call-expression} \\
	\nonterminal{postfix-expression} \terminal{(} \optional{\nonterminal{argument-list}} \terminal{)} \\

\nonterminaldef{argument-list} \\
	\nonterminal{complex-expression} \optional{\terminal{,}} \\
	\terminal{...} \nonterminal{complex-expression} \optional{\terminal{,}} \\
	\nonterminal{complex-expression} \terminal{,} \nonterminal{argument-list} \\
\end{grammar}

Forward references: \subsecref{Simple, complex, and compound expressions}

\specsubsubitem
A \nonterminal{call-expression} shall invoke a function in the execution
environment and its result shall be a value of the type specified by the
\nonterminal{postfix-expression}'s function result type. This evaluation shall
include any necessary side-effects per \subsubitemref{Program execution}{1}.

\specsubsubitem
The result type of the \nonterminal{postfix-expression} shall be restricted to a
set which includes all function types which do not have the \terminal{@init},
\terminal{@fini}, or \terminal{@test} attributes set, as well as non-nullable
pointers whose secondary type is included in the set.

\informative{The result type of the \nonterminal{postfix-expression} can be a
function, a pointer to a function, a pointer to a pointer to a function, and so
on.}

\specsubsubitem
The function invoked shall be the function object the
\nonterminal{postfix-expression} refers to, selecting that object indirectly via
any number of pointer types if appropriate.

\specsubsubitem
The \nonterminal{argument-list} shall be a list of expressions whose types
shall be assignable to the types of the invoked function's parameters, in the
order that they are declared in the invoked function's result type.

\specsubsubitem
The execution environment shall evaluate the \nonterminal{argument-list},
ordered such that any side-effects of evaluating the arguments occur in the
order that the arguments are listed, to obtain the parameter values required to
invoke the function.

\specsubsubitem
If the invoked function uses Hare-style variadism, the
\nonterminal{argument-list} shall provide zero or more arguments following the
last non-variadic parameter, all of which must be assignable to the type of the
variadic parameter.

\specsubsubitem
If the final argument uses the \terminal{...} form, it must occupy the position of a
variadic parameter and be of a slice or array type. The implementation shall
interpret this value as the list of variadic parameters.

\specsubsubitem
If the invoked function uses C-style variadism, the function may provide zero
or more arguments following the final parameter. These arguments shall be of a
type with a non-zero size, but are otherwise unconstrained.

\specsubsubitem
The specific means by which the invoked function assumes control of the
execution environment, and by which the arguments are provided to it, is
implementation-defined.

\informative{This is generally provided by the target's ABI specification.}

\specsubsubitem
If the invoked function's result type has the \terminal{@noreturn} attribute,
the call expression is considered to terminate.

\specsubsection{Measurements}

\begin{grammar}
\nonterminaldef{measurement-expression} \\
	\nonterminal{size-expression} \\
	\nonterminal{length-expression} \\
	\nonterminal{offset-expression} \\

\nonterminaldef{size-expression} \\
	\terminal{size} \terminal{(} \nonterminal{type} \terminal{)} \\

\nonterminaldef{length-expression} \\
	\terminal{len} \terminal{(} \nonterminal{postfix-expression} \terminal{)} \\

\nonterminaldef{offset-expression} \\
	\terminal{offset} \terminal{(} \nonterminal{field-access-expression} \terminal{)} \\
\end{grammar}

Forward references: \subsecref{Field access}

\specsubsubitem
A \nonterminal{measurement-expression} is used to measure objects. The result
type shall be \terminal{size}.

\specsubsubitem
The \terminal{size} expression shall compute the \textit{size} of the specified
\nonterminal{type}.

\specsubsubitem
The \terminal{len} expression shall compute the \textit{length} of a bounded
array, or the \code{length} field of a slice object, referred to by
\nonterminal{postfix-expression}. If an unbounded array object is given, the
translation environment shall print a diagnostic message and abort.

\specsubsubitem
The \terminal{offset} expression shall determine the struct field which would be
accessed by \nonterminal{field-access-expression} and compute its
\textit{offset}.

\specsubsection{Field access}

\begin{grammar}
\nonterminaldef{field-access-expression} \\
	\nonterminal{postfix-expression} \terminal{.} \nonterminal{name} \\
\end{grammar}

\specsubsubitem
A \nonterminal{field-access-expression} is used to access fields of
\subsecref{Struct and union types}. The result type of the
\nonterminal{postfix-expression} shall be constrained to a set which includes
all struct and union types, as well as non-nullable pointers whose secondary
type is included in the set.

\informative{The result type of the \nonterminal{postfix-expression} can be a
struct or union, a pointer to a struct or union, a pointer to a pointer to a
struct or union, and so on.}

\specsubsubitem
The object from which the field is selected shall be the struct or union object
the \nonterminal{postfix-expression} refers to, selecting that object indirectly
via any number of pointer types if appropriate.

\specsubsubitem
If the \nonterminal{postfix-expression}'s result type is a union type, the
result of the \nonterminal{field-access-expression} shall be the union's storage
area interpreted as the type of the field named by \nonterminal{name}, and the
result type of the expression shall be the type of the named field.

\specsubsubitem
If the type of the struct object in the first term has the \terminal{const}
flag, the result type shall also have the \terminal{const} flag set, regardless
of the flag's value on the type of the named field.

\specsubsubitem
If the \nonterminal{postfix-expression}'s result type is a struct type,
the result of the \nonterminal{field-access-expression} shall be the value
stored in the \nonterminal{name} field of the result of the
\nonterminal{postfix-expression}, and the result type of the expression shall be
the type of the named field.

\specsubsection{Indexing}

\begin{grammar}
\nonterminaldef{indexing-expression} \\
	\nonterminal{postfix-expression} \terminal{[} \nonterminal{simple-expression} \terminal{]} \\
\end{grammar}

\specsubsubitem
An \nonterminal{indexing-expression} shall access a specific value of a slice
or array type. The \nonterminal{simple-expression} shall have an integer result
type. The result type of the \nonterminal{postfix-expression} shall be
constrained to a set which includes all slice and array types, as well as
non-nullable pointers whose secondary type is included in the set.

\informative{The result type of the \nonterminal{postfix-expression} can be a
slice or array, a pointer to a slice or array, a pointer to a pointer to a
slice or array, and so on.}

\specsubsubitem
The object from which the field is selected shall be the slice or array object
the \nonterminal{postfix-expression} refers to, selecting that object indirectly
via any number of pointer types if appropriate.

\specsubsubitem
The result type of an \nonterminal{indexing-expression} is the secondary type
of the slice or array type given by the \nonterminal{postfix-expression} result
type.

\specsubsubitem
If the type of the array or slice object in the first term has the
\terminal{const} flag, the result type shall also have the \terminal{const}
flag set, regardless of the flag's value on the secondary type.

\specsubsubitem
The execution environment shall compute the result of
\nonterminal{simple-expression} to obtain $N$ for selecting the \textit{N} per
the algorithm given in \subsecref{Slice and array types}.

\specsubsubitem
The execution environment shall perform a \textit{bounds test} on the value of
$N$ to ensure it falls within the acceptable range for the given slice or array
type. It shall test that $N < Z$, where $Z$ is the length of the bounded array
type, or the \code{length} field of the slice, whichever is appropriate.  For
unbounded array types, the bounds test shall not occur. If the bounds test
fails, a diagnostic message shall be printed and the execution environment
shall abort.

The implementation may perform a bounds test in the translation environment if
is able, print a diagnostic message, and abort the translation environment if
it fails.

\specsubsection{Slicing}

\begin{grammar}
\nonterminaldef{slicing-expression} \\
	\nonterminal{postfix-expression} \terminal{[} \optional{\nonterminal{simple-expression}} \terminal{..} \optional{\nonterminal{simple-expression}} \terminal{]} \\
\end{grammar}

\specsubsubitem
A \nonterminal{slicing-expression} shall have a result type of
\nonterminal{slice}, which is computed a subset of a slice or array object.
The optional \nonterminal{simple-expression}s shall have an integer result type.
The result type of the \nonterminal{postfix-expression} shall be constrained to
a set which includes all slice and array types, as well as non-nullable pointers
whose secondary type is included in the set.

\informative{The result type of the \nonterminal{postfix-expression} can be a
slice or array, a pointer to a slice or array, a pointer to a pointer to a
slice or array, and so on.}

\specsubsubitem
The object from which the field is selected shall be the slice or array object
the \nonterminal{postfix-expression} refers to, selecting that object indirectly
via any number of pointer types if appropriate.

\specsubsubitem
The first \nonterminal{simple-expression} shall compute value $L$, and the
second shall compute $H$. If absent, $L = 0$ and $H = \code{length}$, where
\code{length} shall be equal to the length of a bounded array type or the
length of a slice type, represented in either case by the result of
\nonterminal{postfix-expression}. If $H$ is not specified, and
\nonterminal{postfix-expression} is of an unbounded array type, the translation
environment shall abort.

\specsubsubitem
The resulting slice value shall have its \code{data} field set from, in the case
of an array type, the address of the array; or in the case of a slice type, the
\code{data} value of the source object; plus $L \times S$, where $S$ is the
size of the slice or array's secondary type.

\specsubsubitem
The resulting slice value shall have its \code{length} and \code{capacity}
fields set to $H - L$.

\specsubsubitem
The secondary type of the resulting slice type shall be equivalent to the
secondary type of the slice or array type given by
\nonterminal{postfix-expression}. The resulting slice type shall inherit the
\nonterminal{const} attribute from this type.

\specsubsection{Postfix expressions}

\begin{grammar}
\nonterminaldef{postfix-expression} \\
	\nonterminal{nested-expression} \\
	\nonterminal{allocation-expression} \\
	\nonterminal{assertion-expression} \\
	\nonterminal{call-expression} \\
	\nonterminal{field-access-expression} \\
	\nonterminal{indexing-expression} \\
	\nonterminal{measurement-expression} \\
	\nonterminal{slicing-expression} \\

\nonterminaldef{object-selector} \\
	\nonterminal{identifier} \\
	\nonterminal{indexing-expression} \\
	\nonterminal{field-access-expression} \\
\end{grammar}

\specsubsubitem
\nonterminal{postfix-expression} is an expression class for expressions whose
operators use postfix notation.

\specsubsubitem
\nonterminal{object-selector} defines a subset of postfix expressions which
refer to objects, for use in other parts of the grammar.

\specsubsection{Unary arithmetic}

\begin{grammar}
\nonterminaldef{unary-expression} \\
	\nonterminal{postfix-expression} \\
	\nonterminal{unary-operator} \nonterminal{unary-expression} \\
	\terminal{\&} \nonterminal{object-selector} \\

\nonterminaldef{unary-operator} \oneof \\
	\terminal{+}
	\terminal{-}
	\terminal{\textasciitilde}
	\terminal{!}
	\terminal{*}
\end{grammar}

\specsubsubitem
A unary expression applies a \nonterminal{unary-operator} to a single value.

\specsubsubitem
The \terminal{+} and \terminal{-} operators shall respectively perform unary
positive and unary negation operations. The result type shall be equivalent to
the type of \nonterminal{unary-expression}, which shall be of a signed numeric
type.

\specsubsubitem
The \terminal{\textasciitilde} operator shall perform a binary NOT operation,
inverting each bit of the value. Its result type shall be equivalent to the
type of \nonterminal{unary-expression}, which shall be of an unsigned integer
type.

\specsubsubitem
The \terminal{!} operator shall perform a logical NOT operation. The result
type, and the type of \nonterminal{unary-expression}, shall both be
\terminal{bool}. If the \nonterminal{unary-expression} is \terminal{true}, the
result shall be \terminal{false}, and vice-versa.

\specsubsubitem
The \terminal{*} operator shall dereference a pointer, and return the object it
references.  The type of \nonterminal{unary-expression} shall be a pointer
type, and the result type shall be the pointer's secondary type. The pointer
type shall not be \textit{nullable}.

\specsubsubitem
The \terminal{\&} operator shall take the address of an object. The result type
shall be a pointer whose secondary type is the type of the object selected by
\nonterminal{object-selector}.

\informative{The following table is informative.}

\begin{tabular}{r | l }
Operator & Meaning \\
\hline
\terminal{+} & Positive \\
\terminal{-} & Negation \\
\terminal{\textasciitilde} & Binary NOT \\
\terminal{!} & Logical NOT \\
\terminal{*} & Dereference pointer \\
\terminal{\&} & Take address \\
\end{tabular}

\specsubsection{Casts and type assertions}

\begin{grammar}
\nonterminaldef{cast-expression} \\
	\nonterminal{unary-expression} \\
	\nonterminal{cast-expression} \terminal{:} \nonterminal{type} \\
	\nonterminal{cast-expression} \terminal{as} \nonterminal{type} \\
	\nonterminal{cast-expression} \terminal{is} \nonterminal{type} \\
\end{grammar}

\specsubsubitem
A cast expression interrogates or converts the type of an object. The first
form illustrates the precedence. The second and third forms (\terminal{:} and
\terminal{as}) have a result type specified by the \nonterminal{type}; and the
fourth form (\terminal{is}) has a result type of \terminal{bool}.

\specsubsubitem
The second form is a \textit{type cast}, and shall not fail. It shall cause the
execution environment to convert or interpret the value as another type.

\specsubsubitem
A type which may be cast to another type is considered \textit{castable} to
that type.

\specsubsubitem
All types are castable to themselves. The set of other types which are castable
to a given type are given by the following table:

\begin{tabular}{r | l}
Source type & Casts to \\
\hline
Floating types & Any numeric type \\
Integer types & Any numeric type or enum type, or \terminal{uintptr} \\
\terminal{uintptr} & Any pointer type, any integer type, or \terminal{null} \\
Any pointer type & Any pointer type, \terminal{uintptr}, or \terminal{null} \\
Enum types & Any enum type or numeric type \\
Array slice and types & Any slice or array type \\
Type alias & Any type the underlying type could cast to \\
Any type & Any type alias with an underlying type it may be cast to \\
\terminal{str} & \terminal{*} \terminal{const} \terminal{char} \\
\terminal{u8} & \terminal{char} \\
\terminal{char} & \terminal{u8} \\
\terminal{rune} & \terminal{u32} \\
\terminal{u32} & \terminal{rune} \\
Tagged unions & See below \\
\end{tabular}

\specsubsubitem
Tagged union types are mutually castable with any type which is found among its
members, including the otherwise non-castable types of \terminal{bool} and
\terminal{void}, as well as any other tagged union type.

\specsubsubitem
When an integer type is cast to an integer of less precision, it shall be
truncated towards the least significant bit.

\specsubsubitem
When a signed type is cast to a unsigned type, the sign bit shall be copied to
the most significant bit of the unsigned type, and vice versa.

\specsubsubitem
When a floating type is cast to an integer, the resulting value shall be equal
to $I = \lfloor F \rfloor$, where F is the source value. If the destination type
has insufficient precision to represent $I$, it shall be truncated towards the
least significant bit.

\specsubsubitem
When casting an integer to a floating point type, if the destination type
lacks the precision to represent the value, it shall be truncated towards zero.

\specsubsubitem
Casting a pointer type to \nonterminal{uintptr}, and then back to the pointer
type, shall yield the same pointer.

\informative{However, casting \nonterminal{uintptr} to any other integer type
and back again may truncate towards the least significant bit and is not
guaranteed to yield the same pointer.}

\specsubsubitem
Casting a \terminal{str} to \terminal{*} \terminal{const} \terminal{char} is a
special case; it is equivalent to casting the string's \textit{data} field to
\terminal{*} \terminal{const} \terminal{char}.

\specsubsubitem
The third form is a \textit{type assertion}. In this form,
\nonterminal{cast-expression} shall be of a tagged union type, and
\nonterminal{type} shall be a constituent type of that tagged union. The
\nonterminal{cast-expression} shall be computed, and if the tag does not match
\nonterminal{type}, a diagnostic message shall be printed and the execution
environment shall abort. Otherwise, the result type is \nonterminal{type}.

\specsubsubitem
The fourth form is a \textit{type test}. In this form,
\nonterminal{cast-expression} shall be of a tagged union type, and
\nonterminal{type} shall be a constituent type of that tagged union. The result
type is \terminal{bool}, and shall be \terminal{true} if the selected tag of
\nonterminal{cast-expression} is \nonterminal{type}, or \terminal{false}
otherwise.

\specsubsection{Multiplicative arithmetic}

\begin{grammar}
\nonterminaldef{multiplicative-expression} \\
	\nonterminal{cast-expression} \\
	\nonterminal{multiplicative-expression} \terminal{*} \nonterminal{cast-expression} \\
	\nonterminal{multiplicative-expression} \terminal{/} \nonterminal{cast-expression} \\
	\nonterminal{multiplicative-expression} \terminal{\%} \nonterminal{cast-expression} \\
\end{grammar}

\specsubsubitem
A \nonterminal{multiplicative-expression} multiplies (\terminal{*}), divides
(\terminal{/}), or obtains the remainder between (\terminal{\%}) two
expressions. The first form illustrates the precedence. The operands and result
type shall be subject to the \secref{Type promotion} rules.

\specsubsubitem
In the case of division or modulus, the first term is the dividend, and the
second term is the divisor.

\specsubsubitem
A modulus (\terminal{\%}) operation shall be performed with operands of integer
types only.

\specsubsubitem
If an operation would cause the result to overflow the result type, it is
truncated towards the least significant bits in the case of integer types, and
towards zero in the case of float types. Integer divisions which would produce
a fractional part are floored.

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Additive arithmetic}

\begin{grammar}
\nonterminaldef{additive-expression} \\
	\nonterminal{multiplicative-expression} \\
	\nonterminal{additive-expression} \terminal{+} \nonterminal{multiplicative-expression} \\
	\nonterminal{additive-expression} \terminal{-} \nonterminal{multiplicative-expression} \\
\end{grammar}

\specsubsubitem
An \nonterminal{additive-expression} adds (\terminal{+}) two operands, or
subtracts (\terminal{-}) one from another. The first form illustrates the
precedence. The operands and result type shall be subject to the \secref{Type
promotion} rules.

\specsubsubitem
In the case of subtraction, the first term is the minuend, and the second term
is the subtrahend.

\specsubsubitem
If an operation would cause the result to overflow or underflow the result
type, it is truncated towards the least significant bits in the case of integer
types, and towards zero in the case of float types. In the case of signed
types, this truncation will cause the sign bit to change.

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Bit shifting arithmetic}

\begin{grammar}
\nonterminaldef{shift-expression} \\
	\nonterminal{additive-expression} \\
	\nonterminal{shift-expression} \terminal{\textless{}\textless{}} \nonterminal{additive-expression} \\
	\nonterminal{shift-expression} \terminal{\textgreater{}\textgreater{}} \nonterminal{additive-expression} \\
\end{grammar}

\specsubsubitem
A \nonterminal{shift-expression} performs a bitwise left-shift
(\terminal{\textless{}\textless{}}) or right-shift (\terminal{\textgreater{}\textgreater{}}). The first
form illustrates the precedence. The result type shall be the type of the first
operand. Both operands shall be of unsigned integer types.

\specsubsubitem
\code{\nonterminal{shift-expression} \terminal{\textless{}\textless{}} $N$} shall shift
each bit towards the most significant bit $N$ places, and set the least
significant $N$ bits to zero. The $N$ most significant bits shall be silently
discarded. If $N$ is greater than the size in bits of the type, the result shall
be zero.

\informative{This operation is equivalent to multiplying
\nonterminal{shift-expression} by $2^N$}

\specsubsubitem
\code{\nonterminal{shift-expression} \terminal{\textgreater{}\textgreater{}} $N$} shall shift
each bit towards the least significant bit $N$ places, and set the most
significant $N$ bits to zero. The $N$ least significant bits shall be silently
discarded. If $N$ is greater than the size in bits of the type, the result shall
be zero.

\informative{This operation is equivalent to dividing
\nonterminal{shift-expression} by $2^N$}

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Bitwise arithmetic}

\begin{grammar}
\nonterminaldef{and-expression} \\
	\nonterminal{shift-expression} \\
	\nonterminal{and-expression} \terminal{\&} \nonterminal{shift-expression} \\

\nonterminaldef{exclusive-or-expression} \\
	\nonterminal{and-expression} \\
	\nonterminal{exclusive-or-expression} \terminal{\^} \nonterminal{and-expression} \\

\nonterminaldef{inclusive-or-expression} \\
	\nonterminal{exclusive-or-expression} \\
	\nonterminal{inclusive-or-expression} \terminal{|} \nonterminal{exclusive-or-expression} \\
\end{grammar}

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Logical comparisons}

\begin{grammar}
\nonterminaldef{comparision-expression} \\
	\nonterminal{inclusive-or-expression} \\
	\nonterminal{comparision-expression} \terminal{<} \nonterminal{inclusive-or-expression} \\
	\nonterminal{comparision-expression} \terminal{>} \nonterminal{inclusive-or-expression} \\
	\nonterminal{comparision-expression} \terminal{<=} \nonterminal{inclusive-or-expression} \\
	\nonterminal{comparision-expression} \terminal{>=} \nonterminal{inclusive-or-expression} \\

\nonterminaldef{equality-expression} \\
	\nonterminal{comparison-expression} \\
	\nonterminal{equality-expression} \terminal{==} \nonterminal{comparison-expression} \\
	\nonterminal{equality-expression} \terminal{!=} \nonterminal{comparison-expression} \\
\end{grammar}

\specsubsubitem
A \nonterminal{comparison-expression} determines which operand is lesser than
(\terminal{<}), greater than (\terminal{>}), less than or equal to
(\terminal{<=}), or greater than or equal to (\terminal{>=}) the other. The
operands shall be numeric, and are subject to the \secref{Type promotion}
rules.  The result type shall be \terminal{bool}.

\specsubsubitem
The result of the \terminal{<} operator shall be \terminal{true} if the first
operand is mathematically less than the second operand and \terminal{false}
otherwise.

\specsubsubitem
The result of the \terminal{>} operator shall be \terminal{true} if the first
operand is mathematically greater than the second operand and \terminal{false}
otherwise.

\specsubsubitem
The result of the \terminal{<=} operator shall be \terminal{true} if the
first operand is mathematically less than or equal to second operand
and \terminal{false} otherwise.

\specsubsubitem
The result of the \terminal{>=} operator shall be \terminal{true} if the first
operand is mathematically greater than or equal to second operand
and \terminal{false} otherwise.

\specsubsubitem
An \nonterminal{equality-expression} determines if two operands are equal to one
another. The result type is \terminal{bool}. If the types of the \terminal{==}
or \terminal{!=} operators are numeric, they shall be subject to
\subsecref{Type promotion}. Otherwise, each operand must be of the same type.

\specsubsubitem
The result of the \terminal{==} operator shall be \terminal{true} if the first
operand is equal to second operand in value, and \terminal{false} otherwise.

\specsubsubitem
The result of the \terminal{!=} operator shall be \terminal{true} if the first
operand is not equal to second operand in value, and \terminal{false} otherwise.

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Logical arithmetic}

\begin{grammar}
\nonterminaldef{logical-and-expression} \\
	\nonterminal{equality-expression} \\
	\nonterminal{logical-and-expression} \terminal{\&\&} \nonterminal{equality-expression} \\

\nonterminaldef{logical-xor-expression} \\
	\nonterminal{logical-and-expression} \\
	\nonterminal{logical-xor-expression} \terminal{\textasciicircum\textasciicircum} \nonterminal{logical-and-expression} \\

\nonterminaldef{logical-or-expression} \\
	\nonterminal{logical-xor-expression} \\
	\nonterminal{logical-or-expression} \terminal{||} \nonterminal{logical-xor-expression} \\
\end{grammar}

\specsubsubitem
For all cases of logical arithmetic, both terms shall be of the \terminal{bool}
type, and the result type shall be \terminal{bool}.

\specsubsubitem
\terminal{\&\&} shall compute a logical and operation, and shall be
\terminal{true} if both terms are \terminal{true}, and false otherwise.

\specsubsubitem
\terminal{\textasciicircum\textasciicircum} shall be a logical exclusive or
operation, and shall be \terminal{true} if the terms are not equal to each
other, and \terminal{false} otherwise.

\specsubsubitem
\terminal{||} shall be a logical or operation, and shall be \terminal{true} if
either term is \terminal{true}, and \terminal{false} otherwise.

\specsubsubitem
If the first term of \nonterminal{logical-and-expression} is \terminal{false},
or the first term of \nonterminal{logical-or-expression} is \terminal{true},
the implementation shall ensure that the side-effects of the second term do not
occur.

\specsubsection{If expressions}

\begin{grammar}
\nonterminaldef{if-expression} \\
	\terminal{if} \nonterminal{conditional-branch} \\
	\terminal{if} \nonterminal{conditional-branch} \terminal{else} \nonterminal{if-expression} \\
	\terminal{if} \nonterminal{conditional-branch} \terminal{else} \nonterminal{compound-expression} \\

\nonterminaldef{conditional-branch} \\
	\terminal{(} \nonterminal{simple-expression} \terminal{)} \nonterminal{compound-expression} \\
\end{grammar}

\specsubsubitem
An \nonterminal{if-expression} chooses which, if any, expression to evaluate
based on a logical criteria. In all forms, the result type of
\nonterminal{simple-expression} shall be \terminal{bool}.

\specsubsubitem
When executing a \nonterminal{conditional-branch}, the implementation shall
evaluate the \\ \nonterminal{simple-expression} (the \textit{condition}), and
if \terminal{true}, the implementation shall execute the corresponding
\nonterminal{compound-expression} (the \textit{branch}), ensuring that all
side-effects occur. If the condition is \terminal{false}, the branch shall not
be executed and shall not cause side-effects.

\specsubsubitem
In the second form, the first \nonterminal{conditional-branch} shall be
executed. If it was \terminal{false}, the second-order
\nonterminal{if-expression} shall be executed; otherwise not. In the latter
case, any side-effects of the second condition or branch shall not occur.

\specsubsubitem
In the third form, the \nonterminal{conditional-branch} shall be executed. If
it was \terminal{false}, the \nonterminal{compound-expression} shall be
executed, and all of its side-effects shall occur.

\specsubsubitem
In the first form, the result type is \terminal{void}. In the second form, the
result type is \terminal{void} unless the third form is present in the
$N^{th}$-order sub-expression for any value of $N$. In this case, and in the
case of the third form used in the first order, if the result types of each
branch are uniform, the result type of the expression as a whole shall be of
that type. If the types are not uniform, the result type shall be a tagged
union of the set of possible result types. The result value shall be selected
from the result of the branch which is executed.

\specsubsubitem
If any of the branch expressions terminate, that branch is not considered for
the purpose of determining the result type. If all branches terminate, the
result type is \terminal{void} and the if statement itself is considered
terminal.

\specsubsection{For loops}

\begin{grammar}
\nonterminaldef{for-loop} \\
	\optional{\nonterminal{label}} \terminal{for} \terminal{(} \nonterminal{for-predicate} \terminal{)} \nonterminal{compound-expression} \\

\nonterminaldef{for-predicate} \\
	\nonterminal{simple-expression} \\
	\nonterminal{simple-expression} \terminal{;} \nonterminal{scope-expression} \\
	\nonterminal{binding} \terminal{;} \nonterminal{simple-expression} \terminal{;} \nonterminal{scope-expression} \\

\nonterminaldef{label}\exactly \\
	\terminal{:} \nonterminal{name} \\
\end{grammar}
% XXX: We may want to narrow the afterthought's expression class

\specsubsubitem
A \nonterminal{for-loop} executes its \nonterminal{compound-expression} zero or
more times, so long as a condition is true. Its result type is \terminal{void}.
If the \nonterminal{label} is present, the expression is \textit{labelled}, and
the label must be unique among all anscestors of the for loop which are
labelled.

\specsubsubitem
In the first form, \nonterminal{for-predicate} specifies the \textit{condition}
with its \nonterminal{simple-expression}. In the second form, the first
expression is the condition, and the second expression is the
\textit{afterthought}. In the third form, the \nonterminal{binding} is the
\textit{binding}, and the two expressions are respectively the condition and
afterthought. The result type of the condition shall be \terminal{bool}.

\specsubsubitem
The implementation shall establish a new scope for the
\nonterminal{compound-expression}, then, if present, it shall evaluate the
\nonterminal{binding} in this scope. The implementation shall then evaluate the
condition. If it is \terminal{true}, the \nonterminal{compound-expression}
shall be evaluated and all of its side-effects shall occur; this process is an
\textit{iteration}. When the iteration is complete, the implementation shall
evaluate the afterthought, if present, and then repeat the process, until the
condition evaluates to \terminal{false}.

\specsubsection{Switch expressions}

\begin{grammar}
\nonterminaldef{switch-expression} \\
	\terminal{switch} \terminal{(} \nonterminal{simple-expression} \terminal{)} \terminal{\{} \nonterminal{switch-cases} \terminal{\}} \\

\nonterminaldef{switch-cases} \\
	\nonterminal{switch-case} \optional{\terminal{,}} \\
	\nonterminal{switch-case} \terminal{,} \nonterminal{switch-cases} \\

\nonterminaldef{switch-case} \\
	\nonterminal{case-options} \terminal{=>} \nonterminal{compound-expression} \\
	\terminal{*} \terminal{=>} \nonterminal{compound-expression} \\

\nonterminaldef{case-options} \\
	\nonterminal{simple-expression} \optional{\terminal{,}} \\
	\nonterminal{simple-expression} \terminal{,} \nonterminal{case-options} \\
\end{grammar}

\specsubsubitem
A switch statement evaluates a value (\nonterminal{simple-expression}, the
\textit{switching expression}), then compares it with a number of
\nonterminal{switch-cases}, taking whichever branch matches the value.

\specsubsubitem
Each of the \nonterminal{case-options} specifies a value to compare with, given
by \nonterminal{simple-expression}. This expression shall be limited to the 
\secref{Translation compatible expression subset}, and its result type shall be
equivalent to the result type of the switching expression. The implementation
shall evaluate the \nonterminal{compound-expression} of the corresponding
\nonterminal{switch-case} if any of the \nonterminal{case-options} is equal to
the switching expression's result, setting the result of the overall switch
expression to the result of the selected \nonterminal{compound-expression}.

\specsubsubitem
The \terminal{*} form of \nonterminal{switch-case} indicates any case which is
not selected by the other cases. Only one case of this form shall appear in the
switch expression.

\specsubsubitem
The switch cases shall be \textit{exhaustive}, meaning that every possible
value of the switching expression is accounted for by a
\nonterminal{switch-case}. It shall also be preicsely exhaustive: no two cases
shall select for the same value.

\specsubsubitem
The implementation shall ensure that side-effects of the switch value
expression occur before those of the selected case, and that side-effects of
non-selected cases do not occur.

\specsubsubitem
If the result types of all non-terminating cases are equivalent, the result type
of the switch expression shall be the result type of the cases. Otherwise, the
result type shall be a tagged union of the set of the result types of the
non-terminating cases. If all cases terminate, the result type shall be
\terminal{void} and the switch expression shall terminate.

\specsubsection{Match expressions}

\begin{grammar}
\nonterminaldef{match-expression} \\
	\terminal{match} \terminal{(} \nonterminal{simple-expression} \terminal{)} \terminal{\{} \nonterminal{match-cases} \terminal{\}} \\

\nonterminaldef{match-cases} \\
	\nonterminal{match-case} \optional{\terminal{,}} \\
	\nonterminal{match-case} \terminal{,} \nonterminal{match-cases} \\

\nonterminaldef{match-case} \\
	\nonterminal{name} \terminal{:} \nonterminal{type} \terminal{=>} \nonterminal{compound-expression} \\
	\nonterminal{type} \terminal{=>} \nonterminal{compound-expression} \\
	\terminal{*} \terminal{=>} \nonterminal{compound-expression} \\
\end{grammar}

\specsubsubitem
A match statement evaluates a value (\nonterminal{simple-expression}, the
\textit{matching expression}), then selects and evaluates another expression
based on its result type. The result type of the matching expression must be a
tagged union or nullable pointer type, or an alias of either.

\specsubsubitem
If the matching expression has a tagged union type, each
\nonterminal{match-case} shall specify a type which is either a member of that
tagged union, or another tagged union which supports a subset of the matching
expression's type, or a type alias which refers to a qualifying type.

\specsubsubitem
If the matching expression has a nullable pointer type, one match case shall be
\terminal{null}, and another shall be the equivalent non-nullable pointer type,
or a type alias which refers to a qualifying type.

\specsubsubitem
The \terminal{*} form of \nonterminal{match-case} indicates any case which is
not selected by the other cases. Only one case of this form shall appear in the
match expression.

\specsubsubitem
The first form of \nonterminal{match-case}, if selected, shall cause the
implementation to cast the match expression to the selected type and assign the
resulting value to \nonterminal{name}. It shall insert this binding into a new
scope which applies to the \nonterminal{compound-expression}.

\specsubsubitem
The match cases shall be \textit{exhaustive}, meaning that every possible type
of the matching expression is accounted for by a \nonterminal{match-case}. It
shall also be preicsely exhaustive: no two cases shall select for the same
type.

\specsubsubitem
The implementation shall ensure that side-effects of the match value
expression occur before those of the selected case, and that side-effects of
non-selected cases do not occur.

\specsubsubitem
If the result types of all non-terminating cases are equivalent, the result type
of the match expression shall be the result type of the cases. Otherwise, the
result type shall be a tagged union of the set of the result types of the
non-terminating cases. If all cases terminate, the result type shall be
\terminal{void} and the match expression shall terminate.

\specsubsection{Assignment}

\begin{grammar}
\nonterminaldef{assignment} \\
	\nonterminal{object-selector} \nonterminal{assignment-op} \nonterminal{complex-expression} \\
	\terminal{*} \nonterminal{unary-expression} \nonterminal{assignment-op} \nonterminal{complex-expression} \\

\nonterminaldef{assignment-op} \oneof \\
	\terminal{=}
	\terminal{+=}
	\terminal{-=}
	\terminal{*=}
	\terminal{/=}
	\terminal{\%=}
	\terminal{\textless{}\textless{}=}
	\terminal{\textgreater{}\textgreater{}=}
	\terminal{\&=}
	\terminal{|=}
	\terminal{\textasciicircum=}
\end{grammar}

\specsubsubitem
An \nonterminal{assignment} expression shall cause the object given by the
first term to be assigned a new value based on the value given by the second
term.

\specsubsubitem
If the \nonterminal{assignment-op} is \terminal{=}, the first term shall be
assigned the value given by the second term. Otherwise, the assignment
\code{\nonterminal{e1} \nonterminal{op}\terminal{=} \nonterminal{e1}} shall be
equivalent to the assignment
\code{\nonterminal{e1} \terminal{=} \nonterminal{e1} \nonterminal{op} \nonterminal{e2}},
but the side effects of \nonterminal{e1} shall only occur once.

\specsubsubitem
In the first form, the \nonterminal{object-selector} selects the object to be
modified. The type of this object shall not be of a \terminal{const} type.

\specsubsubitem
In the second form, the \nonterminal{unary-expression} shall have a result type
of a non-nullable, non-const pointer type, and the object which is assigned
shall be the secondary object to which the pointer object refers. The second
term shall be assignable to the pointer's secondary type.

\specsubsubitem
The second term shall be \textit{assignable} to the object. Assignability rules
are stricter than castability rules. All types are assignable to themselves. The
set of other types which are assignable to a given type are given by the
following table:

\begin{tabular}{r | l}
Object type & May be assigned from \\
\hline
Mutable type & Constant types assignable to the object type \\
Signed integer types & Signed integer types of equal or higher precision \\
Unsigned integer types & Unsigned integer types of equal or higher precision \\
Floating-point types & Any floating-point type of equal or higher precision \\
Nullable pointer types & Non-nullable pointer type of the same secondary type \\
Nullable pointer types & \terminal{null} \\
Slice types & Array type of the same secondary type and definite length \\
Array types of undefined size & Array types of defined size \\
Tagged union types & See notes \\
Type aliases & Any type assignable to the secondary type \\
\terminal{void} & Any type \\
\terminal{*} \terminal{void} & Any non-nullable pointer type \\
\terminal{nullable} \terminal{*} \terminal{void} & Any pointer type \\
\terminal{*} \terminal{const} \terminal{char} & \terminal{str} \\
\end{tabular}

The implementation shall perform any necessary conversion from the source type
to the destination type.

\specsubsubitem
Pointers to array types are mutually assignable if their secondary types are
mutually assignable.

\specsubsubitem
Tagged union types may be assigned from any of their constituent types. Tagged
unions may also be assigned from any type which is assignable to exactly one of
its constituent types. Additionally, tagged unions may be assigned from any
other tagged union type, provided that the set of constituent types of the
destination type is a superset of the set of constituent types of the source
type.

\specsubsubitem
\terminal{const} types have the same assignability rules as the equivalent
non-const type.

\informative{In the context of an assignment expression,
\subsubitemref{Assignment}{2} prevents the modification of objects with a const
type. However, the \textit{assignability} rules are referred to in many other
contexts throughout the specification, and in these contexts, unless otherwise
specified, non-const types are assignable to const types. For example, a
\nonterminal{binding} which specifies a const \nonterminal{type} may use a
non-const type for its \nonterminal{complex-expression}.}

\specsubsubitem
For assignment of \terminal{*} \terminal{const} \terminal{char} from
\terminal{str} types, see the notes on \subsecref{Casts and type assertions}.

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.


\specsubsection{Variable binding}

\begin{grammar}
\nonterminaldef{binding-list} \\
	\optional{\terminal{static}} \terminal{let} \nonterminal{bindings} \\
	\terminal{const} \nonterminal{bindings} \\

\nonterminaldef{bindings} \\
	\nonterminal{binding} \optional{\terminal{,}} \\
	\nonterminal{binding} \terminal{,} \nonterminal{bindings} \\

\nonterminaldef{binding} \\
	\nonterminal{name} \terminal{=} \nonterminal{simple-expression} \\
	\nonterminal{name} \terminal{:} \nonterminal{type} \terminal{=} \nonterminal{complex-expression} \\
\end{grammar}

\specsubsubitem
A \nonterminal{binding-list} shall cause one or more objects to become
available in the present scope. Each object shall be identified by its
\nonterminal{name}, and shall have its initial value set to the result of the
\nonterminal{simple-expression} or \nonterminal{complex-expression}. The result
type of a binding list expression is \terminal{void}.

\specsubsubitem
In the first form of \nonterminal{binding-list}, the type of the object shall
be equivalent to the result type of the \nonterminal{simple-expression}. In the
second form, the type shall be as indicated, and the result type of the
\nonterminal{complex-expression} shall be assignable to this type.

\specsubsubitem
If the \terminal{const} form is used, the type of each binding shall be
modified to \textit{include} the \terminal{const} flag. If the \terminal{let}
form is used, the type of each binding which uses the first form of
\nonterminal{binding} shall be modified to \textit{omit} the \terminal{const}
flag.

\specsubsubitem
If the \terminal{static} form is used, the variables shall be allocated
\textit{statically}, such that they are only initialized once and their
previous value, accounting for any later mutations, is preserved each time
the binding expression is encountered, including across repeated or recursive
calls to the enclosing function. In this case, the initializer must use the
\secref{Translation compatible expression subset}.

\specsubsubitem
The type of the binding shall not use a type which has a zero or undefined size.

\specsubsection{Deferred expressions}

\begin{grammar}
\nonterminaldef{deferred-expression} \\
	\terminal{defer} \nonterminal{scope-expression} \\
\end{grammar}

\specsubsubitem
A \nonterminal{deferred-expression} causes another expression to be
\textit{deferred} until the termination of the current scope. The result type
is \terminal{void}.

\specsubsubitem
The implementation shall cause the \nonterminal{scope-expression} to be
evaluated upon the termination of the current scope, either due to normal
program flow, or due to encountering a terminating expression.

\specsubsubitem
If several expressions are deferred in a single scope, their side-effects shall
occur in the same order that they appear in the program source.

\specsubsubitem
If the current scope is terminated before a \nonterminal{deferred-expression}
(\informative{but not an expression which was already deferred}) would be
evaluated, the side-effects of the \nonterminal{scope-expression} shall not
occur.

\specsubsubitem
A \nonterminal{deferred-expression} shall not appear as a descendant of the
expression tree formed by \nonterminal{scope-expression}.

\specsubsection{Expression lists}

\begin{grammar}
\nonterminaldef{expression-list} \\
	\nonterminal{scope-expression} \terminal{;} \\
	\nonterminal{scope-expression} \terminal{;} \nonterminal{expression-list} \\
\end{grammar}

\specsubsubitem
A \nonterminal{expression-list} evaluates any number of
\nonterminal{scope-expression}s in sequence. The result of the
\nonterminal{expression-list} shall be the result of the final
\nonterminal{scope-expression}.

\specsubsubitem
The expressions shall be evaluated such that the side-effects of each all occur
in the order that each expression appears.

\specsubsubitem
If any of the \nonterminal{scope-expression}s terminate, the
\nonterminal{expression-list} is considered to terminate.

\specsubsubitem
The \nonterminal{expression-list} shall establish a new scope whose parent is
the scope in which the \nonterminal{expression-list} resides.

\specsubsection{Control statements}

\begin{grammar}
\nonterminaldef{control-statement} \\
	\terminal{break} \optional{\nonterminal{label}} \\
	\terminal{continue} \optional{\nonterminal{label}} \\
	\terminal{return} \optional{\nonterminal{complex-expression}} \\
\end{grammar}

\specsubsubitem
\nonterminal{control-statement} causes an \nonterminal{expression-list} to
terminate in a specific way. A control statement is a terminating expression
and its result type is \terminal{void}.

\specsubsubitem
The first and second forms shall be valid only if used within a
\nonterminal{for-loop}. The first form shall cause the loop to abort without
evaluating the \textit{condition} or the \textit{afterthought}. The second form
shall cause the loop to repeat immediately, running the \textit{afterthought},
re-testing the \textit{condition}, and repeating the loop if \terminal{true}.

\specsubsubitem
If the \nonterminal{label} is provided for either the first or second forms, it
shall be used to specify which \nonterminal{for-loop} the statement shall
influence, and shall match a labelled for loop which is an ancestor of the
statement. If the label is not specified, the control statement shall refer to
the most immediate anscestor of the control statement which is a
\nonterminal{for-loop}. If no qualifying loop can be identified, a diagnostic
message shall be shown and the translation phase shall abort.

\specsubsubitem
The third form shall terminate the function the expression is a descendant of.
If the function's result type is not \terminal{void}, the
\nonterminal{complex-expression} shall be provided, and shall be assignable to
the function's result type. It shall provide the result for the function. If
the function's result type is void, the \nonterminal{complex-expression} shall
not be present.

\specsubsubitem
In any of these cases, the implementation shall ensure that side-effects do not
occur for any expressions which are lexically situated \textit{after} the
\nonterminal{control-statement} within the scope of the loop or function they
influence.

\specsubsection{High-level expression classes}

\begin{grammar}
\nonterminaldef{simple-expression} \\
	\nonterminal{logical-or-expression} \\

\nonterminaldef{complex-expression} \\
	\nonterminal{simple-expression} \\
	\nonterminal{if-expression} \\
	\nonterminal{for-loop} \\
	\nonterminal{switch-expression} \\
	\nonterminal{match-expression} \\

\nonterminaldef{scope-expression} \\
	\nonterminal{assignment} \\
	\nonterminal{binding-list} \\
	\nonterminal{deferred-expression} \\
	\nonterminal{complex-expression} \\
	\nonterminal{compound-expression} \\

\nonterminaldef{compound-expression} \\
	\nonterminal{simple-expression} \\
	\terminal{\{} \nonterminal{expression-list} \terminal{\}} \\
	\terminal{\{} \nonterminal{control-statement} \terminal{;} \terminal{\}} \\
	\terminal{\{} \nonterminal{expression-list} \terminal{;} \nonterminal{control-statement} \terminal{;} \terminal{\}} \\
\end{grammar}

\specsubsubitem
\nonterminal{simple-expression}, \nonterminal{complex-expression},
\nonterminal{scope-expression}, and \nonterminal{compound-expression} are
high-level expression classes which are used to classify the kinds of
expressions which are available in specific situations.

\informative{
\nonterminal{simple-expression} and \nonterminal{complex-expression} are
available in most circumstances. A simple expression can encapsulate a
complex-expression via \nonterminal{nested-expression} should the programmer
consider themselves wiser than the language designer, but generally speaking a
simple-expression will not branch or alter control flow.
}

\informative{
\nonterminal{scope-expression} is available in context where new objects may
be defined (\nonterminal{binding}, \nonterminal{allocation-expression}) and
mutated (\nonterminal{assignment}).
}

\informative{
\nonterminal{compound-expression} is used for lists of expressions evaluated in
sequence, and expands the classification to include
\nonterminal{control-statements}, which are used to influence the flow of
expression evaluation within the sequence.
}

\specsection{Type promotion}

\specsubitem
The operands of some arithmetic expressions are subject to \textit{type
promotion}, to allow for arithmetic between disjoint types. The operand of
lower precision may be \textit{promoted}, or implicitly cast, to the precision
of the more precise operand. Unless explicitly covered by the following cases,
operands shall not be promoted, and the translation environment shall print a
diagnostic message and abort for incompatible combinations of operand types.

\specsubitem
For expressions where the result type is determined by type promotion, the
result type shall be equivalent to the type of the operand which has the
highest precision.

\specsubitem
For expressions involving two integer types, the type of lower precision may be
promoted to the type of higher precision only if the signedness is the same for
each operand. A type cannot be promoted to \terminal{uintptr}.

\specsubitem
For expressions involving floating-point types, \terminal{f32} may be promoted
to \terminal{f64}.

\specsection{Translation compatible expression subset}

The translation-compatible expression subset is a subset of expression types
which the implementation must be able to evaluate during the translation phase.

\specsubitem
The following expression types are included:

\begin{minipage}[t][7cm][b]{\textwidth}
\begin{multicols}{2}
\begin{itemize}
\item \nonterminal{logical-or-expression}
\item \nonterminal{logical-xor-expression}
\item \nonterminal{logical-and-expression}
\item \nonterminal{equality-expression}
\item \nonterminal{comparison-expression}
\item \nonterminal{inclusive-or-expression}
\item \nonterminal{exclusive-or-expression}
\item \nonterminal{and-expression}
\item \nonterminal{shift-expression}
\item \nonterminal{additive-expression}
\item \nonterminal{multiplicative-expression}
\item \nonterminal{cast-expression}
\item \nonterminal{unary-expression}
\item \nonterminal{field-access-expression}
\item \nonterminal{indexing-expression}
\item \nonterminal{measurement-expression}
\item \nonterminal{nested-expression}
\item \nonterminal{plain-expression}
\end{itemize}
\end{multicols}
\end{minipage}

\vspace{0.25cm}
\specsubitem
All terminals which are descendants of any of the listed terminals are
included, and all non-terminals and terminals which are descendants of
\nonterminal{plain-expression} are included.

\specsubitem
The pointer dereference \nonterminal{unary-expression} (the \terminal{*}
operator) shall be excluded from the translation-compatible expression subset.
Additionally, the implicit pointer type dereference semantics of
\nonterminal{field-access-expression} and \nonterminal{indexing-expression} are
not available.

\specsubitem
The implementation is not required to use a conformant implementation of the
storage semantics of types in the translation environment, provided that there
are not observable side-effects in the execution environment as a result of any
differences.

\specsubitem
In a context where an expression is constrained to this subset, the use of an
expression type outside of this set shall cause the translation environment to
print a diagnostic message and abort.
