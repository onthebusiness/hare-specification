\specsection{Expressions}

\specsubitem
An expression is a procedure which the implementation may perform to obtain a
\textit{result}, and possibly cause side-effects (see
\subsubitemref{Program execution}{1}).

\specsubitem
Expression types are organized into a number of classes and subclasses of
expressions which define the contexts in which each expression type is
applicable.

\specsubitem
All expressions have a defined \textit{result type}. It may be \terminal{void}.

\specsubitem
Some expressions \textit{terminate}. The semantics of terminating expressions
vary between different expression types, and will be detailed as appropriate.
If unspecified, expressions described by this expression are presumed to be
non-terminating. Expression classes inherit their termination qualities from the
more specific sub-expressions which they classify.

\specsubitem
Some expressions may provide a \textit{type hint} to other expressions which
appear in their grammar, which those expressions may take advantage of to
refine their behavior.

\specsubsection{Constants}

\begin{grammar}
\nonterminaldef{constant} \\
	\nonterminal{integer-constant} \\
	\nonterminal{floating-constant} \\
	\nonterminal{rune-constant} \\
	\nonterminal{string-constant} \\
	\terminal{true} \\
	\terminal{false} \\
	\terminal{null} \\
	\terminal{void} \\
\end{grammar}

\specsubsubitem
Constants (also known as literals) shall describe a specific value of an
unambiguous type. The result of the expression is the constant value.

\specsubsubitem
The keywords \terminal{true} and \terminal{false} respectively represent
the constants of the \terminal{bool} type.

\specsubsubitem
The representation of \terminal{true} as an \terminal{uint}-equivalent (ref
\subsubitemref{Other primitive types}{2}) shall be one.

\specsubsubitem
The \terminal{null} keyword represents the \terminal{null} value of the
\terminal{null} type.

\specsubsubitem
The \terminal{void} keyword represents the \terminal{void} value of the
\terminal{void} type.

\specsubsection{Floating constants}

\begin{grammar}
\nonterminaldef{floating-constant} \exactly \\
	\nonterminal{decimal-digits} \terminal{.} \nonterminal{decimal-digits} \optional{\nonterminal{exponent}} \optional{\nonterminal{floating-suffix}} \\
	\nonterminal{decimal-digits} \optional{\nonterminal{exponent}} \nonterminal{floating-suffix} \\

\nonterminaldef{floating-suffix} \oneof \\
	\terminal{f32}
	\terminal{f64} \\

\nonterminaldef{decimal-digits} \exactly \\
	\nonterminal{decimal-digit} \optional{\nonterminal{decimal-digits}} \\

\nonterminaldef{decimal-digit} \oneof \\
	\terminal{0}
	\terminal{1}
	\terminal{2}
	\terminal{3}
	\terminal{4}
	\terminal{5}
	\terminal{6}
	\terminal{7}
	\terminal{8}
	\terminal{9} \\

\nonterminaldef{exponent} \exactly \\
	\nonterminal{exponent-char} \optional{\nonterminal{sign}} \nonterminal{decimal-digits} \\

\nonterminaldef{sign} \oneof \\
        \terminal{+}
        \terminal{-} \\

\nonterminaldef{exponent-char} \oneof \\
        \terminal{e}
        \terminal{E} \\
\end{grammar}

Floating constants represent an IEEE 754-compatible floating-point
number in either the binary32 or binary64 format.

\specsubitem
If the \nonterminal{floating-suffix} is not provided and a type hint is
provided, the type shall be the type hint. If the \nonterminal{floating-suffix}
is not provided and a type hint is not provided, the type shall be
\terminal{f64}. Otherwise, the type shall refer to the type named by the suffix.

\specsubitem
If the \nonterminal{exponent} is provided, the value of the
constant shall be multiplied by 10 to the power of
\nonterminal{decimal-digits}.

\specsubsection{Integer constants}

\begin{grammar}
\nonterminaldef{integer-constant} \exactly \\
	\terminal{0x} \nonterminal{hex-digits} \optional{\nonterminal{integer-suffix}} \\
	\terminal{0o} \nonterminal{octal-digits} \optional{\nonterminal{integer-suffix}} \\
	\terminal{0b} \nonterminal{binary-digits} \optional{\nonterminal{integer-suffix}} \\
	\nonterminal{decimal-digits} \optional{\nonterminal{exponent}}
		\optional{\nonterminal{integer-suffix}} \\

\nonterminaldef{hex-digits} \exactly \\
	\nonterminal{hex-digit} \optional{\nonterminal{hex-digits}} \\

\nonterminaldef{hex-digit} \oneof \\
	\terminal{0}
	\terminal{1}
	\terminal{2}
	\terminal{3}
	\terminal{4}
	\terminal{5}
	\terminal{6}
	\terminal{7}
	\terminal{8}
	\terminal{9}
	\terminal{A}
	\terminal{B}
	\terminal{C}
	\terminal{D}
	\terminal{E}
	\terminal{F}
	\terminal{a}
	\terminal{b}
	\terminal{c}
	\terminal{d}
	\terminal{e}
	\terminal{f} \\

\nonterminaldef{octal-digits} \exactly \\
	\nonterminal{octal-digit} \optional{\nonterminal{octal-digits}} \\

\nonterminaldef{octal-digit} \oneof \\
	\terminal{0}
	\terminal{1}
	\terminal{2}
	\terminal{3}
	\terminal{4}
	\terminal{5}
	\terminal{6}
	\terminal{7} \\

\nonterminaldef{binary-digits} \exactly \\
	\nonterminal{binary-digit} \optional{\nonterminal{binary-digits}} \\

\nonterminaldef{binary-digit} \oneof \\
	\terminal{0}
	\terminal{1} \\

\nonterminaldef{integer-suffix} \oneof \\
	\terminal{i}
	\terminal{u}
	\terminal{z}
	\terminal{i8}
	\terminal{i16}
	\terminal{i32}
	\terminal{i64}
	\terminal{u8}
	\terminal{u16}
	\terminal{u32}
	\terminal{u64} \\
\end{grammar}

Integer constants represent an integer value at a specific precision.

\specsubitem
If the \nonterminal{integer-suffix} is not provided and a type hint is provided,
the type shall be the type hint. If the \nonterminal{integer-suffix} is not
provided and a type hint is not provided, the type shall be \terminal{int}. If
the \nonterminal{integer-suffix} is provided, the type is specified by the
suffix. Suffixes \terminal{i}, \terminal{u},  and \terminal{z} shall
respectively refer to the \terminal{int}, \terminal{uint}, and \terminal{size}
types; the remainder shall refer to the type named by the suffix.

\specsubitem
If the number provided is not within the limits of the precision of the
constant type, a diagnostic message shall be printed and the translation phase
shall fail.

\specsubitem
The prefixes \terminal{0x}, \terminal{0o}, and \terminal{0b} shall respectively
cause the number to be interpreted with a hexadecimal, octal, or binary base.
If no prefix is used, the number shall be interpreted with a decimal base.

\specsubitem
If the \nonterminal{exponent} is provided, the value of the
integer shall be multiplied by 10 to the power of \nonterminal{decimal-digits}.

\specsubsection{Rune constants}
\begin{grammar}
\nonterminaldef{rune-constant} \\
	\terminal{'} \nonterminal{rune} \terminal{'} \\

\nonterminaldef{rune} \\
	\norm{Any character other than \terminal{\textbackslash} or \terminal{'}} \\
	\nonterminal{escape-sequence} \\

\nonterminaldef{escape-sequence} \exactly \\
	\nonterminal{named-escape} \\
	\terminal{\textbackslash{}x} \nonterminal{hex-digit} \nonterminal{hex-digit} \\
	\terminal{\textbackslash{}u} \nonterminal{fourbyte} \\
	\terminal{\textbackslash{}U} \nonterminal{eightbyte} \\


\nonterminaldef{fourbyte} \exactly \\
	\nonterminal{hex-digit} \nonterminal{hex-digit} \nonterminal{hex-digit} \nonterminal{hex-digit} \\

\nonterminaldef{eightbyte} \exactly \\
	\nonterminal{fourbyte} \nonterminal{fourbyte} \\

\nonterminaldef{named-escape} \oneof \\
	\terminal{\textbackslash0}
	\terminal{\textbackslash{}a}
	\terminal{\textbackslash{}b}
	\terminal{\textbackslash{}f}
	\terminal{\textbackslash{}n}
	\terminal{\textbackslash{}r}
	\terminal{\textbackslash{}t}
	\terminal{\textbackslash{}v}
	\terminal{\textbackslash\textbackslash}
	\terminal{\textbackslash'}
	\terminal{\textbackslash"} \\
\end{grammar}

\specsubsubitem
If a type hint is provided, the type shall be the type hint. Otherwise, the type
shall be \terminal{rune}.

\specsubsubitem
If the \nonterminal{rune-constant} is not an \nonterminal{escape-sequence}, the
value of the rune shall be the Unicode codepoint representing
\nonterminal{rune}.

\specsubsubitem
A \nonterminal{rune-constant} beginning with \terminal{\textbackslash{}x},
\terminal{\textbackslash{}u}, or \terminal{\textbackslash{}U} shall interpet
its value as a Unicode codepoint specified in its hexadecimal representation by
\nonterminal{hex-digit}s.

\specsubsubitem
A \nonterminal{rune-constant} containing a \nonterminal{named-escape} shall have
a value based on the following chart:

\begin{tabular}{r | l | r | l}
Escape sequence & Unicode codepoint & Escape sequence & Unicode codepoint \\
\hline
\terminal{\textbackslash0} & \code{U+0000} &
\terminal{\textbackslash{}a} & \code{U+0007} \\
\terminal{\textbackslash{}b} & \code{U+0008} &
\terminal{\textbackslash{}f} & \code{U+000C} \\
\terminal{\textbackslash{}n} & \code{U+000A} &
\terminal{\textbackslash{}r} & \code{U+000D} \\
\terminal{\textbackslash{}t} & \code{U+0009} &
\terminal{\textbackslash{}v} & \code{U+000B} \\
\terminal{\textbackslash\textbackslash} & \code{U+005C} &
\terminal{\textbackslash'} & \code{U+002C} \\
\terminal{\textbackslash"} & \code{U+0022} \\
\end{tabular}

\specsubsection{String constants}

\begin{grammar}
\nonterminaldef{string-constant} \\
	\terminal{"} \nonterminal{string-chars} \terminal{"} \\
	\nonterminal{string-constant} \nonterminal{string-constant} \\

\nonterminaldef{string-chars} \\
	\nonterminal{string-char} \optional{\nonterminal{string-chars}} \\

\nonterminaldef{string-char} \\
	\norm{Any character other than \terminal{\textbackslash} or \terminal{"}} \\
	\nonterminal{escape-sequence} \\
\end{grammar}

\specsubsubitem
A \nonterminal{string-constant} expression shall have a result type of
\terminal{const} \terminal{str}.

\specsubsubitem
If the first form of \nonterminal{string-constant} is used, the string's
\textit{data} field shall refer to a UTF-8 encoded sequence of Unicode
codepoints, ascertained by encoding the sequence of \nonterminal{string-char}s
given in order, after interpreting escape codes per
\subsubitemref{Rune constants}{17}.

\specsubsubitem
If the second form of \nonterminal{string-constant} is used, the string's
\textit{data} field shall refer to a UTF-8 encoded sequence of Unicode
codepoints, ascertained by concatenating the \textit{data} field of the first
\nonterminal{string-constant} and the \textit{data} field of the second
\nonterminal{string-constant}.

\specsubsubitem
The \textit{length} and \textit{capacity} fields shall be set to the length in
octets of the encoded UTF-8 data.

\specsubsection{Array literals}

\begin{grammar}
\nonterminaldef{array-literal} \\
	\terminal{[} \optional{\nonterminal{array-members}} \terminal{]} \\

\nonterminaldef{array-members} \\
	\nonterminal{expression} \optional{\terminal{,}} \\
	\nonterminal{expression} \terminal{...} \optional{\terminal{,}} \\
	\nonterminal{expression} \terminal{,} \nonterminal{array-members} \\
\end{grammar}

Forward references: \subsecref{Simple, complex, and compound expressions}

\specsubsubitem
An \nonterminal{array-literal} expression produces a value of an array type.
The type of each \nonterminal{expression} shall be uniform and shall
determine the member type of the array value, and the length of the array type
shall be defined by the number of members.

\specsubsubitem
If a type hint has been provided to an array literal which is an array type (or
a type alias which represents an array type), the member type will be inferred
from this array type. The initializer expressions for each value among
\nonterminal{array-members} shall receive this member type as a type hint. If
the \nonterminal{array-members} is not specified, a type hint must be provided.

\specsubsubitem
The execution environment shall evaluate the \nonterminal{array-members},
ordered such that any side-effects of evaluating the arguments occur in the
order that the members are listed, such that the \textit{N}th member provides
the value for the \textit{N}th array member.

\specsubsubitem
If the \terminal{...} form is used, the result's array type shall be expandable.
If a type hint is available, it shall not be of a context-defined array type.

\specsubsection{Enum literals}

\begin{grammar}
\nonterminaldef{enum-literal} \exactly \\
	\nonterminal{identifier} \terminal{::} \nonterminal{name} \\
\end{grammar}

\specsubsubitem
An \nonterminal{enum-literal} expression produces a value of an enum type. The
\nonterminal{identifier} shall be a type alias (see \subsecref{Type aliases})
which refers to an enum type. The result type shall be the type alias to which
the \nonterminal{identifier} refers.

\specsubsubitem
The enum type to which the type alias refers shall have an
\nonterminal{enum-value} whose name is the \nonterminal{enum-literal}'s
\nonterminal{name}. The result of the \nonterminal{enum-literal}
shall be the value assigned to this \nonterminal{enum-value}. If there is no
such \nonterminal{enum-value}, a diagnostic message shall be printed and the
translation phase shall abort. 

\specsubsection{Struct literals}

\begin{grammar}
\nonterminaldef{struct-literal} \\
	\terminal{struct} \terminal{\{} \nonterminal{field-values} \optional{\terminal{,}} \terminal{\}} \\
	\nonterminal{identifier} \terminal{\{} \nonterminal{struct-initializer} \optional{\terminal{,}} \terminal{\}} \\

\nonterminaldef{struct-initializer} \\
	\nonterminal{field-values} \\
	\nonterminal{field-values} \terminal{,} \terminal{...} \\
	\terminal{...} \\

\nonterminaldef{field-values} \\
	\nonterminal{field-value} \\
	\nonterminal{field-values} \terminal{,} \nonterminal{field-value} \\

\nonterminaldef{field-value} \\
	\nonterminal{name} \terminal{=} \nonterminal{expression} \\
	\nonterminal{name} \terminal{:} \nonterminal{type} \terminal{=} \nonterminal{expression} \\
	\nonterminal{struct-literal} \\
\end{grammar}

\specsubsubitem
A \nonterminal{struct-literal} produces a value of a struct type. The first
form is the \textit{plain form}, and the second form is the \textit{named form}.

\specsubsubitem
If the plain form is given, the result type shall be a struct type defined by
the \nonterminal{field-value}s, in order, with their identifiers and types
explicitly specified. The first form of \nonterminal{field-value} shall not be
used in such a struct.

\specsubsubitem
If the named form is given, the \nonterminal{identifier} shall identify a type
alias (see \subsecref{Type aliases}) which refers to a struct or union type.
The result type shall be this alias type.

\specsubsubitem
Each \nonterminal{field-value} shall specify a field by its \nonterminal{name},
and assign that field in the result value to the result of the expression
given. The type of the named field, via the named type alias in the first form,
or the given type in the second form, shall be provided to the initializer
expression as a type hint. The \nonterminal{field-values} shall be evaluated in
the order in which they appear in the \nonterminal{struct-literal}.

\specsubsubitem
If \terminal{...} is not given, \nonterminal{field-values} shall be
\textit{exhaustive}, and include every field of the result type exactly once.
Otherwise, a diagnostic message shall be printed and the translation phase
shall abort.

\specsubsubitem
If \terminal{...} is given, any fields of the result type which are not
included in \nonterminal{field-values} shall be initialized to their default
values. Each included field shall only be named once. If a field is omitted
which does not have a default value, a diagnostic message shall be printed and
the translation phase shall abort.

\specsubsubitem
If the named type is a union type, the \nonterminal{field-values} shall be
empty and \terminal{...} provided. The union type must have a default value.

\specsubsubitem
If the \nonterminal{struct-literal} form of the \nonterminal{field-value} is
given, its fields shall be interpreted as fields of the parent struct.

\informative{The following values are equivalent: \\
\code{struct \{ a: int = 10, b: int = 20 \}} \\
\code{struct \{ a: int = 10, struct \{ b: int = 20 \} \}}}

\specsubsection{Plain expressions}

\begin{grammar}
\nonterminaldef{plain-expression} \\
	\nonterminal{identifier} \\
	\nonterminal{constant} \\
	\nonterminal{array-literal} \\
	\nonterminal{enum-literal} \\
	\nonterminal{struct-literal} \\

\nonterminaldef{nested-expression} \\
	\nonterminal{plain-expression} \\
	\terminal{(} \nonterminal{expression} \terminal{)} \\
	\terminal{(} \nonterminal{tuple-items} \terminal{)} \\

\nonterminaldef{tuple-items} \\
	\nonterminal{expression} \terminal{,} \nonterminal{expression} \optional{\terminal{,}} \\
	\nonterminal{expression} \terminal{,} \nonterminal{tuple-items} \\
\end{grammar}

Forward references: \subsecref{Simple, complex, and compound expressions}

\specsubsubitem
\nonterminal{plain-expression} is an expression class which represents its
result value "plainly". In the case of constants and literals, the value is
represented by the result of those expressions. In the case of an
\nonterminal{identifier}, the expression produces the value of the identified
object.

\specsubsubitem
\nonterminal{nested-expression} is an expression class provided to allow the
programmer to overcome undesirable associativity between operators.

\specsubsubitem
The \nonterminal{tuple-items} form of \nonterminal{nested-expression} shall
describe a \textit{tuple expression}, and have a result type which is the tuple
described by the types of its \nonterminal{expression}s in the order that they
appear. If a type hint is available, the tuple items may be assigned to the
types of the respective tuple sub-types in the order that they appear. The
implementation shall cause the side-effects of each \nonterminal{expression} to
occur in the order that they appear.

\specsubsection{Allocations}

\begin{grammar}
\nonterminaldef{allocation-expression} \\
	\terminal{alloc} \terminal{(} \nonterminal{expression} \terminal{)} \\
	\terminal{alloc} \terminal{(} \nonterminal{expression} \terminal{...} \terminal{)} \\
	\terminal{alloc} \terminal{(} \nonterminal{expression} \terminal{,} \nonterminal{expression} \terminal{)} \\
	\terminal{free} \terminal{(} \nonterminal{expression} \terminal{)} \\
\end{grammar}

\specsubsubitem
An \terminal{alloc} expression allocates an object at runtime and initializes
its value to the first \nonterminal{expression} (the \textit{initializer}). The
result type of the \textit{initializer} provides the allocation's
\textit{object type}. The result type of the allocation expression is, usually,
a pointer type whose secondary type is the object type.

\specsubsubitem
The first form is the object allocation form. If the allocation expression is
provided a type hint of a pointer type, the secondary type of this pointer type
shall be provided to the initializer as its type hint. The execution
environment will allocate sufficient storage for the object type and initialize
its value using the initializer expression, then set its result to a pointer to
the new object.

\specsubsubitem
The second form is the copy allocation form. In this form, the initializer will
provide an object type which is either a slice or array type (or an alias
thereof). The execution environment will allocate storage sufficient to store
an array equal in length to the initializer, then copy the initializer's slice
or array items into this array. The result value shall be set to a slice object
whose secondary type is equal to the secondary type of the initializer's result
type, whose data field refers to the new array, and whose length and capacity
fields are set to the length of the array.

\specsubsubitem
The third form is the slice allocation form. In this form, the initializer will
be assignable to a slice or array type, and the second \nonterminal{expression}
provides the desired \textit{capacity} for a new slice. The capacity shall be
assignable to the \nonterminal{size} type. The execution environment shall
choose a capacity equal to or greater than this term, then provision an array
of that length and set each $N$th value to the $N$th value of the initializer,
for each value of $N$ between $0$ (inclusive) and the length of the initializer
(exclusive). The result of the \nonterminal{allocation-expression} shall be a
slice whose data field refers to this array, whose length is equal to the
length of the initializer, and whose capacity is set to the selected capacity.

\specsubsubitem
In the slice allocation form, if the array specified by the initializer is
\textit{expandable}, the second expression shall be used as the \textit{length}
instead of the capacity. The execution environment shall choose a capacity
equal to or greater than this value, then for each $N$th value of the allocated
array from the length of the initializer ($L$, inclusive) to the specified
\textit{length} ($L'$) shall be initialized to the value at $L-1$ in the
initializer. The length field of the resulting slice value shall be set to the
$L'$.

\informative{The following allocates a slice of length 10 with all values set to zero:}

\code{let x: []int = alloc([0...], 10)}

\specsubsubitem
In the \terminal{alloc} form, if the execution environment is unable to
allocate sufficient storage for the requested type, the execution environment
shall print a diagnostic message and abort. If the type hint is a nullable
pointer type, the result type of the allocation expression shall also be
nullable, and \terminal{null} shall be returned instead of aborting if
sufficient storage cannot be provided.

\specsubsubitem
The \terminal{free} form shall discard resources previously allocated with a
\terminal{alloc} expression, freeing them for future use. The
\nonterminal{expression} shall evaluate to a pointer type, in which case the
object referred to by the pointer shall be freed, or a slice type, in which
case the array referred to by its data field shall be freed.

\specsubsection{Assertions}

\begin{grammar}
\nonterminaldef{assertion-expression} \\
	\terminal{assert} \terminal{(} \nonterminal{expression} \terminal{)} \\
	\terminal{assert} \terminal{(} \nonterminal{expression} \terminal{,} \nonterminal{string-constant} \terminal{)} \\
	\terminal{static} \terminal{assert} \terminal{(} \nonterminal{expression} \terminal{)} \\
	\terminal{static} \terminal{assert} \terminal{(} \nonterminal{expression} \terminal{,} \nonterminal{string-constant} \terminal{)} \\
	\terminal{abort} \terminal{(} \optional{\nonterminal{string-constant}} \terminal{)} \\
	\terminal{static} \terminal{abort} \terminal{(} \optional{\nonterminal{string-constant}} \terminal{)} \\
\end{grammar}
% TODO: Specify the calling semantics for sys::assert and sys::abort
% Blocked until we start specifying the runtime library details

Forward references: \subsecref{Simple, complex, and compound expressions}

\specsubsubitem
An \nonterminal{assertion-expression} is used to validate an assumption by the
programmer by \textit{asserting} its truth. The result type of a
\nonterminal{assertion-expression} is \terminal{void}.

\specsubsubitem
\nonterminal{expression} shall be an expression of type \terminal{bool}, which
shall be provided to it as a type hint.

\specsubsubitem
In the first two forms, this expression shall be evaluated
in the execution environment, and if false, a diagnostic message shall be
printed and the execution phase aborted. The programmer may provide the
\nonterminal{string-constant} to be included in the diagnostic message.

\specsubsubitem
In the \terminal{static} form, \nonterminal{expression} shall be limited to the
\secref{Translation compatible expression subset}, shall be evaluated in the
translation environment, and is otherwise equivalent to the other forms.

\specsubsubitem
The \terminal{abort} form shall cause the execution environment to print a
diagnostic message and abort. The programmer may provide the
\nonterminal{string-constant} to be included in the diagnostic message. An
abort is a terminating expression.

\specsubsection{Calls}

\begin{grammar}
\nonterminaldef{call-expression} \\
	\nonterminal{postfix-expression} \terminal{(} \optional{\nonterminal{argument-list}} \terminal{)} \\

\nonterminaldef{argument-list} \\
	\nonterminal{expression} \optional{\terminal{,}} \\
	\nonterminal{expression} \terminal{...} \optional{\terminal{,}} \\
	\nonterminal{expression} \terminal{,} \nonterminal{argument-list} \\
\end{grammar}

Forward references: \subsecref{Simple, complex, and compound expressions}

\specsubsubitem
A \nonterminal{call-expression} shall invoke a function in the execution
environment and its result shall be a value of the type specified by the
\nonterminal{postfix-expression}'s function result type. This evaluation shall
include any necessary side-effects per \subsubitemref{Program execution}{1}.

\specsubsubitem
The result type of the \nonterminal{postfix-expression} shall be restricted to a
set which includes all function types which do not have the \terminal{@init},
\terminal{@fini}, or \terminal{@test} attributes set, as well as non-nullable
pointers whose secondary type is included in the set.

\informative{The result type of the \nonterminal{postfix-expression} can be a
function, a pointer to a function, a pointer to a pointer to a function, and so
on.}

\specsubsubitem
The function invoked shall be the function object the
\nonterminal{postfix-expression} refers to, selecting that object indirectly via
any number of pointer types if appropriate.

\specsubsubitem
The \nonterminal{argument-list} shall be a list of expressions whose types
shall be assignable to the types of the invoked function's parameters, in the
order that they are declared in the invoked function's result type. The types
specified in the function's prototype shall be provided as type hints to each
argument expression as appropriate.

\specsubsubitem
The execution environment shall evaluate the \nonterminal{argument-list},
ordered such that any side-effects of evaluating the arguments occur in the
order that the arguments are listed, to obtain the parameter values required to
invoke the function.

\specsubsubitem
If the invoked function uses Hare-style variadism, the
\nonterminal{argument-list} shall provide zero or more arguments following the
last non-variadic parameter, all of which must be assignable to the type of the
variadic parameter.

\specsubsubitem
If the final argument uses the \terminal{...} form, it must occupy the position of a
variadic parameter and be of a slice or array type. The implementation shall
interpret this value as the list of variadic parameters.

\specsubsubitem
If the invoked function uses C-style variadism, the function may provide zero
or more arguments following the final parameter. These arguments shall be of a
type with a non-zero size, but are otherwise unconstrained.

\specsubsubitem
The specific means by which the invoked function assumes control of the
execution environment, and by which the arguments are provided to it, is
implementation-defined.

\informative{This is generally provided by the target's ABI specification.}

\specsubsubitem
If the invoked function's result type has the \terminal{@noreturn} attribute,
the call expression is considered to terminate.

\specsubsection{Measurements}

\begin{grammar}
\nonterminaldef{measurement-expression} \\
	\nonterminal{size-expression} \\
	\nonterminal{length-expression} \\
	\nonterminal{offset-expression} \\

\nonterminaldef{size-expression} \\
	\terminal{size} \terminal{(} \nonterminal{type} \terminal{)} \\

\nonterminaldef{length-expression} \\
	\terminal{len} \terminal{(} \nonterminal{expression} \terminal{)} \\

\nonterminaldef{offset-expression} \\
	\terminal{offset} \terminal{(} \nonterminal{field-access-expression} \terminal{)} \\
\end{grammar}

Forward references: \subsecref{Field access}

\specsubsubitem
A \nonterminal{measurement-expression} is used to measure objects. The result
type shall be \terminal{size}.

\specsubsubitem
The \terminal{size} expression shall compute the \textit{size} of the specified
\nonterminal{type}.

\specsubsubitem
The \terminal{len} expression shall compute the \textit{length} of a bounded
array, or the \code{length} field of a slice object, referred to by
\nonterminal{expression}. If an unbounded array object is given, the translation
environment shall print a diagnostic message and abort.

\specsubsubitem
The object used for a length expression selected shall be the array or slice
object the \nonterminal{expression} refers to, selecting that object indirectly
via any number of pointer types if appropriate.

\specsubsubitem
The \terminal{offset} expression shall determine the struct or tuple field
which would be accessed by \nonterminal{field-access-expression} and compute
its \textit{offset}.

\specsubsection{Field access}

\begin{grammar}
\nonterminaldef{field-access-expression} \\
	\nonterminal{postfix-expression} \terminal{.} \nonterminal{name} \\
	\nonterminal{postfix-expression} \terminal{.} \nonterminal{integer-constant} \\
\end{grammar}

\specsubsubitem
A \nonterminal{field-access-expression} is used to access fields of
\subsecref{Struct and union types} and \subsecref{Tuple types}. The result type
of the \nonterminal{postfix-expression} shall be constrained to a set which
includes all struct, union, and tuple types, as well as non-nullable pointers
whose secondary type is included in the set.

\informative{The result type of the \nonterminal{postfix-expression} can be a
struct or union or tuple, a pointer to a struct or union or tuple, a pointer to
a pointer to a struct or union or tuple, and so on.}

\specsubsubitem
The object from which the field is selected shall be the struct or union object
the \nonterminal{postfix-expression} refers to, selecting that object indirectly
via any number of pointer types if appropriate.

\specsubsubitem
If the \nonterminal{postfix-expression}'s result type is a union type, the
first form shall be used. The result of the
\nonterminal{field-access-expression} shall be the union's storage area
interpreted as the type of the field named by \nonterminal{name}, and the
result type of the expression shall be the type of the named field.

\specsubsubitem
If the \nonterminal{postfix-expression}'s result type is a struct type, the
first form shall be used. The result of the
\nonterminal{field-access-expression} shall be the value stored in the
\nonterminal{name} field of the result of the \nonterminal{postfix-expression},
and the result type of the expression shall be the type of the named field.

\specsubsubitem
If the \nonterminal{postfix-expression}'s result type is a tuple type,
the second form shall be used. The result of the
\nonterminal{field-access-expression} shall be the $N$th value stored in the
tuple which is the result of the \nonterminal{postfix-expression}, and the
result type of the expression shall be the type of the $N$th value.

\specsubsubitem
If the type of the struct object in the first term has the \terminal{const}
flag, the result type shall also have the \terminal{const} flag set, regardless
of the flag's value on the type of the named field.

\specsubsection{Indexing}

\begin{grammar}
\nonterminaldef{indexing-expression} \\
	\nonterminal{postfix-expression} \terminal{[} \nonterminal{expression} \terminal{]} \\
\end{grammar}

\specsubsubitem
An \nonterminal{indexing-expression} shall access a specific value of a slice
or array type. The \nonterminal{expression} shall have an integer result type.
The result type of the \nonterminal{postfix-expression} shall be constrained to
a set which includes all slice and array types, as well as non-nullable pointers
whose secondary type is included in the set.

\informative{The result type of the \nonterminal{postfix-expression} can be a
slice or array, a pointer to a slice or array, a pointer to a pointer to a
slice or array, and so on.}

\specsubsubitem
The object from which the field is selected shall be the slice or array object
the \nonterminal{postfix-expression} refers to, selecting that object indirectly
via any number of pointer types if appropriate.

\specsubsubitem
The result type of an \nonterminal{indexing-expression} is the secondary type
of the slice or array type given by the \nonterminal{postfix-expression} result
type.

\specsubsubitem
If the type of the array or slice object in the first term has the
\terminal{const} flag, the result type shall also have the \terminal{const}
flag set, regardless of the flag's value on the secondary type.

\specsubsubitem
The execution environment shall compute the result of
\nonterminal{expression} to obtain $N$ for selecting the \textit{N} per the
algorithm given in \subsecref{Slice and array types}.

\specsubsubitem
The execution environment shall perform a \textit{bounds test} on the value of
$N$ to ensure it falls within the acceptable range for the given slice or array
type. It shall test that $N < Z$, where $Z$ is the length of the bounded array
type, or the \code{length} field of the slice, whichever is appropriate.  For
unbounded array types, the bounds test shall not occur. If the bounds test
fails, a diagnostic message shall be printed and the execution environment
shall abort.

The implementation may perform a bounds test in the translation environment if
is able, print a diagnostic message, and abort the translation environment if
it fails.

\specsubsection{Slicing}

\begin{grammar}
\nonterminaldef{slicing-expression} \\
	\nonterminal{postfix-expression} \terminal{[} \optional{\nonterminal{expression}} \terminal{..} \optional{\nonterminal{expression}} \terminal{]} \\
\end{grammar}

\specsubsubitem
A \nonterminal{slicing-expression} shall have a result type of
\nonterminal{slice}, which is computed a subset of a slice or array object.
The optional \nonterminal{expression}s shall have an integer result type. The
result type of the \nonterminal{postfix-expression} shall be constrained to
a set which includes all slice and array types, as well as non-nullable pointers
whose secondary type is included in the set.

\informative{The result type of the \nonterminal{postfix-expression} can be a
slice or array, a pointer to a slice or array, a pointer to a pointer to a
slice or array, and so on.}

\specsubsubitem
The object from which the field is selected shall be the slice or array object
the \nonterminal{postfix-expression} refers to, selecting that object indirectly
via any number of pointer types if appropriate.

\specsubsubitem
The first \nonterminal{expression} shall compute value $L$, and the second shall
compute $H$. If absent, $L = 0$ and $H = \code{length}$, where \code{length}
shall be equal to the length of a bounded array type or the length of a slice
type, represented in either case by the result of
\nonterminal{postfix-expression}. If $H$ is not specified, and
\nonterminal{postfix-expression} is of an unbounded array type, the translation
environment shall abort.

\specsubsubitem
The resulting slice value shall have its \code{data} field set from, in the case
of an array type, the address of the array; or in the case of a slice type, the
\code{data} value of the source object; plus $L \times S$, where $S$ is the
size of the slice or array's secondary type.

\specsubsubitem
The resulting slice value shall have its \code{length} field set to $H - L$,
and its capacity field set to the \code{length} of the source object minus $L$.
If the length of the object is undefined, the capacity shall be set to $H - L$
instead.

\specsubsubitem
The secondary type of the resulting slice type shall be equivalent to the
secondary type of the slice or array type given by
\nonterminal{postfix-expression}. The resulting slice type shall inherit the
\nonterminal{const} attribute from this type.

\specsubsection{Appending}

\begin{grammar}
\nonterminaldef{slice-mutation-expression} \\
	\nonterminal{append-expression} \\
	\nonterminal{insert-expression} \\
	\nonterminal{delete-expression} \\

\nonterminaldef{append-expression} \\
	\optional{\terminal{static}} \terminal{append} \terminal{(} \nonterminal{object-selector} \terminal{,} \nonterminal{expression} \terminal{)} \\
	\optional{\terminal{static}} \terminal{append} \terminal{(} \nonterminal{object-selector} \terminal{,} \nonterminal{expression} \terminal{...} \terminal{)} \\
	\optional{\terminal{static}} \terminal{append} \terminal{(} \nonterminal{object-selector} \terminal{,} \nonterminal{expression} \terminal{,} \nonterminal{expression} \terminal{)} \\
\end{grammar}

\specsubsubitem
An \nonterminal{append-expression} shall append a value, or values, to the
slice object specified by the first argument. Valid result types for
\nonterminal{object-selector} shall either be a slice type, or a pointer to a
valid result type. The selected object shall be mutable and non-const. The
member type of this slice shall be the expression's \textit{member type}. The
result of an \terminal{append} shall be \terminal{void}.

\specsubsubitem
The second term of an \terminal{append} expression is the \textit{append
values}. In the first form, the append values shall specify a single value
whose type is assignable to the member type. In the second form, the expression
shall have a valid result type which shall be an array or slice whose member
type is the append expression's member type, or a pointer to a valid result
type.

\specsubsubitem
The execution environment shall ensure that the capacity of the object is at
least $N \geq L^1 + L^2$, where $L^1$ is the object length and $L^2$ is the
length of the append values, reallocating the underlying storage if necessary.
If sufficient storage cannot be allocated, the execution environment shall
print a diagnostic message and abort. The length of the object shall be set to
$L^1 + L^2$.

\specsubsubitem
The third form of an \nonterminal{append-expression} shall specify an
expandable array as its second term, and its third term shall be assignable to
\terminal{size}. This form shall behave similarly to the second form, except
that the new length and capacity of the object is given by the third term.

\specsubsubitem
The execution environment shall assign values of the object slice from index
$N = L^1$ (inclusive) to $N = L^1 + L^2$ (exclusive) from each append values at
index $N-L^1$. In the third form of \nonterminal{append-expression}, the last
value of append values shall be assigned for values $N = L^1 + L^2$ (inclusive)
up to the index given by the third term (exclusive).

\specsubsubitem
The \terminal{static} forms shall be equivalent to the non-static forms except
that they shall never cause the underlying slice to be reallocated. If the
operation would require more space than the capacity of the slice provides, the
execution environment shall print a diagnostic message and abort.

\specsubsubitem
The side-effects of the \nonterminal{object-selector} shall occur before the
side-effects of the append values, which shall occur before the side-effects of
the length term if present.

\specsubsection{Inserting}

\begin{grammar}
\nonterminaldef{insert-expression} \\
	\optional{\terminal{static}} \terminal{insert} \terminal{(} \nonterminal{indexing-expression} \terminal{,} \nonterminal{expression} \terminal{)} \\
	\optional{\terminal{static}} \terminal{insert} \terminal{(} \nonterminal{indexing-expression} \terminal{,} \nonterminal{expression} \terminal{...} \terminal{)} \\
\end{grammar}

% TODO: Do we want/need insert(x[5], [0...], 10)?

\specsubsubitem
An \nonterminal{insert-expression} shall insert a value, or values, into the
slice object specified by the first argument. The
\nonterminal{indexing-expression} specifies both the slice object and an index
at which the new values shall be inserted, or the \textit{insertion index}.
The selected object shall be mutable and non-const. The member type of this
slice shall be the expression's \textit{member type}. The result of an
\terminal{insert} shall be \terminal{void}.

\specsubsubitem
The second term of an \terminal{insert} expression is the \textit{insert
values}. In the first form, the insert values shall specify a single value
whose type is assignable to the member type. In the second form, the expression
shall have a valid result type which shall be an array or slice whose member
type is the append expression's member type, or a pointer to a valid result
type.

\specsubsubitem
The execution environment shall ensure that the capacity of the object is at
least $N \geq L^1 + L^2$, where $L^1$ is the object length and $L^2$ is the
length of the insert values, reallocating the underlying storage if necessary.
If sufficient storage cannot be allocated, the execution environment shall
print a diagnostic message and abort. The length of the object shall be set to
$L^1 + L^2$.

\specsubsubitem
After ensuring sufficient space is available for the new items, the execution
environment shall copy or move each item $N$ such that from $N=I$ (inclusive)
to $N=I+L^2$ (exclusive), each item is placed at $I+L^2+N-1$, causing the items
to "shift" over to accomodate the insert values.

\specsubsubitem
The execution environment shall assign values of the object slice from index
$N = I$ (inclusive) to $N = I+L^2$ (exclusive) from each insert value in order.

\specsubsubitem
The \terminal{static} forms shall be equivalent to the non-static forms except
that they shall never cause the underlying slice to be reallocated. If the
operation would require more space than the capacity of the slice provides, the
execution environment shall print a diagnostic message and abort.

\specsubsubitem
The side-effects of the \nonterminal{indexing-expression} shall occur before
the side-effects of the insert values.

\specsubsection{Deleting}

\begin{grammar}
\nonterminaldef{delete-expression} \\
	\optional{\terminal{static}} \terminal{delete} \terminal{(} \nonterminal{indexing-expression} \terminal{)} \\
	\optional{\terminal{static}} \terminal{delete} \terminal{(} \nonterminal{slicing-expression} \terminal{)} \\
\end{grammar}

\specsubsubitem
A \nonterminal{delete-expression} shall remove a value, or values, from the
slice object specified by the first argument. The selected object shall be
mutable and non-const. The result of a \terminal{delete} shall be
\terminal{void}.

\specsubsubitem
Should a \nonterminal{indexing-expression} be used, it shall specify the index
of a single value as the \textit{deleted items}. Should a
\nonterminal{slicing-expression} be used, it shall specify a range of values as
the deleted items.

\specsubsubitem
The execution environment shall set the length of the slice object to $L^1-L^2$,
where $L^1$ is its previous length and $L^2$ is the number of deleted items.
Starting from the first index specified by the
\nonterminal{indexing-expression} or \nonterminal{slicing-expression}, $I$,
each item at index $N+L^1$ shall be copied to $N$, "shifting" items over to
reclaim the space previously used by the deleted items.

\specsubsubitem
The execution environment may decrease the slice object's capacity,
re-allocating its data field if necessary, in order to reclaim unused memory.
This re-allocation, if performed, shall not fail. The slice object shall be
updated to reflect the new capacity if necessary.

\specsubsubitem
The \terminal{static} forms shall be equivalent to the non-static forms except
that they shall never cause the underlying slice to be reallocated.

\specsubsection{Error propagation}

\begin{grammar}
\nonterminaldef{error-propagation} \\
	\nonterminal{postfix-expression} \terminal{?} \\
	\nonterminal{postfix-expression} \terminal{!} \\
\end{grammar}

\specsubsubitem
\terminal{?} and \terminal{!} are the error propagation operators. The
\nonterminal{postfix-expression} shall have a result type which is either a
type with the error flag set, or a tagged union type which has a type with the
error flag set among its member types.

\specsubsubitem
The result type of an error propagation expression shall be the same as the
type of the \nonterminal{postfix-expression}, without its error cases, or
\terminal{void} if no non-error types remain. The result is a tagged union
whose member types are the subset of the original type which do not include the
error flag; or, if there is only one such type, that type without a tagged
union; or, if there are no such types, \terminal{void}. If the original type is
not a tagged union type, the translation phase shall abort with a diagnostic
message.

\specsubsubitem
An error propagation expression shall perform an \textit{error test} which
checks if the result value of the \nonterminal{postfix-expression} is of a
non-error type. If so, that value shall be the result of the error propagation
expression.

\specsubsubitem
In the \terminal{?} form, if the error test fails (i.e. an error is found), the
error type shall be assignable to the current function's return type, and that
value shall be returned from the function, causing the function to terminate.

\specsubsubitem
In the \terminal{!} form, if the error test fails (i.e. an error is found), the
execution environment shall print a diagnostic message and abort.

\specsubsubitem
If a type hint is provided to the error propagation expression, the same type
shall be provided to the \nonterminal{postfix-expression}.

\specsubsection{Postfix expressions}

\begin{grammar}
\nonterminaldef{postfix-expression} \\
	\nonterminal{nested-expression} \\
	\nonterminal{call-expression} \\
	\nonterminal{field-access-expression} \\
	\nonterminal{indexing-expression} \\
	\nonterminal{slicing-expression} \\
	\nonterminal{error-propagation} \\

\nonterminaldef{object-selector} \\
	\nonterminal{identifier} \\
	\nonterminal{indexing-expression} \\
	\nonterminal{field-access-expression} \\
\end{grammar}

\specsubsubitem
\nonterminal{postfix-expression} is an expression class for expressions whose
operators use postfix notation.

\specsubsubitem
\nonterminal{object-selector} defines a subset of postfix expressions which
refer to objects, for use in other parts of the grammar.

\specsubsection{Builtin expressions}

\begin{grammar}
\nonterminaldef{builtin-expression} \\
	\nonterminal{allocation-expression} \\
	\nonterminal{assertion-expression} \\
	\nonterminal{deferred-expression} \\
	\nonterminal{measurement-expression} \\
	\nonterminal{slice-mutation-expression} \\
	\nonterminal{postfix-expression} \\
\end{grammar}

\specsubsection{Unary arithmetic}

\begin{grammar}
\nonterminaldef{unary-expression} \\
	\nonterminal{builtin-expression} \\
	\nonterminal{unary-operator} \nonterminal{unary-expression} \\

\nonterminaldef{unary-operator} \oneof \\
	\terminal{+}
	\terminal{-}
	\terminal{\textasciitilde}
	\terminal{!}
	\terminal{*}
	\terminal{\&}
\end{grammar}

\specsubsubitem
A unary expression applies a \nonterminal{unary-operator} to a single value.

\specsubsubitem
The \terminal{+} and \terminal{-} operators shall respectively perform unary
positive and unary negation operations. The result type shall be equivalent to
the type of \nonterminal{unary-expression}, which shall be of a signed numeric
type.

\specsubsubitem
The \terminal{\textasciitilde} operator shall perform a binary NOT operation,
inverting each bit of the value. Its result type shall be equivalent to the
type of \nonterminal{unary-expression}, which shall be of an unsigned integer
type.

\specsubsubitem
The \terminal{!} operator shall perform a logical NOT operation. The result
type, and the type of \nonterminal{unary-expression}, shall both be
\terminal{bool}. If the \nonterminal{unary-expression} is \terminal{true}, the
result shall be \terminal{false}, and vice-versa.

\specsubsubitem
The \terminal{*} operator shall dereference a pointer, and return the object it
references.  The type of \nonterminal{unary-expression} shall be a pointer
type, and the result type shall be the pointer's secondary type. The pointer
type shall not be \textit{nullable}.

\specsubsubitem
The \terminal{\&} operator shall take the address of an object. The result type
shall be a pointer whose secondary type is the type of the object selected by
the \nonterminal{unary-expression}. If the \nonterminal{unary-expression} is not
an \nonterminal{object-selector}, the ensuing pointer shall only be valid within
the current function.

\informative{The following table is informative.}

\begin{tabular}{r | l }
Operator & Meaning \\
\hline
\terminal{+} & Positive \\
\terminal{-} & Negation \\
\terminal{\textasciitilde} & Binary NOT \\
\terminal{!} & Logical NOT \\
\terminal{*} & Dereference pointer \\
\terminal{\&} & Take address \\
\end{tabular}

\specsubsection{Casts and type assertions}

\begin{grammar}
\nonterminaldef{cast-expression} \\
	\nonterminal{unary-expression} \\
	\nonterminal{cast-expression} \terminal{:} \nonterminal{type} \\
	\nonterminal{cast-expression} \terminal{as} \nonterminal{type} \\
	\nonterminal{cast-expression} \terminal{is} \nonterminal{type} \\
\end{grammar}

\specsubsubitem
A cast expression interrogates or converts the type of an object. The first
form illustrates the precedence. The second and third forms (\terminal{:} and
\terminal{as}) have a result type specified by the \nonterminal{type}; and the
fourth form (\terminal{is}) has a result type of \terminal{bool}.

\specsubsubitem
Each form shall provide the specified \nonterminal{type} as a type hint to its
\nonterminal{cast-expression}.

\specsubsubitem
The second form is a \textit{type cast}, and shall not fail. It shall cause the
execution environment to convert or interpret the value as another type.

\specsubsubitem
A type which may be cast to another type is considered \textit{castable} to
that type.

\specsubsubitem
All types are castable to themselves. The set of other types which are castable
to a given type are given by the following table:

\begin{tabular}{r | l}
Source type & Casts to \\
\hline
Floating types & Any numeric type \\
Integer types & Any numeric type or enum type \\
\terminal{uintptr} & Any pointer type or \terminal{null} \\
Any pointer type & Any pointer type, \terminal{uintptr}, or \terminal{null} \\
Enum types & Any enum type or numeric type \\
Array and slice types & Any array or slice type \\
Slice types & Any pointer to an array type \\
Type alias & Any type the underlying type could cast to \\
Any type & Any type alias with an underlying type it may be cast to \\
\terminal{u8} & \terminal{char} \\
\terminal{char} & \terminal{u8} \\
\terminal{rune} & \terminal{u32} \\
\terminal{u32} & \terminal{rune} \\
\terminal{null} & Any pointer type or \terminal{uintptr} \\
Tagged unions & See below \\
\end{tabular}

\specsubsubitem
Tagged union types are mutually castable with any type which is found among its
members, including the otherwise non-castable types of \terminal{bool} and
\terminal{void}, as well as any other tagged union type.

\specsubsubitem
When an integer type is cast to an integer of less precision, it shall be
truncated towards the least significant bit.

\specsubsubitem
When a signed type is cast to a unsigned type, the sign bit shall be copied to
the most significant bit of the unsigned type, and vice versa.

\specsubsubitem
When a floating type is cast to an integer, the resulting value shall be equal
to $I = \lfloor F \rfloor$, where F is the source value. If the destination type
has insufficient precision to represent $I$, it shall be truncated towards the
least significant bit.

\specsubsubitem
When casting an integer to a floating point type, if the destination type
lacks the precision to represent the value, it shall be truncated towards zero.

\specsubsubitem
Casting a pointer type to \nonterminal{uintptr}, and then back to the pointer
type, shall yield the same pointer.

\informative{However, casting \nonterminal{uintptr} to any other integer type
and back again may truncate towards the least significant bit and is not
guaranteed to yield the same pointer.}

\specsubsubitem
The \terminal{const} flag shall not affect the rules for casting one type to
another. The same holds for the error flag as well.

\specsubsubitem
The third form is a \textit{type assertion}. In this form,
\nonterminal{cast-expression} shall be of a tagged union type, and
\nonterminal{type} shall be a constituent type of that tagged union. The
\nonterminal{cast-expression} shall be computed, and if the tag does not match
\nonterminal{type}, a diagnostic message shall be printed and the execution
environment shall abort. Otherwise, the result type is \nonterminal{type}.

\specsubsubitem
The fourth form is a \textit{type test}. In this form,
\nonterminal{cast-expression} shall be of a tagged union type, and
\nonterminal{type} shall be a constituent type of that tagged union. The result
type is \terminal{bool}, and shall be \terminal{true} if the selected tag of
\nonterminal{cast-expression} is \nonterminal{type}, or \terminal{false}
otherwise.

\specsubsection{Multiplicative arithmetic}

\begin{grammar}
\nonterminaldef{multiplicative-expression} \\
	\nonterminal{cast-expression} \\
	\nonterminal{multiplicative-expression} \terminal{*} \nonterminal{cast-expression} \\
	\nonterminal{multiplicative-expression} \terminal{/} \nonterminal{cast-expression} \\
	\nonterminal{multiplicative-expression} \terminal{\%} \nonterminal{cast-expression} \\
\end{grammar}

\specsubsubitem
A \nonterminal{multiplicative-expression} multiplies (\terminal{*}), divides
(\terminal{/}), or obtains the remainder between (\terminal{\%}) two
expressions. The first form illustrates the precedence. The operands and result
type shall be subject to the \secref{Type promotion} rules.

\specsubsubitem
In the case of division or modulus, the first term is the dividend, and the
second term is the divisor. The result of the modulus shall have the same sign
as the dividend.

\specsubsubitem
A modulus (\terminal{\%}) operation shall be performed with operands of integer
types only.

\specsubsubitem
If an operation would cause the result to overflow the result type, it is
truncated towards the least significant bits in the case of integer types, and
towards zero in the case of float types. Integer divisions which would produce
a fractional part are rounded towards zero.

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Additive arithmetic}

\begin{grammar}
\nonterminaldef{additive-expression} \\
	\nonterminal{multiplicative-expression} \\
	\nonterminal{additive-expression} \terminal{+} \nonterminal{multiplicative-expression} \\
	\nonterminal{additive-expression} \terminal{-} \nonterminal{multiplicative-expression} \\
\end{grammar}

\specsubsubitem
An \nonterminal{additive-expression} adds (\terminal{+}) two operands, or
subtracts (\terminal{-}) one from another. The first form illustrates the
precedence. The operands and result type shall be subject to the \secref{Type
promotion} rules.

\specsubsubitem
In the case of subtraction, the first term is the minuend, and the second term
is the subtrahend.

\specsubsubitem
If an operation would cause the result to overflow or underflow the result
type, it is truncated towards the least significant bits in the case of integer
types, and towards zero in the case of float types. In the case of signed
types, this truncation will cause the sign bit to change.

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Bit shifting arithmetic}

\begin{grammar}
\nonterminaldef{shift-expression} \\
	\nonterminal{additive-expression} \\
	\nonterminal{shift-expression} \terminal{\textless{}\textless{}} \nonterminal{additive-expression} \\
	\nonterminal{shift-expression} \terminal{\textgreater{}\textgreater{}} \nonterminal{additive-expression} \\
\end{grammar}

\specsubsubitem
A \nonterminal{shift-expression} performs a bitwise left-shift
(\terminal{\textless{}\textless{}}) or right-shift (\terminal{\textgreater{}\textgreater{}}). The first
form illustrates the precedence. The result type shall be the type of the first
operand. Both operands shall be of unsigned integer types.

\specsubsubitem
\code{\nonterminal{shift-expression} \terminal{\textless{}\textless{}} $N$} shall shift
each bit towards the most significant bit $N$ places, and set the least
significant $N$ bits to zero. The $N$ most significant bits shall be silently
discarded. If $N$ is greater than the size in bits of the type, the result shall
be zero.

\informative{This operation is equivalent to multiplying
\nonterminal{shift-expression} by $2^N$}

\specsubsubitem
\code{\nonterminal{shift-expression} \terminal{\textgreater{}\textgreater{}}
$N$} shall shift each bit towards the least significant bit $N$ places. The most
significant bits shall be set to either zero or one depending on the signedness
of \nonterminal{shift-expression}: If it is signed, then the $N$ most
significant bits shall be set to the value of the sign bit. If it unsigned, then
the $N$ most significant bits shall be set to zero. The $N$ least significant
bits shall be silently discarded. If $N$ is greater than the size in bits of the
type, the result shall be zero.

\informative{This operation is equivalent to dividing
\nonterminal{shift-expression} by $2^N$}

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Bitwise arithmetic}

\begin{grammar}
\nonterminaldef{and-expression} \\
	\nonterminal{shift-expression} \\
	\nonterminal{and-expression} \terminal{\&} \nonterminal{shift-expression} \\

\nonterminaldef{exclusive-or-expression} \\
	\nonterminal{and-expression} \\
	\nonterminal{exclusive-or-expression} \terminal{\^} \nonterminal{and-expression} \\

\nonterminaldef{inclusive-or-expression} \\
	\nonterminal{exclusive-or-expression} \\
	\nonterminal{inclusive-or-expression} \terminal{|} \nonterminal{exclusive-or-expression} \\
\end{grammar}

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Logical comparisons}

\begin{grammar}
\nonterminaldef{comparison-expression} \\
	\nonterminal{inclusive-or-expression} \\
	\nonterminal{comparison-expression} \terminal{<} \nonterminal{inclusive-or-expression} \\
	\nonterminal{comparison-expression} \terminal{>} \nonterminal{inclusive-or-expression} \\
	\nonterminal{comparison-expression} \terminal{<=} \nonterminal{inclusive-or-expression} \\
	\nonterminal{comparison-expression} \terminal{>=} \nonterminal{inclusive-or-expression} \\

\nonterminaldef{equality-expression} \\
	\nonterminal{comparison-expression} \\
	\nonterminal{equality-expression} \terminal{==} \nonterminal{comparison-expression} \\
	\nonterminal{equality-expression} \terminal{!=} \nonterminal{comparison-expression} \\
\end{grammar}

\specsubsubitem
A \nonterminal{comparison-expression} determines which operand is lesser than
(\terminal{<}), greater than (\terminal{>}), less than or equal to
(\terminal{<=}), or greater than or equal to (\terminal{>=}) the other. The
operands shall be numeric, and are subject to the \secref{Type promotion}
rules.  The result type shall be \terminal{bool}.

\specsubsubitem
The result of the \terminal{<} operator shall be \terminal{true} if the first
operand is mathematically less than the second operand and \terminal{false}
otherwise.

\specsubsubitem
The result of the \terminal{>} operator shall be \terminal{true} if the first
operand is mathematically greater than the second operand and \terminal{false}
otherwise.

\specsubsubitem
The result of the \terminal{<=} operator shall be \terminal{true} if the
first operand is mathematically less than or equal to second operand
and \terminal{false} otherwise.

\specsubsubitem
The result of the \terminal{>=} operator shall be \terminal{true} if the first
operand is mathematically greater than or equal to second operand
and \terminal{false} otherwise.

\specsubsubitem
An \nonterminal{equality-expression} determines if two operands are equal to one
another. The result type is \terminal{bool}. If the types of the \terminal{==}
or \terminal{!=} operators are numeric, they shall be subject to
\subsecref{Type promotion}. Otherwise, each operand must be of the same type,
and that type must both be either \terminal{str}, \terminal{bool},
\terminal{rune}, or a pointer type.

\specsubsubitem
The result of the \terminal{==} operator shall be \terminal{true} if the first
operand is equal to second operand in value, and \terminal{false} otherwise.

\specsubsubitem
The result of the \terminal{!=} operator shall be \terminal{true} if the first
operand is not equal to second operand in value, and \terminal{false} otherwise.

\specsubsubitem
If the type is \terminal{str}, an \nonterminal{equality-expression} shall be
\terminal{true} if both strings have the same length and octets, and
\terminal{false} otherwise.

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Logical arithmetic}

\begin{grammar}
\nonterminaldef{logical-and-expression} \\
	\nonterminal{equality-expression} \\
	\nonterminal{logical-and-expression} \terminal{\&\&} \nonterminal{equality-expression} \\

\nonterminaldef{logical-xor-expression} \\
	\nonterminal{logical-and-expression} \\
	\nonterminal{logical-xor-expression} \terminal{\textasciicircum\textasciicircum} \nonterminal{logical-and-expression} \\

\nonterminaldef{logical-or-expression} \\
	\nonterminal{logical-xor-expression} \\
	\nonterminal{logical-or-expression} \terminal{||} \nonterminal{logical-xor-expression} \\
\end{grammar}

\specsubsubitem
For all cases of logical arithmetic, both terms shall be of the \terminal{bool}
type, and the result type shall be \terminal{bool}.

\specsubsubitem
\terminal{\&\&} shall compute a logical and operation, and shall be
\terminal{true} if both terms are \terminal{true}, and false otherwise.

\specsubsubitem
\terminal{\textasciicircum\textasciicircum} shall be a logical exclusive or
operation, and shall be \terminal{true} if the terms are not equal to each
other, and \terminal{false} otherwise.

\specsubsubitem
\terminal{||} shall be a logical or operation, and shall be \terminal{true} if
either term is \terminal{true}, and \terminal{false} otherwise.

\specsubsubitem
If the first term of \nonterminal{logical-and-expression} is \terminal{false},
or the first term of \nonterminal{logical-or-expression} is \terminal{true},
the implementation shall ensure that the side-effects of the second term do not
occur.

\specsubsection{If expressions}

\begin{grammar}
\nonterminaldef{if-expression} \\
	\terminal{if} \nonterminal{conditional-branch} \\
	\terminal{if} \nonterminal{conditional-branch} \terminal{else} \nonterminal{if-expression} \\
	\terminal{if} \nonterminal{conditional-branch} \terminal{else} \nonterminal{expression} \\

\nonterminaldef{conditional-branch} \\
	\terminal{(} \nonterminal{expression} \terminal{)} \nonterminal{expression} \\
\end{grammar}

\specsubsubitem
An \nonterminal{if-expression} chooses which, if any, expression to evaluate
based on a logical criteria. In all forms, the result type of
\nonterminal{expression} shall be \terminal{bool}. If a type hint is provided,
the \nonterminal{expression} shall receive it as a type hint.

\specsubsubitem
When executing a \nonterminal{conditional-branch}, the implementation shall
evaluate the \\ \nonterminal{expression} (the \textit{condition}), and if
\terminal{true}, the implementation shall execute the corresponding
\nonterminal{expression} (the \textit{branch}), ensuring that all side-effects
occur. If the condition is \terminal{false}, the branch shall not be executed
and shall not cause side-effects.

\specsubsubitem
In the second form, the first \nonterminal{conditional-branch} shall be
executed. If it was \terminal{false}, the second-order
\nonterminal{if-expression} shall be executed; otherwise not. In the latter
case, any side-effects of the second condition or branch shall not occur.

\specsubsubitem
In the third form, the \nonterminal{conditional-branch} shall be executed. If
it was \terminal{false}, the \nonterminal{expression} shall be executed, and all
of its side-effects shall occur.

\specsubsubitem
In the first form, the result type is \terminal{void}. In the second form, the
result type is \terminal{void} unless the third form is present in the
$N^{th}$-order sub-expression for any value of $N$. In this case, and in the
case of the third form used in the first order, if the result types of each
branch are uniform, the result type of the expression as a whole shall be of
that type. If the types are not uniform, the result type shall be a tagged
union of the set of possible result types. The result value shall be selected
from the result of the branch which is executed.

\specsubsubitem
If a type hint is provided and all non-terminating branches are assignable to
that type, the result type shall be the type given by the type hint. If the
result types of all non-terminating cases are equivalent, the result type of
the if expression shall be the result type of the cases. Otherwise, the
result type shall be a tagged union of the set of the result types of the
non-terminating cases.

If all cases terminate, the result type shall be \terminal{void} and the if
expression shall terminate.

\specsubsection{For loops}

\begin{grammar}
\nonterminaldef{for-loop} \\
	\terminal{for} \terminal{(} \nonterminal{for-predicate} \terminal{)} \nonterminal{expression} \\

\nonterminaldef{for-predicate} \\
	\nonterminal{expression} \\
	\nonterminal{binding-list} \terminal{;} \nonterminal{expression} \\
	\nonterminal{expression} \terminal{;} \nonterminal{expression} \\
	\nonterminal{binding-list} \terminal{;} \nonterminal{expression} \terminal{;} \nonterminal{expression} \\
\end{grammar}
% XXX: We may want to narrow the afterthought's expression class

\specsubsubitem
A \nonterminal{for-loop} executes its \nonterminal{expression}, the
\textit{body} of the loop, zero or more times, so long as a condition is true.
Its result type is \terminal{void}.

\specsubsubitem
In the first form, \nonterminal{for-predicate} specifies the \textit{condition}
with its \nonterminal{expression}. In the second form, the
\nonterminal{binding-list} is the \textit{binding} and the expression is the
condition. In the second form, the first expression is the condition, and the
second expression is the \textit{afterthought}. In the third form, the
\nonterminal{binding-list} is the binding, and the two expressions are
respectively the condition and afterthought. The result type of the condition
shall be \terminal{bool}, and this shall be provided as a type hint.

\specsubsubitem
The implementation shall establish a new scope for the
\nonterminal{expression}, then, if present, it shall evaluate the
\nonterminal{binding} in this scope. The implementation shall then evaluate the
condition. If it is \terminal{true}, the \nonterminal{expression} shall be
evaluated and all of its side-effects shall occur; this process is an
\textit{iteration}. When the iteration is complete, the implementation shall
evaluate the afterthought, if present, and then repeat the process, until the
condition evaluates to \terminal{false}.

\specsubsection{Switch expressions}

\begin{grammar}
\nonterminaldef{switch-expression} \\
	\terminal{switch} \terminal{(} \nonterminal{expression} \terminal{)} \terminal{\{} \nonterminal{switch-cases} \terminal{\}} \\

\nonterminaldef{switch-cases} \\
	\nonterminal{switch-case} \terminal{;} \\
	\nonterminal{switch-case} \terminal{;} \nonterminal{switch-cases} \\

\nonterminaldef{switch-case} \\
	\terminal{case} \nonterminal{case-options} \terminal{=>} \nonterminal{expression-list} \\
	\terminal{case} \terminal{=>} \nonterminal{expression-list} \\

\nonterminaldef{case-options} \\
	\nonterminal{expression} \optional{\terminal{,}} \\
	\nonterminal{expression} \terminal{,} \nonterminal{case-options} \\
\end{grammar}

Forward references: \subsecref{Compound expressions}

\specsubsubitem
A switch statement evaluates a value (\nonterminal{expression}, the
\textit{switching expression}), then compares it with a number of
\nonterminal{switch-cases}, taking whichever branch matches the value.

\specsubsubitem
Each of the \nonterminal{case-options} specifies a value to compare with, given
by \nonterminal{expression}. This expression shall be limited to the
\secref{Translation compatible expression subset}, and its result type shall be
equivalent to the result type of the switching expression.

\specsubsubitem
Each \nonterminal{switch-case} introduces an implicit
\nonterminal{compound-expression} which the provided
\nonterminal{expression-list} gives the expressions of. The implementation
shall evaluate the \nonterminal{expression-list} of the corresponding
\nonterminal{switch-case} if any of the \nonterminal{case-options} is equal to
the switching expression's result, setting the result of the overall switch
expression to the result of the selected \nonterminal{switch-case}.

\informative{As such, the appropriate way to set the result of a switch
statement is with a \nonterminal{yield-expression}. The semantics of
\nonterminal{deferred-expression}, \nonterminal{bindings}, and so on, are also
implicated.}

\specsubsubitem
The form of \nonterminal{switch-case} without \nonterminal{case-options}
indicates any case which is not selected by the other cases. Only one case of
this form shall appear in the switch expression.

\specsubsubitem
The switch cases shall be \textit{exhaustive}, meaning that every possible
value of the switching expression is accounted for by a
\nonterminal{switch-case}. It shall also be preicsely exhaustive: no two cases
shall select for the same value.

\specsubsubitem
The implementation shall ensure that side-effects of the switch value
expression occur before those of the selected case, and that side-effects of
non-selected cases do not occur.

\specsubsubitem
If a type hint is provided, each branch shall receive it as a type hint.

\specsubsubitem
If a type hint is provided and all non-terminating branches are assignable to
that type, the result type shall be the type given by the type hint. If the
result types of all non-terminating cases are equivalent, the result type of
the switch expression shall be the result type of the cases. Otherwise, the
result type shall be a tagged union of the set of the result types of the
non-terminating cases.

If all cases terminate, the result type shall be \terminal{void} and the switch
expression shall terminate.

\specsubsection{Match expressions}

\begin{grammar}
\nonterminaldef{match-expression} \\
	\terminal{match} \terminal{(} \nonterminal{expression} \terminal{)} \terminal{\{} \nonterminal{match-cases} \terminal{\}} \\

\nonterminaldef{match-cases} \\
	\nonterminal{match-case} \terminal{;} \\
	\nonterminal{match-case} \terminal{;} \nonterminal{match-cases} \\

\nonterminaldef{match-case} \\
	\terminal{case} \terminal{let} \nonterminal{name} \terminal{:} \nonterminal{type} \terminal{=>} \nonterminal{expression-list} \\
	\terminal{case} \nonterminal{type} \terminal{=>} \nonterminal{expression-list} \\
	\terminal{case} \terminal{=>} \nonterminal{expression-list} \\
\end{grammar}

Forward references: \subsecref{Compound expressions}

\specsubsubitem
A match statement evaluates a value (\nonterminal{expression}, the
\textit{matching expression}), then selects and evaluates another expression
based on its result type. The result type of the matching expression must be a
tagged union or nullable pointer type, or an alias of either.

\specsubsubitem
If the matching expression has a tagged union type, each
\nonterminal{match-case} shall specify a type which is either a member of that
tagged union, or another tagged union which supports a subset of the matching
expression's type, or a type alias which refers to a qualifying type.

\specsubsubitem
If the matching expression has a nullable pointer type, one match case shall be
\terminal{null}, and another shall be the equivalent non-nullable pointer type,
or a type alias which refers to a qualifying type.

\specsubsubitem
Each \nonterminal{match-case} introduces an implicit
\nonterminal{compound-expression} which the provided
\nonterminal{expression-list} gives the expressions of. The implementation
shall evaluate the \nonterminal{expression-list} of the corresponding
\nonterminal{match-case} if the value of the matching expression is of the type
specified by this match case, or can be assigned from it, setting the result of
the overall match statement to the result of the selected
\nonterminal{match-case}.

% TODO: Write up new matching algorithm

\informative{As such, the appropriate way to set the result of a match
statement is with a \nonterminal{yield-expression}. The semantics of
\nonterminal{deferred-expression}, \nonterminal{bindings}, and so on, are also
implicated.}

\specsubsubitem
The form of \nonterminal{match-case} without a \nonterminal{type} indicates any
case which is not selected by the other cases. Only one case of this form shall
appear in the match expression.

\specsubsubitem
The first form of \nonterminal{match-case}, if selected, shall cause the
implementation to cast the match expression to the selected type and assign the
resulting value to \nonterminal{name}. It shall insert this binding into the
scope of the implicit \nonterminal{compound-expression} of the selected case.

\specsubsubitem
The match cases shall be \textit{exhaustive}, meaning that every possible type
of the matching expression is accounted for by a \nonterminal{match-case}. It
shall also be preicsely exhaustive: no two cases shall select for the same
type.

\specsubsubitem
The implementation shall ensure that side-effects of the match value
expression occur before those of the selected case, and that side-effects of
non-selected cases do not occur.

\specsubsubitem
If a type hint is provided, each branch shall receive it as a type hint.

\specsubsubitem
If a type hint is provided and all non-terminating branches are assignable to
that type, the result type shall be the type given by the type hint. If the
result types of all non-terminating cases are equivalent, the result type of
the match expression shall be the result type of the cases. Otherwise, the
result type shall be a tagged union of the set of the result types of the
non-terminating cases.

If all cases terminate, the result type shall be \terminal{void} and the match
expression shall terminate.

\specsubsection{Assignment}

\begin{grammar}
\nonterminaldef{assignment} \\
	\nonterminal{object-selector} \nonterminal{assignment-op} \nonterminal{expression} \\
	\terminal{*} \nonterminal{unary-expression} \nonterminal{assignment-op} \nonterminal{expression} \\
	\nonterminal{slicing-expression} \terminal{=} \nonterminal{expression} \\

\nonterminaldef{assignment-op} \oneof \\
	\terminal{=}
	\terminal{+=}
	\terminal{-=}
	\terminal{*=}
	\terminal{/=}
	\terminal{\%=}
	\terminal{\textless{}\textless{}=}
	\terminal{\textgreater{}\textgreater{}=}
	\terminal{\&=}
	\terminal{|=}
	\terminal{\textasciicircum=}
	\terminal{\&\&=}
	\terminal{||=}
	\terminal{\textasciicircum\textasciicircum=}
\end{grammar}

\specsubsubitem
An \nonterminal{assignment} expression shall cause the object given by the
first term to be assigned a new value based on the value given by the second
term. The type of the object shall be provided as a type hint to the secondary
expression(s).

\specsubsubitem
If the \nonterminal{assignment-op} is \terminal{=}, the first term shall be
assigned the value given by the second term. Otherwise, the assignment
\code{\nonterminal{e1} \nonterminal{op}\terminal{=} \nonterminal{e1}} shall be
equivalent to the assignment
\code{\nonterminal{e1} \terminal{=} \nonterminal{e1} \nonterminal{op} \nonterminal{e2}},
but the side effects of \nonterminal{e1} shall only occur once.

\specsubsubitem
In the first form, the \nonterminal{object-selector} selects the object to be
modified. The type of this object shall not be of a \terminal{const} type.

\specsubsubitem
In the second form, the \nonterminal{unary-expression} shall have a result type
of a non-nullable, non-const pointer type, and the object which is assigned
shall be the secondary object to which the pointer object refers. The second
term shall be assignable to the pointer's secondary type.

\specsubsubitem
In the third form, the \nonterminal{expression} shall be of a slice
type, and shall have a length equal to the slice given by
\nonterminal{slicing-expression}. The first term shall not be of a
\terminal{const} type, and the lengths of the two slices shall be equal. The
contents of the slice given by the second term shall be copied into the slice
given by the first term.

\specsubsubitem
The second term shall be \textit{assignable} to the object. Assignability rules
are stricter than castability rules. All types are assignable to themselves. The
set of other types which are assignable to a given type are given by the
following table:

\begin{tabular}{r | l}
Object type & May be assigned from \\
\hline
Mutable type & Constant types assignable to the object type \\
Signed integer types & Signed integer types of equal or higher precision \\
Unsigned integer types & Unsigned integer types of equal or higher precision \\
Floating-point types & Any floating-point type of equal or higher precision \\
Nullable pointer types & Non-nullable pointer type of the same secondary type \\
Nullable pointer types & \terminal{null} \\
Slice types & Array type of the same secondary type and definite length \\
Slice types & \terminal{[}\terminal{]}\terminal{void} \\
Array types of undefined size & Array types of defined size \\
Tagged union types & See notes \\
Type aliases & Any type assignable to the secondary type \\
\terminal{void} & Any type \\
\terminal{*} \terminal{void} & Any non-nullable pointer type \\
\terminal{nullable} \terminal{*} \terminal{void} & Any pointer type \\
\terminal{*} \terminal{const} \terminal{char} & \terminal{str} \\
\end{tabular}

The implementation shall perform any necessary conversion from the source type
to the destination type.

\specsubsubitem
Pointers to array types are mutually assignable if their secondary types are
mutually assignable.

\specsubsubitem
A pointer to a type is assignable to a pointer to a secondary type if
the primary type is a struct type which contains the secondary type at
offset zero, or if the type at offset zero is a type which would be assignable
under these rules.

\specsubsubitem
Tagged union types may be assigned from any of their constituent types. Tagged
unions may also be assigned from any type which is assignable to exactly one of
its constituent types. Additionally, tagged unions may be assigned from any
other tagged union type, provided that the set of constituent types of the
destination type is a superset of the set of constituent types of the source
type.

\specsubsubitem
\terminal{const} types have the same assignability rules as the equivalent
non-const type. Types with the error flag set have the same assignability rules
as the equivalent type with the flag unset.

\informative{In the context of an assignment expression,
\subsubitemref{Assignment}{2} prevents the modification of objects with a const
type. However, the \textit{assignability} rules are referred to in many other
contexts throughout the specification, and in these contexts, unless otherwise
specified, non-const types are assignable to const types. For example, a
\nonterminal{binding} which specifies a const \nonterminal{type} may use a
non-const type for its \nonterminal{expression}.}

\specsubsubitem
For assignment of \terminal{*} \terminal{const} \terminal{char} from
\terminal{str} types, see the notes on \subsecref{Casts and type assertions}.

\specsubsubitem
The implementation shall ensure that any side-effects of the first term shall
occur before side-effects of the second term.

\specsubsection{Variable binding}

\begin{grammar}
\nonterminaldef{binding-list} \\
	\optional{\terminal{static}} \terminal{let} \nonterminal{bindings} \\
	\optional{\terminal{static}} \terminal{const} \nonterminal{bindings} \\

\nonterminaldef{bindings} \\
	\nonterminal{binding} \optional{\terminal{,}} \\
	\nonterminal{binding} \terminal{,} \nonterminal{bindings} \\

\nonterminaldef{binding} \\
	\nonterminal{name} \terminal{=} \nonterminal{expression} \\
	\nonterminal{name} \terminal{:} \nonterminal{type} \terminal{=} \nonterminal{expression} \\
	\terminal{(} \nonterminal{binding-names} \terminal{)}  \terminal{=} \nonterminal{expression} \\
	\terminal{(} \nonterminal{binding-names} \terminal{)} \terminal{:} \nonterminal{type} \terminal{=} \nonterminal{expression} \\

\nonterminaldef{binding-names} \\
	\nonterminal{name} \terminal{,} \nonterminal{name} \\
	\nonterminal{name} \terminal{,} \nonterminal{binding-names} \\
\end{grammar}

\specsubsubitem
A \nonterminal{binding-list} shall cause one or more objects to become
available in the present scope. Each object shall be identified by its
\nonterminal{name}, and shall have its initial value set to the result of the
\nonterminal{expression} or \nonterminal{expression}. The result
type of a binding list expression is \terminal{void}.

\specsubsubitem
In the first form of \nonterminal{binding-list}, the type of the object shall
be equivalent to the result type of the \nonterminal{expression}. In the
second form, the type shall be as indicated, and the result type of the
\nonterminal{expression} shall be assignable to this type. In this second form,
the type specified is used as a type hint for the \nonterminal{expression}.

\specsubsubitem
The third and fourth forms of \nonterminal{binding} are the \textit{tuple
unpacking} form, and in this case, the \nonterminal{type} and
\nonterminal{expression} shall be of a tuple type with a number of values equal
to the number of times \nonterminal{name} is given. The implementation shall
create separate bindings for each name, of the type of the corresponding tuple
value, and initialize them to that value from the tuple.

\specsubsubitem
If any \nonterminal{name} is \terminal{\_} (an underscore), a binding shall not
be created, but any side-effects of the initializer shall still occur.

\specsubsubitem
If the \terminal{const} form is used, the type of each binding shall be
modified to \textit{include} the \terminal{const} flag. If the \terminal{let}
form is used, the type of each binding which uses the first form of
\nonterminal{binding} shall be modified to \textit{omit} the \terminal{const}
flag.

\specsubsubitem
If the \terminal{static} form is used, the variables shall be allocated
\textit{statically}, such that they are only initialized once and their
previous value, accounting for any later mutations, is preserved each time
the binding expression is encountered, including across repeated or recursive
calls to the enclosing function. In this case, the initializer must use the
\secref{Translation compatible expression subset}.

\specsubsubitem
If a \nonterminal{binding} gives a \nonterminal{name} which is already defined
in the current scope, the new binding shall \textit{shadow} the earlier
binding, causing any later references to this name to resolve to the newer
binding.

\specsubsubitem
If the second form of \nonterminal{binding} is used and the \nonterminal{name}
is not already in use in this scope, the name shall be bound prior to the
evaluation of the \nonterminal{expression}, and may be used in the
\nonterminal{expression} \textit{only} as the object of the unary addressing
operator (\terminal{\&}).

\specsubsubitem
The type of the binding shall not use a type which has a zero or undefined size.

\specsubsection{Deferred expressions}

\begin{grammar}
\nonterminaldef{deferred-expression} \\
	\terminal{defer} \nonterminal{expression} \\
\end{grammar}

\specsubsubitem
A \nonterminal{deferred-expression} causes another expression to be
\textit{deferred} until the termination of the current scope. The result type
is \terminal{void}.

\specsubsubitem
The implementation shall cause the \nonterminal{expression} to be evaluated
upon the termination of the current scope, either due to normal program flow,
or due to encountering a terminating expression.

\specsubsubitem
If several expressions are deferred in a single scope, their side-effects shall
occur in the reverse of the order that they appear in the program source.

\specsubsubitem
If the current scope is terminated before a \nonterminal{deferred-expression}
(\informative{but not an expression which was already deferred}) would be
evaluated, the side-effects of the \nonterminal{expression} shall not occur.

\specsubsubitem
A \nonterminal{deferred-expression} shall not appear as a descendant of the
expression tree formed by \nonterminal{expression}.

\specsubsection{Compound expressions}

\begin{grammar}
\nonterminaldef{expression-list} \\
	\nonterminal{expression} \terminal{;} \\
	\nonterminal{expression} \terminal{;} \nonterminal{expression-list} \\

\nonterminaldef{compound-expression} \\
	\optional{\nonterminal{label}} \terminal{\{} \nonterminal{expression-list} \terminal{\}} \\

\nonterminaldef{label}\exactly \\
	\terminal{:} \nonterminal{name} \\
\end{grammar}

\specsubsubitem
A \nonterminal{compound-expression} evaluates any number of
\nonterminal{expression}s in sequence. If a \nonterminal{label} is present, the
expression is considered \textit{labelled}.

\specsubsubitem
The result of a \nonterminal{compound-expression} shall be \terminal{void}
unless the expression is selected by one or more
\nonterminal{yield-expression}s. If the result types of the yield expressions
are uniform, the \nonterminal{compound-expression} result type is that type.
Otherwise, the result type is the tagged union which is the sum of those types.

% TODO: Rewrite result type aggregation rules

\specsubsubitem
If a type hint is provided to an \nonterminal{compound-expression}, the hint shall
be provided to the expression of any \nonterminal{yield-expression} which
selects that \nonterminal{compound-expression}.

\specsubsubitem
The expressions shall be evaluated such that the side-effects of each all occur
in the order that each expression appears.

\specsubsubitem
If any of the \nonterminal{expression}s terminate, the
\nonterminal{compound-expression} is considered to terminate, unless the
expression which would cause the \nonterminal{compound-expression} is a
\nonterminal{yield-expression} which selects this
\nonterminal{compound-expression}s scope. There shall be no expressions
following the first terminating expression in a \nonterminal{compound-expression}.

\specsubsubitem
The \nonterminal{compound-expression} shall establish a new scope whose parent is
the scope in which the \nonterminal{compound-expression} resides.

\specsubsection{Control statements}

\begin{grammar}
\nonterminaldef{control-expression} \\
	\terminal{break} \optional{\nonterminal{label}} \\
	\terminal{continue} \optional{\nonterminal{label}} \\
	\terminal{return} \optional{\nonterminal{expression}} \\
	\nonterminal{yield-expression} \\

\nonterminaldef{yield-expression} \\
	\terminal{yield} \\
	\terminal{yield} \nonterminal{expression} \\
	\terminal{yield} \nonterminal{label} \\
	\terminal{yield} \nonterminal{label} \terminal{,} \nonterminal{expression} \\
\end{grammar}

\specsubsubitem
\nonterminal{control-expression} causes a \textit{selected}
\nonterminal{compound-expression} to terminate in a specific way. Control
statements and yield expresisons are terminating expressions and their result
type is \terminal{void}.

\specsubsubitem
The rules for the selection of an applicable \nonterminal{compound-expression}
vary based on the kind of control expression used. If a label is used, it shall
select the corresponding labelled \nonterminal{compound-expression} from the
anscestors of the \nonterminal{control-expression}, and the selected expression
shall meet the requirements for the appropriate control expression type.
Otherwise, the first qualifying \nonterminal{compound-expression} among the
ancestors of the \nonterminal{control-expression} is used, ordered such that
the nearest ancestor is considered first. If no suitable
\nonterminal{compound-expression} is selected, a diagnostic message will be
displayed and the translation phase shall terminate.

\specsubsubitem
In the \terminal{break} and \terminal{continue} forms, the selected expression
shall be the body of a \nonterminal{for-loop}. The \terminal{break} form shall
cause the loop to abort without evaluating the \textit{condition} or the
\textit{afterthought}. The \terminal{continue} form shall cause the loop to
repeat immediately, running the \textit{afterthought}, re-testing the
\textit{condition}, and repeating the loop if \terminal{true}.

\specsubsubitem
The \terminal{return} form shall select the \nonterminal{compound-expression}
which is the body of the \nonterminal{function-declaration} within which it
appears. The \nonterminal{expression} shall be used as the result value for the
function, or, if absent, \terminal{void} shall be used. This expression shall
receive the function's result type as a type hint, and the result shall be
assignable to that type.

\specsubsubitem
The \nonterminal{yield-expression} form shall select any
\nonterminal{compound-expression} which is not eligible for the other forms;
that is, any compound expression which is not a function or loop body. If an
expression is provided, it shall not terminate, and shall be used as the result
value for the \nonterminal{compound-expression}. See the description of
\nonterminal{compound-expression} for details on the type semantics associated
with a yield expression.

\specsubsubitem
In any of these cases, the implementation shall ensure that side-effects do not
occur for any expressions which are lexically situated \textit{after} the
\nonterminal{control-expression} within the selected
\nonterminal{compound-expression}.

\specsubsection{High-level expression class}

\begin{grammar}
\nonterminaldef{expression} \\
	\nonterminal{assignment} \\
	\nonterminal{binding-list} \\
	\nonterminal{logical-or-expression} \\
	\nonterminal{if-expression} \\
	\nonterminal{for-loop} \\
	\nonterminal{switch-expression} \\
	\nonterminal{match-expression} \\
	\nonterminal{control-expression} \\
	\nonterminal{compound-expression} \\
\end{grammar}

\specsection{Type promotion}

\specsubitem
The operands of some arithmetic expressions are subject to \textit{type
promotion}, to allow for arithmetic between disjoint types. The operand of
lower precision may be \textit{promoted}, or implicitly cast, to the precision
of the more precise operand. Unless explicitly covered by the following cases,
operands shall not be promoted, and the translation environment shall print a
diagnostic message and abort for incompatible combinations of operand types.

\specsubitem
For expressions where the result type is determined by type promotion, the
result type shall be equivalent to the type of the operand which has the
highest precision.

\specsubitem
For expressions involving two integer types, the type of lower precision may be
promoted to the type of higher precision only if the signedness is the same for
each operand. A type cannot be promoted to \terminal{uintptr}.

\specsubitem
For expressions involving floating-point types, \terminal{f32} may be promoted
to \terminal{f64}.

\specsubitem
For expressions involving pointer types, \terminal{null} may be promoted to any
nullable pointer type, and a non-nullable pointer type may be promoted to
a nullable pointer type with the same secondary type. Any pointer type may be
promoted to a void pointer.

\specsubitem
A mutable type may be promoted to a constant type which is otherwise equivalent
to the mutable type, or any other type which that constant type may promote to.

\specsubitem
A pointer type may be promoted to another pointer type if the secondary type of
the pointer may be promoted to the secondary type of the second pointer.

\specsubitem
An array type may promote to an array type with undefined size with an
equivalent member type.

\specsubitem
A non-aliased type A may promote to a type alias B if type A may promote to the
underlying type of type B.

% TODO: This is an awful edge case, fix harec first
% Ideally, constants wouldn't be lowered to int without a type hint, then we
% could specify promotion and assignability normally for them and lower them to
% int in bindings (and maybe some other places?)

\specsubitem
If one operand is a constant and the other is not, the constant shall receive
the result type of the other operand as a type hint and type promotion shall be
done between its result type and the other operand's result type.

\specsubitem
If both operands are constants, they shall both receive the lowest-precision
integer type which would hold both of them as a type hint.

\specsection{Translation compatible expression subset}

The translation-compatible expression subset is a subset of expression types
which the implementation must be able to evaluate during the translation phase.

\specsubitem
The following expression types are included:

\begin{minipage}[t][7cm][b]{\textwidth}
\begin{multicols}{2}
\begin{itemize}
\item \nonterminal{logical-or-expression}
\item \nonterminal{logical-xor-expression}
\item \nonterminal{logical-and-expression}
\item \nonterminal{equality-expression}
\item \nonterminal{comparison-expression}
\item \nonterminal{inclusive-or-expression}
\item \nonterminal{exclusive-or-expression}
\item \nonterminal{and-expression}
\item \nonterminal{shift-expression}
\item \nonterminal{additive-expression}
\item \nonterminal{multiplicative-expression}
\item \nonterminal{cast-expression}
\item \nonterminal{unary-expression}
\item \nonterminal{field-access-expression}
\item \nonterminal{indexing-expression}
\item \nonterminal{measurement-expression}
\item \nonterminal{nested-expression}
\item \nonterminal{plain-expression}
\end{itemize}
\end{multicols}
\end{minipage}

\vspace{0.25cm}
\specsubitem
All terminals which are descendants of any of the listed terminals are
included, and all non-terminals and terminals which are descendants of
\nonterminal{plain-expression} are included.

\specsubitem
The pointer dereference \nonterminal{unary-expression} (the \terminal{*}
operator) shall be excluded from the translation-compatible expression subset.
Additionally, the implicit pointer type dereference semantics of
\nonterminal{field-access-expression} and \nonterminal{indexing-expression} are
not available.

\specsubitem
The implementation is not required to use a conformant implementation of the
storage semantics of types in the translation environment, provided that there
are not observable side-effects in the execution environment as a result of any
differences.

\specsubitem
In a context where an expression is constrained to this subset, the use of an
expression type outside of this set shall cause the translation environment to
print a diagnostic message and abort.
