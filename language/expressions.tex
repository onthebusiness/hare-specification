\specsection{Expressions}

\specsubitem
An expression is a procedure which the implementation may perform to obtain a
\textit{result}, and possibly cause side-effects (see
\subsubitemref{Program execution}{1}).

\specsubitem
Expression types are organized into a number of classes and subclasses of
expressions which define the contexts in which each expression type is
applicable.

\specsubitem
All expressions have a defined \textit{result type}. It may be \terminal{void}.

\specsubitem
Some expressions \textit{terminate}. The semantics of terminating expressions
vary between different expression types, and will be detailed as appropriate.
If unspecified, expressions described by this expression are presumed to be
non-terminating.

\specsubsection{Constants}

\begin{grammar}
\nonterminaldef{constant} \\
	\nonterminal{integer-constant} \\
	\nonterminal{floating-constant} \\
	\nonterminal{rune-constant} \\
	\nonterminal{string-constant} \\
	\terminal{true} \\
	\terminal{false} \\
	\terminal{null} \\
	\terminal{void} \\
\end{grammar}

\specsubsubitem
Constants (also known as literals) shall describe a specific value of an
unambiguous type. The result of the expression is the constant value.

\specsubsubitem
The keywords \terminal{true} and \terminal{false} respectively represent
the constants of the \terminal{bool} type.

\specsubsubitem
The representation of \terminal{true} as an \terminal{uint}-equivalent (ref
\subsubitemref{Other primitive types}{2}) shall be one.

\specsubsubitem
The \terminal{null} keyword represents the \terminal{null} value of the
\terminal{null} type.

\specsubsubitem
The \terminal{void} keyword represents the \terminal{void} value of the
\terminal{void} type.

\specsubsection{Floating constants}

\begin{grammar}
\nonterminaldef{floating-constant} \\
	\nonterminal{decimal-digits} \terminal{.} \nonterminal{decimal-digits} \optional{\nonterminal{exponent}} \optional{\nonterminal{floating-suffix}} \\
	\nonterminal{decimal-digits} \optional{\nonterminal{exponent}} \nonterminal{floating-suffix} \\

\nonterminaldef{floating-suffix} \oneof \\
	\terminal{f32}
	\terminal{f64} \\

\nonterminaldef{decimal-digits} \\
	\nonterminal{decimal-digit} \optional{\nonterminal{decimal-digits}} \\

\nonterminaldef{decimal-digit} \oneof \\
	\terminal{0}
	\terminal{1}
	\terminal{2}
	\terminal{3}
	\terminal{4}
	\terminal{5}
	\terminal{6}
	\terminal{7}
	\terminal{8}
	\terminal{9} \\

\nonterminaldef{exponent} \\
	\terminal{e} \nonterminal{decimal-digits} \\
\end{grammar}

% TODO: consider using magic precision numeric constants which assume
% their type from context

Floating constants represent an IEEE 754-compatible floating-point
number in either the binary32 or binary64 format.

\specsubitem
If the \nonterminal{floating-suffix} is not provided, the type shall be
\terminal{f64}. Otherwise, the type shall refer to the type named by the suffix.

\specsubitem
If the \nonterminal{exponent} is provided, the value of the
constant shall be multiplied by 10 to the power of
\nonterminal{decimal-digits}.

\specsubsection{Integer constants}

\begin{grammar}
\nonterminaldef{integer-constant} \\
	\terminal{0x} \nonterminal{hex-digits} \optional{\nonterminal{integer-suffix}} \\
	\terminal{0o} \nonterminal{octal-digits} \optional{\nonterminal{integer-suffix}} \\
	\terminal{0b} \nonterminal{binary-digits} \optional{\nonterminal{integer-suffix}} \\
	\nonterminal{decimal-digits} \optional{\nonterminal{exponent}}
		\optional{\nonterminal{integer-suffix}} \\

\nonterminaldef{hex-digits} \\
	\nonterminal{hex-digit} \optional{\nonterminal{hex-digits}} \\

\nonterminaldef{hex-digit} \oneof \\
	\terminal{0}
	\terminal{1}
	\terminal{2}
	\terminal{3}
	\terminal{4}
	\terminal{5}
	\terminal{6}
	\terminal{7}
	\terminal{8}
	\terminal{9}
	\terminal{A}
	\terminal{B}
	\terminal{C}
	\terminal{D}
	\terminal{E}
	\terminal{F}
	\terminal{a}
	\terminal{b}
	\terminal{c}
	\terminal{d}
	\terminal{e}
	\terminal{f} \\

\nonterminaldef{octal-digits} \\
	\nonterminal{octal-digit} \optional{\nonterminal{octal-digits}} \\

\nonterminaldef{octal-digit} \oneof \\
	\terminal{0}
	\terminal{1}
	\terminal{2}
	\terminal{3}
	\terminal{4}
	\terminal{5}
	\terminal{6}
	\terminal{7} \\

\nonterminaldef{binary-digits} \\
	\nonterminal{binary-digit} \optional{\nonterminal{binary-digits}} \\

\nonterminaldef{binary-digit} \oneof \\
	\terminal{0}
	\terminal{1} \\

\nonterminaldef{integer-suffix} \oneof \\
	\terminal{i}
	\terminal{u}
	\terminal{z}
	\terminal{i8}
	\terminal{i16}
	\terminal{i32}
	\terminal{i64}
	\terminal{u8}
	\terminal{u16}
	\terminal{u32}
	\terminal{u64} \\
\end{grammar}

% TODO: Consider using magic precision numeric constants which assume their
% type from context

Integer constants represent an integer value at a specific precision.

\specsubitem
If the \nonterminal{integer-suffix} is not provided, the type shall be
\terminal{int}.  Otherwise, the type is specified by the suffix. Suffixes
\terminal{i}, \terminal{u},  and \terminal{z} shall respectively refer to the
\terminal{int}, \terminal{uint}, and \terminal{size} types; the remainder shall
refer to the type named by the suffix.

\specsubitem
If the number provided is not within the limits of the precision of the
constant type, a diagnostic message shall be printed and the translation phase
shall fail.

\specsubitem
The prefixes \terminal{0x}, \terminal{0o}, and \terminal{0b} shall respectively
cause the number to be interpreted with a hexadecimal, octal, or binary base.
If no prefix is used, the number shall be interpreted with a decimal base.

\specsubitem
If the \nonterminal{exponent} is provided, the value of the
integer shall be multiplied by 10 to the power of \nonterminal{decimal-digits}.

\specsubsection{Rune constants}
\begin{grammar}
\nonterminaldef{rune-constant} \\
	\terminal{'} \nonterminal{rune} \terminal{'} \\

\nonterminaldef{rune} \\
	\norm{Any character other than \terminal{\textbackslash} or \terminal{'}} \\
	\nonterminal{escape-sequence} \\

\nonterminaldef{escape-sequence} \\
	\nonterminal{named-escape} \\
	\terminal{\textbackslash{}x} \nonterminal{hex-digit} \nonterminal{hex-digit} \\
	\terminal{\textbackslash{}u} \nonterminal{hex-digit} \nonterminal{hex-digit} \nonterminal{hex-digit} \nonterminal{hex-digit} \\

\nonterminaldef{named-escape} \oneof \\
	\terminal{\textbackslash0}
	\terminal{\textbackslash{}a}
	\terminal{\textbackslash{}b}
	\terminal{\textbackslash{}f}
	\terminal{\textbackslash{}n}
	\terminal{\textbackslash{}r}
	\terminal{\textbackslash{}t}
	\terminal{\textbackslash{}v}
	\terminal{\textbackslash\textbackslash}
	\terminal{\textbackslash'}
	\terminal{\textbackslash"} \\
\end{grammar}

\specsubsubitem
If the \nonterminal{rune-constant} is not an \nonterminal{escape-sequence}, the
value of the rune shall be the Unicode codepoint representing
\nonterminal{rune}.

\specsubsubitem
A \nonterminal{rune-constant} beginning with \terminal{\textbackslash{}x} or
\terminal{\textbackslash{}u} shall interpet its value as a Unicode codepoint
specified in its hexadecimal representation by \nonterminal{hex-digit}s.

\specsubsubitem
A \nonterminal{rune-constant} containing a \nonterminal{named-escape} shall have
a value based on the following chart:

\begin{tabular}{r | l | r | l}
Escape sequence & Unicode codepoint & Escape sequence & Unicode codepoint \\
\hline
\terminal{\textbackslash0} & \code{U+0000} &
\terminal{\textbackslash{}a} & \code{U+0007} \\
\terminal{\textbackslash{}b} & \code{U+0008} &
\terminal{\textbackslash{}f} & \code{U+000C} \\
\terminal{\textbackslash{}n} & \code{U+000A} &
\terminal{\textbackslash{}r} & \code{U+000D} \\
\terminal{\textbackslash{}t} & \code{U+0009} &
\terminal{\textbackslash{}v} & \code{U+000B} \\
\terminal{\textbackslash\textbackslash} & \code{U+005C} &
\terminal{\textbackslash'} & \code{U+002C} \\
\terminal{\textbackslash"} & \code{U+0022} \\
\end{tabular}

\specsubsection{String constants}

\begin{grammar}
\nonterminaldef{string-constant} \\
	\terminal{"} \nonterminal{string-chars} \terminal{"} \\

\nonterminaldef{string-chars} \\
	\nonterminal{string-char} \optional{\nonterminal{string-chars}} \\

\nonterminaldef{string-char} \\
	\norm{Any character other than \terminal{\textbackslash} or \terminal{"}} \\
	\nonterminal{escape-sequence} \\
\end{grammar}

\specsubsubitem
A \nonterminal{string-constant} expression shall have a result type of
\terminal{const} \terminal{str}.

\specsubsubitem
The string's \textit{data} field shall refer to a UTF-8 encoded sequence of
Unicode codepoints, ascertained by encoding the sequence of
\nonterminal{string-char}s given in order, after interpreting escape codes per
\subsubitemref{Rune constants}{17}.

\specsubsubitem
The \textit{length} and \textit{capacity} fields shall be set to the length in
octets of the encoded UTF-8 data.

\specsubsection{Array literals}

\begin{grammar}
\nonterminaldef{array-literal} \\
	\terminal{[} \nonterminal{array-members} \terminal{]} \\

\nonterminaldef{array-members} \\
	\nonterminal{simple-expression} \optional{\terminal{,}} \\
	\nonterminal{simple-expression} \terminal{...} \optional{\terminal{,}} \\
	\nonterminal{simple-expression} \terminal{,} \nonterminal{array-members} \\
\end{grammar}

Forward references: \subsecref{Simple, complex, and compound expressions}

\specsubsubitem
An \nonterminal{array-literal} expression produces a value of an array type.
The type of each \nonterminal{simple-expression} shall be uniform and shall
determine the member type of the array value, and the length of the array type
shall be defined by the number of members.

\specsubsubitem
The execution environment shall evaluate the \nonterminal{array-members},
ordered such that any side-effects of evaluating the arguments occur in the
order that the members are listed, such that the \textit{N}th member provides
the value for the \textit{N}th array member.

\specsubsubitem
If the \terminal{...} form is used, the result's array type shall be expandable.

\specsubsection{Struct literals}

\begin{grammar}
\nonterminaldef{struct-literal} \\
	\terminal{struct} \terminal{\{} \nonterminal{field-values} \optional{\terminal{,}} \terminal{\}} \\
	\nonterminal{identifier} \terminal{\{} \nonterminal{struct-initializer} \optional{\terminal{,}} \terminal{\}} \\

\nonterminaldef{struct-initializer} \\
	\nonterminal{field-values} \\
	\nonterminal{field-values} \terminal{,} \terminal{...} \\
	\terminal{...} \\

\nonterminaldef{field-values} \\
	\nonterminal{field-value} \\
	\nonterminal{field-values} \terminal{,} \nonterminal{field-value} \\

\nonterminaldef{field-value} \\
	\nonterminal{identifier} \terminal{=} \nonterminal{simple-initializer} \\
	\nonterminal{identifier} \terminal{:} \nonterminal{type} \terminal{=} \nonterminal{initializer} \\
	\nonterminal{struct-literal} \\
\end{grammar}
% TODO: Define initializer and simple-initializer

\specsubsubitem
A \nonterminal{struct-literal} produces a value of a struct type. The first
form is the \textit{plain form}, and the second form is the \textit{named form}.

\specsubsubitem
If the plain form is given, the result type shall be a struct type defined by
the \nonterminal{field-value}s, in order, with their identifiers and types
explicitly specified. The first form of \nonterminal{field-value} shall not be
used in such a struct.

\specsubsubitem
If the named form is given, the \nonterminal{identifier} shall identify a type
alias (see \subsecref{Type aliases}) which refers to a struct type. The result
type shall be this alias type.

\specsubsubitem
If \terminal{...} is not given, \nonterminal{field-values} shall be
\textit{exhaustive}, and include every field of the result type exactly once.
Otherwise, a diagnostic message shall be printed and the translation phase
shall abort.

\specsubsubitem
If \terminal{...} is given, any fields of the result type which are not
included in \nonterminal{field-values} shall be initialized to their default
values.

\specsubsubitem
If the \nonterminal{struct-literal} form of the \nonterminal{field-value} is
given, its fields shall be interpreted as fields of the parent struct.

\informative{The following values are equivalent: \\
\code{struct \{ a: int = 10, b: int = 20 \}} \\
\code{struct \{ a: int = 10, struct \{ b: int = 20 \} \}}}

\specsubsection{Plain expressions}

\begin{grammar}
\nonterminaldef{plain-expression} \\
	\nonterminal{identifier} \\
	\nonterminal{constant} \\
	\nonterminal{array-literal} \\
	\nonterminal{struct-literal} \\

\nonterminaldef{nested-expression} \\
	\nonterminal{plain-expression} \\
	\terminal{(} \nonterminal{complex-expression} \terminal{)} \\
\end{grammar}

Forward references: \subsecref{Simple, complex, and compound expressions}

\specsubsubitem
\nonterminal{plain-expression} is an expression class which represents its
result value "plainly". In the case of constants and literals, the value is
represented by the result of those expressions. In the case of an
\nonterminal{identifier}, the expression produces the value of the identified
object.

\specsubsubitem
\nonterminal{nested-expression} is an expression class provided to allow the
programmer to overcome constraints placed on the valid range of expression
types in certain parts of the grammar, and to overcome undesirable
associativity between operators.

\specsubsection{Calls}

\begin{grammar}
\nonterminaldef{call-expression} \\
	\nonterminal{postfix-expression} \terminal{(} \optional{\nonterminal{argument-list}} \terminal{)} \\

\nonterminaldef{argument-list} \\
	\nonterminal{complex-expression} \optional{\terminal{,}} \\
	\terminal{...} \nonterminal{complex-expression} \optional{\terminal{,}} \\
	\nonterminal{complex-expression} \terminal{,} \nonterminal{argument-list} \\
\end{grammar}

Forward references: \subsecref{Simple, complex, and compound expressions}

\specsubsubitem
A \nonterminal{call-expression} shall invoke a function in the execution
environment and its result shall be a value of the type specified by the
\nonterminal{postfix-expression}'s function result type. This evaluation shall
include any necessary side-effects per \subsubitemref{Program execution}{1}.

\specsubsubitem
The \nonterminal{postfix-expression} shall have a function type which does not
have the \terminal{@init}, \terminal{@fini}, or \terminal{@test} attributes set.

\specsubsubitem
The \nonterminal{argument-list} shall be a list of expressions whose types
shall be assignable to the types of the function's parameters, in the order
that they are declared in the function type.

\specsubsubitem
The execution environment shall evaluate the \nonterminal{argument-list},
ordered such that any side-effects of evaluating the arguments occur in the
order that the arguments are listed, to obtain the parameter values required to
invoke the function.

\specsubsubitem
If the invoked function uses Hare-style variadism, the
\nonterminal{argument-list} shall provide zero or more arguments following the
last non-variadic parameter, all of which must be assignable to the type of the
variadic parameter.

\specsubsubitem
If the final argument uses the \terminal{...} form, it must occupy the position of a
variadic parameter and be of a slice or array type. The implementation shall
interpret this value as the list of variadic parameters.

\specsubsubitem
If the invoked function uses C-style variadism, the function may provide zero
or more arguments following the final parameter. These arguments shall be of a
type with a non-zero size, but are otherwise unconstrained.

\specsubsubitem
The specific means by which the invoked function assumes control of the
execution environment, and by which the arguments are provided to it, is
implementation-defined.

\informative{This is generally provided by the target's ABI specification.}

\specsubsection{Assertions}

\begin{grammar}
\nonterminaldef{assertion-expression} \\
	\terminal{assert} \terminal{(} \nonterminal{simple-expression} \terminal{)} \\
	\terminal{assert} \terminal{(} \nonterminal{simple-expression} \terminal{,} \nonterminal{string-constant} \terminal{)} \\
	\terminal{static} \terminal{assert} \terminal{(} \nonterminal{simple-expression} \terminal{)} \\
	\terminal{static} \terminal{assert} \terminal{(} \nonterminal{simple-expression} \terminal{,} \nonterminal{string-constant} \terminal{)} \\
	\terminal{abort} \terminal{(} \terminal{)} \\
\end{grammar}

Forward references: \subsecref{Simple, complex, and compound expressions}

\specsubsubitem
An \nonterminal{assertion-expression} is used to validate an assumption by the
programmer by \textit{asserting} its truth. The result type of a
\nonterminal{assertion-expression} is \terminal{void}.

\specsubsubitem
\nonterminal{simple-expression} shall be an expression of type
\nonterminal{bool}.

\specsubsubitem
In the first two forms, this expression shall be evaluated
in the execution environment, and if false, a diagnostic message shall be
printed and the execution phase aborted. The programmer may provide the
\nonterminal{string-constant} to be included in the diagnostic message.

\specsubsubitem
In the \terminal{static} form, \nonterminal{simple-expression} shall be limited
to the \subsecref{Translation compatible expression subset}, shall be evaluated
in the translation environment, and is otherwise equivalent to the other forms.

\specsubsubitem
The \terminal{abort} form shall cause the execution environment to print a
diagnostic message and abort. An abort is a terminating expression.

\specsubsection{Measurements}

\begin{grammar}
\nonterminaldef{measurement-expression} \\
	\nonterminal{size-expression} \\
	\nonterminal{length-expression} \\
	\nonterminal{offset-expression} \\

\nonterminaldef{size-expression} \\
	\terminal{size} \terminal{(} \nonterminal{type} \terminal{)} \\

\nonterminaldef{length-expression} \\
	\terminal{len} \terminal{(} \nonterminal{identifier} \terminal{)} \\

\nonterminaldef{offset-expression} \\
	\terminal{offset} \terminal{(} \nonterminal{field-access-expression} \terminal{)} \\
\end{grammar}

Forward references: \subsecref{Field access}

\specsubsubitem
A \nonterminal{measurement-expression} is used to measure objects. The result
type shall be \terminal{size}.

\specsubsubitem
The \terminal{size} expression shall compute the \textit{size} of the specified
\nonterminal{type}.

\specsubsubitem
The \terminal{len} expression shall compute the \textit{length} of a bounded
array, or the \code{length} field of a slice object, referred to by
\nonterminal{identifier}. If an unbounded array object is given, the
translation environment shall print a diagnostic message and abort.

\specsubsubitem
The \terminal{offset} expression shall determine the struct field which would be
accessed by \nonterminal{field-access-expression} and compute its
\textit{offset}.

\specsubsection{Field access}

\begin{grammar}
\nonterminaldef{field-access-expression} \\
	\nonterminal{postfix-expression} \terminal{.} \nonterminal{name} \\
\end{grammar}

\specsubitem
A \nonterminal{field-access-expression} is used to access fields of
\subsecref{Struct and union types}. The result type of the
\nonterminal{postfix-expression} shall be a struct type or a union type.

\specsubitem
If the \nonterminal{postfix-expression}'s result type is a union type, the
result of the \nonterminal{field-access-expression} shall be the union's storage
area interpreted as the type of the field named by \nonterminal{name}, and the
result type of the expression shall be the type of the named field.

\specsubitem
If the \nonterminal{postfix-expression}'s result type is a struct type,
the result of the \nonterminal{field-access-expression} shall be the value
stored in the \nonterminal{name} field of the result of the
\nonterminal{postfix-expression}, and the result type of the expression shall be
the type of the named field.

\specsubsection{Indexing}

\begin{grammar}
\nonterminaldef{indexing-expression} \\
	\nonterminal{postfix-expression} \terminal{[} \nonterminal{simple-expression} \terminal{]} \\
\end{grammar}

\specsubsubitem
An \nonterminal{indexing-expression} shall access a specific value of a slice
or array type. The \nonterminal{postfix-expression} shall have a result type of
slice or array, and the \nonterminal{simple-expression} shall have a result
type which is assignable to \nonterminal{size}.

\specsubsubitem
The result type of an \nonterminal{indexing-expression} is the secondary type
of the slice or array type given by the \nonterminal{postfix-expression} result
type.

\specsubsubitem
The execution environment shall compute the result of
\nonterminal{simple-expression} to obtain $N$ for selecting the \textit{N} per
the algorithm given in \subsecref{Slice and array types}.

\specsubsubitem
The execution environment shall perform a \textit{bounds test} on the value of
$N$ to ensure it falls within the acceptable range for the given slice or array
type. It shall test that $N < Z$, where $Z$ is the length of the bounded array
type, or the \code{length} field of the slice, whichever is appropriate.  For
unbounded array types, the bounds test shall not occur. If the bounds test
fails, a diagnostic message shall be printed and the execution environment
shall abort.

The implementation may perform a bounds test in the translation environment if
is able, print a diagnostic message, and abort the translation environment if
it fails.

\specsubsection{Slicing}

\begin{grammar}
\nonterminaldef{slicing-expression} \\
	\nonterminal{postfix-expression} \terminal{[} \optional{\nonterminal{simple-expression}} \terminal{..} \optional{\nonterminal{simple-expression}} \terminal{]} \\
\end{grammar}

\specsubsubitem
A \nonterminal{slicing-expression} shall have a result type of
\nonterminal{slice}, which is computed a subset of a slice or array object.
\nonterminal{postfix-expression} shall be of a slice or array type, and the
optional \nonterminal{simple-expression}s shall be assignable to
\nonterminal{size}.

\specsubsubitem
The first \nonterminal{simple-expression} shall compute value $L$, and the
second shall compute $H$. If absent, $L = 0$ and $H = \code{length}$, where
\code{length} shall be equal to the length of a bounded array type or the
length of a slice type, represented in either case by the result of
\nonterminal{postfix-expression}. If $H$ is not specified, and
\nonterminal{postfix-expression} is of an unbounded array type, the translation
environment shall abort.

\specsubsubitem
The resulting slice value shall have its \code{data} field set from, in the case
of an array type, the address of the array; or in the case of a slice type, the
\code{data} value of the source object; plus $L \times S$, where $S$ is the
size of the slice or array's secondary type.

\specsubsubitem
The resulting slice value shall have its \code{length} and \code{capacity}
fields set to $H - L$.

\specsubsubitem
The secondary type of the resulting slice type shall be equivalent to the
secondary type of the slice or array type given by
\nonterminal{postfix-expression}. The resulting slice type shall inherit the
\nonterminal{const} attribute from this type.

\specsubsection{Postfix expressions}

\begin{grammar}
\nonterminaldef{postfix-expression} \\
	\nonterminal{nested-expression} \\
	\nonterminal{assertion-expression} \\
	\nonterminal{call-expression} \\
	\nonterminal{field-access-expression} \\
	\nonterminal{indexing-expression} \\
	\nonterminal{measurement-expression} \\
	\nonterminal{slicing-expression} \\
\end{grammar}

\specsubsubitem
\nonterminal{postfix-expression} is an expression class for expressions whose
operators use postfix notation.

\specsubsection{Unary arithmetic}

\begin{grammar}
\nonterminaldef{unary-expression} \\
	\nonterminal{postfix-expression} \\
	\nonterminal{unary-operator} \nonterminal{unary-expression} \\

\nonterminaldef{unary-operator} \oneof \\
	\terminal{+}
	\terminal{-}
	\terminal{\textasciitilde}
	\terminal{!}
	\terminal{*}
	\terminal{\&}
\end{grammar}

% TODO: Consider removing unary +

\specsubsubitem
A unary expression applies a \nonterminal{unary-operator} to a single value.

\specsubsubitem
The \terminal{+} and \terminal{-} operators shall respectively perform unary
positive and unary negation operations. The result type shall be equivalent to
the type of \nonterminal{unary-expression}, which shall be of a signed numeric
type.

\specsubsubitem
The \terminal{\textasciitilde} operator shall perform a binary NOT operation,
inverting each bit of the value. Its result type shall be equivalent to the
type of \nonterminal{unary-expression}, which shall be of an unsigned integer
type.

\specsubsubitem
The \terminal{!} operator shall perform a logical NOT operation. The result
type, and the type of \nonterminal{unary-expression}, shall both be
\terminal{bool}. If the \nonterminal{unary-expression} is \terminal{true}, the
result shall be \terminal{false}, and vice-versa.

\specsubsubitem
The \terminal{*} operator shall dereference a pointer, and return the object it
references.  The type of \nonterminal{unary-expression} shall be a pointer
type, and the result type shall be the pointer's secondary type. The pointer
type shall not be \textit{nullable}.

\specsubsubitem
The \terminal{\&} operator shall take the address of an object. The result type
shall be a pointer whose secondary type is the type of
\nonterminal{unary-expression}.

\informative{The following table is informative.}

\begin{tabular}{r | l }
Operator & Meaning \\
\hline
\terminal{+} & Positive \\
\terminal{-} & Negation \\
\terminal{\textasciitilde} & Binary NOT \\
\terminal{!} & Logical NOT \\
\terminal{*} & Dereference pointer \\
\terminal{\&} & Take address \\
\end{tabular}

\specsubsection{Casts and type assertions}

\begin{grammar}
\nonterminaldef{cast-expression} \\
	\nonterminal{unary-expression} \\
	\nonterminal{cast-expression} \terminal{:} \nonterminal{type} \\
	\nonterminal{cast-expression} \terminal{as} \nonterminal{type} \\
	\nonterminal{cast-expression} \terminal{is} \nonterminal{type} \\
\end{grammar}

\specsubsubitem
A cast expression interrogates or converts the type of an object. The first
form illustrates the precedence. The second and third forms (\terminal{:} and
\terminal{as}) have a result type specified by the \nonterminal{type}; and the
fourth form (\terminal{is}) has a result type of \terminal{bool}.

\specsubsubitem
The second form is a \textit{type cast}, and is only valid for a combination of
\textit{source types} and \textit{destination types} which are specified by the
following table:

\begin{tabular}{r | l}
Source type & Casts to \\
\hline
Floating types & Any numeric type \\
Integer types & Any numeric type or enum type, or \terminal{uintptr} \\
\terminal{bool}, \terminal{null}, \terminal{void} & Cannot be cast \\
\terminal{char} & \terminal{u8} \\
\terminal{str} & \terminal{*} \terminal{char} \\
\terminal{uintptr} & Any pointer type or any integer type \\
Any pointer type & Any pointer type or \terminal{uintptr} \\
Enum types & Any enum type or numeric type \\
Struct \& union types & Cannot be cast \\
Tagged unions & See notes \\
Type alias & Any type the underlying type could cast to \\
\end{tabular}

Tagged union types are mutually castable with any type which is found among its
members, including the otherwise non-castable types of \terminal{bool} and
\terminal{void}.

A type which may be cast to another type is considered \textit{castable} to
that type.

\specsubsubitem
When an integer type is cast to an integer of less precision, it shall be
truncated towards the least significant bit.

\specsubsubitem
When a signed type is cast to a unsigned type, the sign bit shall be copied to
the most significant bit of the unsigned type, and vice versa.

\specsubsubitem
When a floating type is cast to an integer, the resulting value shall be equal
to $I = \lfloor F \rfloor$, where F is the source value. If the destination type
has insufficient precision to represent $I$, it shall be truncated towards the
least significant bit.

\specsubsubitem
When casting an integer to a floating point type, if the destination type
lacks the precision to represent the value, it shall be truncated towards zero.

\specsubsubitem
Casting a pointer type to \nonterminal{uintptr}, and then back to the pointer
type, shall yield the same pointer.

\informative{However, casting \nonterminal{uintptr} to any other integer type
and back again may truncate towards the least significant bit and is not
guaranteed to yield the same pointer.}

\specsubsubitem
Casting a \terminal{str} to \terminal{*} \terminal{char} is a special case; it
is equivalent to casting the string's \textit{data} field to \terminal{*}
\terminal{char}.

\specsubsubitem
The third form is a \textit{type assertion}. In this form,
\nonterminal{cast-expression} shall be of a tagged union type, and
\nonterminal{type} shall be a constituent type of that tagged union. The
\nonterminal{cast-expression} shall be computed, and if the tag does not match
\nonterminal{type}, a diagnostic message shall be printed and the execution
environment shall abort. Otherwise, the result type is \nonterminal{type}.

\specsubsubitem
The fourth form is a \textit{type test}. In this form,
\nonterminal{cast-expression} shall be of a tagged union type, and
\nonterminal{type} shall be a constituent type of that tagged union. The result
type is \terminal{bool}, and shall be \terminal{true} if the selected tag of
\nonterminal{cast-expression} is \nonterminal{type}, or \terminal{false}
otherwise.

\specsubsection{Multiplicative arithmetic}

\begin{grammar}
\nonterminaldef{multiplicative-expression} \\
	\nonterminal{cast-expression} \\
	\nonterminal{multiplicative-expression} \terminal{*} \nonterminal{cast-expression} \\
	\nonterminal{multiplicative-expression} \terminal{/} \nonterminal{cast-expression} \\
	\nonterminal{multiplicative-expression} \terminal{\%} \nonterminal{cast-expression} \\
\end{grammar}

\specsubsubitem
A \nonterminal{multiplicative-expression} multiplies (\terminal{*}), divides
(\terminal{/}), or obtains the remainder between (\terminal{\%}) two
expressions. The first form illustrates the precedence. The types of the
operands, and the result type, are determined per the \subsecref{Type promotion}
rules.

\specsubsubitem
In the case of division or modulus, the first term is the dividend, and the
second term is the divisor.

\specsubsubitem
A modulus (\terminal{\%}) operation shall be performed with operands of integer
types only.

\specsubsubitem
If an operation would cause the result to overflow the result type, it is
truncated towards the least significant bits in the case of integer types, and
towards zero in the case of float types. Integer divisions which would produce
a fractional part are floored.

\specsubsection{Additive arithmetic}

\begin{grammar}
\nonterminaldef{additive-expression} \\
	\nonterminal{multiplicative-expression} \\
	\nonterminal{additive-expression} \terminal{+} \nonterminal{multiplicative-expression} \\
	\nonterminal{additive-expression} \terminal{-} \nonterminal{multiplicative-expression} \\
\end{grammar}

\specsubsubitem
An \nonterminal{additive-expression} adds (\terminal{+}) two operands, or
subtracts (\terminal{-}) one from another. The first form illustrates the
precedence. The types of the operands, and the result type, are determined per
the \subsecref{Type promotion} rules.

\specsubsubitem
In the case of subtraction, the first term is the minuend, and the second term
is the subtrahend.

\specsubsubitem
If an operation would cause the result to overflow or underflow the result
type, it is truncated towards the least significant bits in the case of integer
types, and towards zero in the case of float types. In the case of signed
types, this truncation will cause the sign bit to change.

\specsubsection{Bit shifting arithmetic}

\begin{grammar}
\nonterminaldef{shift-expression} \\
	\nonterminal{additive-expression} \\
	\nonterminal{shift-expression} \terminal{\textless{}\textless{}} \nonterminal{additive-expression} \\
	\nonterminal{shift-expression} \terminal{\textgreater{}\textgreater{}} \nonterminal{additive-expression} \\
\end{grammar}

\specsubsubitem
A \nonterminal{shift-expression} performs a bitwise left-shift
(\terminal{\textless{}\textless{}}) or right-shift (\terminal{\textgreater{}\textgreater{}}). The first
form illustrates the precedence. The result type shall be the type of the first
operand. Both operands shall be of unsigned integer types.

\specsubsubitem
\code{\nonterminal{shift-expression} \terminal{\textless{}\textless{}} $N$} shall shift
each bit towards the most significant bit $N$ places, and set the least
significant $N$ bits to zero. The $N$ most significant bits shall be silently
discarded. If $N$ is greater than the size in bits of the type, the result shall
be zero.

\informative{This operation is equivalent to multiplying
\nonterminal{shift-expression} by $2^N$}

\specsubsubitem
\code{\nonterminal{shift-expression} \terminal{\textgreater{}\textgreater{}} $N$} shall shift
each bit towards the least significant bit $N$ places, and set the most
significant $N$ bits to zero. The $N$ least significant bits shall be silently
discarded. If $N$ is greater than the size in bits of the type, the result shall
be zero.

\informative{This operation is equivalent to dividing
\nonterminal{shift-expression} by $2^N$}

\specsubsection{Relational arithmetic}

\specsubsection{Equality}

\specsubsection{Bitwise arithmetic}

\specsubsection{Logical arithmetic}

\specsubsection{Scope expressions}

\specsubsection{If expressions}

\begin{grammar}
\nonterminaldef{if-expression} \\
	\terminal{if} \nonterminal{conditional-branch} \\
	\terminal{if} \nonterminal{conditional-branch} \terminal{else} \nonterminal{conditional-branch} \\
	\terminal{if} \nonterminal{conditional-branch} \terminal{else} \nonterminal{if-expression} \\

\nonterminaldef{conditional-branch} \\
	\terminal{(} \nonterminal{complex-expression} \terminal{)} \nonterminal{compound-expression} \\
\end{grammar}

\specsubsection{For loops}

\specsubsection{While loops}

\specsubsection{Match expressions}

\specsubsection{Switch expressions}

\specsubsection{Assignment}

\specsubsection{Variable binding}

\specsubsection{Expression lists}

\begin{grammar}
\nonterminaldef{expression-list} \\
	\terminal{\{} \nonterminal{expressions} \terminal{\}} \\

\nonterminaldef{expressions} \\
	\nonterminal{scope-expression} \terminal{;} \\
	\nonterminal{scope-expression} \terminal{;} \nonterminal{expressions} \\
\end{grammar}

\specsubsubitem
A \nonterminal{expression-list} evaluates any number of
\nonterminal{scope-expression}s in sequence. The result of the
\nonterminal{expression-list} shall be the result of the final
\nonterminal{scope-expression}.

\specsubsection{Control statements}

\begin{grammar}
\nonterminaldef{control-statement} \\
	\terminal{break} \\
	\terminal{continue} \\
	\terminal{return} \optional{\nonterminal{complex-expression}} \\
\end{grammar}

\specsubsection{High-level expression classes}

\begin{grammar}
\nonterminaldef{simple-expression} \\
	\nonterminal{logical-or-expression} \\

\nonterminaldef{complex-expression} \\
	\nonterminal{simple-expression} \\
	\nonterminal{if-expression} \\
	\nonterminal{for-expression} \\
	\nonterminal{while-expression} \\
	\nonterminal{match-expression} \\
	\nonterminal{switch-expression} \\

\nonterminaldef{scope-expression} \\
	\nonterminal{binding} \\
	\nonterminal{complex-expression} \\
	\nonterminal{allocation-expression} \\
	\nonterminal{assignment-expression} \\

\nonterminaldef{compound-expression} \\
	\nonterminal{simple-expression} \\
	\terminal{\{} \nonterminal{expression-list} \terminal{\}} \\
	\terminal{\{} \nonterminal{control-statement} \terminal{;} \terminal{\}} \\
	\terminal{\{} \nonterminal{expression-list} \terminal{;} \nonterminal{control-statement} \terminal{;} \terminal{\}} \\
\end{grammar}

\specsubsubitem
\nonterminal{simple-expression}, \nonterminal{complex-expression},
\nonterminal{scope-expression}, and \nonterminal{compound-expression} are
high-level expression classes which are used to classify the kinds of
expressions which are available in specific situations.

\informative{
\nonterminal{simple-expression} and \nonterminal{complex-expression} are
available in most circumstances. A simple expression can encapsulate a
complex-expression via \nonterminal{nested-expression} should the programmer
consider themselves wiser than the language designer, but generally speaking a
simple-expression will not branch or alter control flow.
}

\informative{
\nonterminal{scope-expression} is available in context where new objects may
be defined (\nonterminal{binding}, \nonterminal{allocation-expression}) and
mutated (\nonterminal{assignment-expression}).
}

\informative{
\nonterminal{compound-expression} is used for lists of expressions evaluated in
sequence, and expands the classification to include
\nonterminal{control-statements}, which are used to influence the flow of
expression evaluation within the sequence.
}
