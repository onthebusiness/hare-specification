\specsection{Expressions}

\specsubitem
An expression is a procedure which the implementation may perform to obtain a
\textit{result}, and possibly cause side-effects (see
\subsubitemref{Program execution}{1}).

\specsubitem
Expression types are organized into a number of classes and subclasses of
expressions which define the contexts in which each expression type is
applicable.

\specsubitem
All expressions have a defined \textit{result type}. It may be \terminal{void}.

\specsubitem
Some expressions \textit{terminate}. The semantics of terminating expressions
vary between different expression types, and will be detailed as appropriate.
If unspecified, expressions described by this expression are presumed to be
non-terminating.

\specsubsection{Constants}

\begin{grammar}
\nonterminaldef{constant} \\
	\nonterminal{integer-constant} \\
	\nonterminal{floating-constant} \\
	\nonterminal{rune-constant} \\
	\nonterminal{string-constant} \\
	\terminal{true} \\
	\terminal{false} \\
	\terminal{null} \\
	\terminal{void} \\
\end{grammar}

\specsubsubitem
Constants (also known as literals) shall describe a specific value of an
unambiguous type. The result of the expression is the constant value.

\specsubsubitem
The keywords \terminal{true} and \terminal{false} respectively represent
the constants of the \terminal{bool} type.

\specsubsubitem
The representation of \terminal{true} as an \terminal{uint}-equivalent (ref
\subsubitemref{Other primitive types}{2}) shall be one.

\specsubsubitem
The \terminal{null} keyword represents the \terminal{null} value of the
\terminal{null} type.

\specsubsubitem
The \terminal{void} keyword represents the \terminal{void} value of the
\terminal{void} type.

\specsubsection{Floating constants}

\begin{grammar}
\nonterminaldef{floating-constant} \\
	\nonterminal{decimal-digits} \terminal{.} \nonterminal{decimal-digits} \optional{\nonterminal{exponent}} \optional{\nonterminal{floating-suffix}} \\
	\nonterminal{decimal-digits} \optional{\nonterminal{exponent}} \nonterminal{floating-suffix} \\

\nonterminaldef{floating-suffix} \oneof \\
	\terminal{f32}
	\terminal{f64} \\

\nonterminaldef{decimal-digits} \\
	\nonterminal{decimal-digit} \optional{\nonterminal{decimal-digits}} \\

\nonterminaldef{decimal-digit} \oneof \\
	\terminal{0}
	\terminal{1}
	\terminal{2}
	\terminal{3}
	\terminal{4}
	\terminal{5}
	\terminal{6}
	\terminal{7}
	\terminal{8}
	\terminal{9} \\

\nonterminaldef{exponent} \\
	\terminal{e} \nonterminal{decimal-digits} \\
\end{grammar}

% TODO: consider using magic precision numeric constants which assume
% their type from context

Floating constants represent an IEEE 754-compatible floating-point
number in either the binary32 or binary64 format.

\specsubitem
If the \nonterminal{floating-suffix} is not provided, the type shall be
\terminal{f64}. Otherwise, the type shall refer to the type named by the suffix.

\specsubitem
If the \nonterminal{exponent} is provided, the value of the
constant shall be multiplied by 10 to the power of
\nonterminal{decimal-digits}.

\specsubsection{Integer constants}

\begin{grammar}
\nonterminaldef{integer-constant} \\
	\terminal{0x} \nonterminal{hex-digits} \optional{\nonterminal{integer-suffix}} \\
	\terminal{0o} \nonterminal{octal-digits} \optional{\nonterminal{integer-suffix}} \\
	\terminal{0b} \nonterminal{binary-digits} \optional{\nonterminal{integer-suffix}} \\
	\nonterminal{decimal-digits} \optional{\nonterminal{exponent}}
		\optional{\nonterminal{integer-suffix}} \\

\nonterminaldef{hex-digits} \\
	\nonterminal{hex-digit} \optional{\nonterminal{hex-digits}} \\

\nonterminaldef{hex-digit} \oneof \\
	\terminal{0}
	\terminal{1}
	\terminal{2}
	\terminal{3}
	\terminal{4}
	\terminal{5}
	\terminal{6}
	\terminal{7}
	\terminal{8}
	\terminal{9}
	\terminal{A}
	\terminal{B}
	\terminal{C}
	\terminal{D}
	\terminal{E}
	\terminal{F}
	\terminal{a}
	\terminal{b}
	\terminal{c}
	\terminal{d}
	\terminal{e}
	\terminal{f} \\

\nonterminaldef{octal-digits} \\
	\nonterminal{octal-digit} \optional{\nonterminal{octal-digits}} \\

\nonterminaldef{octal-digit} \oneof \\
	\terminal{0}
	\terminal{1}
	\terminal{2}
	\terminal{3}
	\terminal{4}
	\terminal{5}
	\terminal{6}
	\terminal{7} \\

\nonterminaldef{binary-digits} \\
	\nonterminal{binary-digit} \optional{\nonterminal{binary-digits}} \\

\nonterminaldef{binary-digit} \oneof \\
	\terminal{0}
	\terminal{1} \\

\nonterminaldef{integer-suffix} \oneof \\
	\terminal{i}
	\terminal{u}
	\terminal{z}
	\terminal{i8}
	\terminal{i16}
	\terminal{i32}
	\terminal{i64}
	\terminal{u8}
	\terminal{u16}
	\terminal{u32}
	\terminal{u64} \\
\end{grammar}

% TODO: Consider using magic precision numeric constants which assume their
% type from context

Integer constants represent an integer value at a specific precision.

\specsubitem
If the \nonterminal{integer-suffix} is not provided, the type shall be
\terminal{int}.  Otherwise, the type is specified by the suffix. Suffixes
\terminal{i}, \terminal{u},  and \terminal{z} shall respectively refer to the
\terminal{int}, \terminal{uint}, and \terminal{size} types; the remainder shall
refer to the type named by the suffix.

\specsubitem
If the number provided is not within the limits of the precision of the
constant type, a diagnostic message shall be printed and the translation phase
shall fail.

\specsubitem
The prefixes \terminal{0x}, \terminal{0o}, and \terminal{0b} shall respectively
cause the number to be interpreted with a hexadecimal, octal, or binary base.
If no prefix is used, the number shall be interpreted with a decimal base.

\specsubitem
If the \nonterminal{exponent} is provided, the value of the
integer shall be multiplied by 10 to the power of \nonterminal{decimal-digits}.

\specsubsection{Rune constants}
\begin{grammar}
\nonterminaldef{rune-constant} \\
	\terminal{'} \nonterminal{rune} \terminal{'} \\

\nonterminaldef{rune} \\
	\norm{Any character other than \terminal{\textbackslash} or \terminal{'}} \\
	\nonterminal{escape-sequence} \\

\nonterminaldef{escape-sequence} \\
	\nonterminal{named-escape} \\
	\terminal{\textbackslash{}x} \nonterminal{hex-digit} \nonterminal{hex-digit} \\
	\terminal{\textbackslash{}u} \nonterminal{hex-digit} \nonterminal{hex-digit} \nonterminal{hex-digit} \nonterminal{hex-digit} \\

\nonterminaldef{named-escape} \oneof \\
	\terminal{\textbackslash0}
	\terminal{\textbackslash{}a}
	\terminal{\textbackslash{}b}
	\terminal{\textbackslash{}f}
	\terminal{\textbackslash{}n}
	\terminal{\textbackslash{}r}
	\terminal{\textbackslash{}t}
	\terminal{\textbackslash{}v}
	\terminal{\textbackslash\textbackslash}
	\terminal{\textbackslash'}
	\terminal{\textbackslash"} \\
\end{grammar}

% TODO: Describe representation of rune types

\specsubitem
If the \nonterminal{rune-constant} is not an \nonterminal{escape-sequence}, the
value of the rune shall be the Unicode codepoint representing
\nonterminal{rune}.

\specsubitem
A \nonterminal{rune-constant} beginning with \terminal{\textbackslash{}x} or
\terminal{\textbackslash{}u} shall interpet its value as a Unicode codepoint
specified in its hexadecimal representation by \nonterminal{hex-digit}s.

\specsubitem
A \nonterminal{rune-constant} containing a \nonterminal{named-escape} shall have
a value based on the following chart:

\begin{tabular}{r | l | r | l}
Escape sequence & Unicode codepoint & Escape sequence & Unicode codepoint \\
\hline
\terminal{\textbackslash0} & \code{U+0000} &
\terminal{\textbackslash{}a} & \code{U+0007} \\
\terminal{\textbackslash{}b} & \code{U+0008} &
\terminal{\textbackslash{}f} & \code{U+000C} \\
\terminal{\textbackslash{}n} & \code{U+000A} &
\terminal{\textbackslash{}r} & \code{U+000D} \\
\terminal{\textbackslash{}t} & \code{U+0009} &
\terminal{\textbackslash{}v} & \code{U+000B} \\
\terminal{\textbackslash\textbackslash} & \code{U+005C} &
\terminal{\textbackslash'} & \code{U+002C} \\
\terminal{\textbackslash"} & \code{U+0022} \\
\end{tabular}

\specsubsection{String constants}

\begin{grammar}
\nonterminaldef{string-constant} \\
	\terminal{"} \nonterminal{string-chars} \terminal{"} \\

\nonterminaldef{string-chars} \\
	\nonterminal{string-char} \optional{\nonterminal{string-chars}} \\

\nonterminaldef{string-char} \\
	\norm{Any character other than \terminal{\textbackslash} or \terminal{"}} \\
	\nonterminal{escape-sequence} \\
\end{grammar}

\specsubsection{Array literals}

\begin{grammar}
\nonterminaldef{array-literal} \\
	\terminal{[} \nonterminal{array-members} \terminal{]} \\

\nonterminaldef{array-members} \\
	\nonterminal{simple-expression} \optional{\terminal{,}} \\
	\nonterminal{simple-expression} \terminal{...} \optional{\terminal{,}} \\
	\nonterminal{simple-expression} \terminal{,} \nonterminal{array-members} \\
\end{grammar}

Forward references: \subsecref{Simple, complex, and compound expressions}

\specsubsubitem
An \nonterminal{array-literal} expression produces a value of an array type.
The type of each \nonterminal{simple-expression} shall be uniform and shall
determine the member type of the array value, and the length of the array type
shall be defined by the number of members.

\specsubsubitem
The execution environment shall evaluate the \nonterminal{array-members},
ordered such that any side-effects of evaluating the arguments occur in the
order that the members are listed, such that the \textit{N}th member provides
the value for the \textit{N}th array member.

\specsubsubitem
If the \terminal{...} form is used, the result's array type shall be expandable.

\specsubsection{Struct literals}

\begin{grammar}
\nonterminaldef{struct-literal} \\
	\terminal{struct} \terminal{\{} \nonterminal{field-values} \optional{\terminal{,}} \terminal{\}} \\
	\nonterminal{identifier} \terminal{\{} \nonterminal{struct-initializer} \optional{\terminal{,}} \terminal{\}} \\

\nonterminaldef{struct-initializer} \\
	\nonterminal{field-values} \\
	\nonterminal{field-values} \terminal{,} \terminal{...} \\
	\terminal{...} \\

\nonterminaldef{field-values} \\
	\nonterminal{field-value} \\
	\nonterminal{field-values} \terminal{,} \nonterminal{field-value} \\

\nonterminaldef{field-value} \\
	\nonterminal{identifier} \terminal{=} \nonterminal{simple-initializer} \\
	\nonterminal{identifier} \terminal{:} \nonterminal{type} \terminal{=} \nonterminal{initializer} \\
	\nonterminal{struct-literal} \\
\end{grammar}
% TODO: Define initializer and simple-initializer

\specsubsubitem
A \nonterminal{struct-literal} produces a value of a struct type. The first
form is the \textit{plain form}, and the second form is the \textit{named form}.

\specsubsubitem
If the plain form is given, the result type shall be a struct type defined by
the \nonterminal{field-value}s, in order, with their identifiers and types
explicitly specified. The first form of \nonterminal{field-value} shall not be
used in such a struct.

\specsubsubitem
If the named form is given, the \nonterminal{identifier} shall identify a type
alias (see \subsecref{Type aliases}) which refers to a struct type. The result
type shall be this alias type.

\specsubsubitem
If \terminal{...} is not given, \nonterminal{field-values} shall be
\textit{exhaustive}, and include every field of the result type exactly once.
Otherwise, a diagnostic message shall be printed and the translation phase
shall abort.

\specsubsubitem
If \terminal{...} is given, any fields of the result type which are not
included in \nonterminal{field-values} shall be initialized to their default
values.

\specsubsubitem
If the \nonterminal{struct-literal} form of the \nonterminal{field-value} is
given, its fields shall be interpreted as fields of the parent struct.

\informative{The following values are equivalent: \\
\code{struct \{ a: int = 10, b: int = 20 \}} \\
\code{struct \{ a: int = 10, struct \{ b: int = 20 \} \}}}

\specsubsection{Plain expressions}

\begin{grammar}
\nonterminaldef{plain-expression} \\
	\nonterminal{identifier} \\
	\nonterminal{constant} \\
	\nonterminal{array-literal} \\
	\nonterminal{struct-literal} \\

\nonterminaldef{nested-expression} \\
	\nonterminal{plain-expression} \\
	\terminal{(} \nonterminal{complex-expression} \terminal{)} \\
\end{grammar}

Forward references: \subsecref{Simple, complex, and compound expressions}

\specsubsubitem
\nonterminal{plain-expression} is an expression class which represents its
result value "plainly". In the case of constants and literals, the value is
represented by the result of those expressions. In the case of an
\nonterminal{identifier}, the expression produces the value of the identified
object.

\specsubsubitem
\nonterminal{nested-expression} is an expression class provided to allow the
programmer to overcome constraints placed on the valid range of expression
types in certain parts of the grammar, and to overcome undesirable
associativity between operators.

\specsubsection{Calls}

\begin{grammar}
\nonterminaldef{call-expression} \\
	\nonterminal{postfix-expression} \terminal{(} \optional{\nonterminal{argument-list}} \terminal{)} \\

\nonterminaldef{argument-list} \\
	\nonterminal{complex-expression} \optional{\terminal{,}} \\
	\terminal{...} \nonterminal{complex-expression} \optional{\terminal{,}} \\
	\nonterminal{complex-expression} \terminal{,} \nonterminal{argument-list} \\
\end{grammar}

Forward references: \subsecref{Simple, complex, and compound expressions}

\specsubsubitem
A \nonterminal{call-expression} shall invoke a function in the execution
environment and its result shall be a value of the type specified by the
\nonterminal{postfix-expression}'s function result type. This evaluation shall
include any necessary side-effects per \subsubitemref{Program execution}{1}.

\specsubsubitem
The \nonterminal{argument-list} shall be a list of expressions whose types
shall be assignable to the types of the function's parameters, in the order
that they are declared in the function type.

\specsubsubitem
The execution environment shall evaluate the \nonterminal{argument-list},
ordered such that any side-effects of evaluating the arguments occur in the
order that the arguments are listed, to obtain the parameter values required to
invoke the function.

\specsubsubitem
If the invoked function uses Hare-style variadism, the
\nonterminal{argument-list} shall provide zero or more arguments following the
last non-variadic parameter, all of which must be assignable to the type of the
variadic parameter.

\specsubsubitem
If the final argument uses the \terminal{...} form, it must occupy the position of a
variadic parameter and be of a slice or array type. The implementation shall
interpret this value as the list of variadic parameters.

\specsubsubitem
If the invoked function uses C-style variadism, the function may provide zero
or more arguments following the final parameter. These arguments shall be of a
type with a non-zero size, but are otherwise unconstrained.

\specsubsubitem
The specific means by which the invoked function assumes control of the
execution environment, and by which the arguments are provided to it, is
implementation-defined.

\informative{This is generally provided by the target's ABI specification.}

\specsubsection{Assertions}

\begin{grammar}
\nonterminaldef{assertion-expression} \\
	\terminal{assert} \terminal{(} \nonterminal{simple-expression} \terminal{)} \\
	\terminal{assert} \terminal{(} \nonterminal{simple-expression} \terminal{,} \nonterminal{string-constant} \terminal{)} \\
	\terminal{static} \terminal{assert} \terminal{(} \nonterminal{simple-expression} \terminal{)} \\
	\terminal{static} \terminal{assert} \terminal{(} \nonterminal{simple-expression} \terminal{,} \nonterminal{string-constant} \terminal{)} \\
\end{grammar}

Forward references: \subsecref{Simple, complex, and compound expressions}

\specsubsubitem
An \nonterminal{assertion-expression} is used to validate an assumption by the
programmer by \textit{asserting} its truth. The result type of a
\nonterminal{assertion-expression} is \terminal{void}.

\specsubsubitem
\nonterminal{simple-expression} shall be an expression of type
\nonterminal{bool}.

\specsubsubitem
In the first two forms, this expression shall be evaluated
in the execution environment, and if false, a diagnostic message shall be
printed and the execution phase aborted. The programmer may provide the
\nonterminal{string-constant} to be included in the diagnostic message.

\specsubsubitem
In the \terminal{static} form, \nonterminal{simple-expression} shall be limited
to the \subsecref{Translation compatible expression subset}, shall be evaluated
in the translation environment, and is otherwise equivalent to the other forms.

\specsubsection{Measurements}

\begin{grammar}
\nonterminaldef{measurement-expression} \\
	\nonterminal{size-expression} \\
	\nonterminal{length-expression} \\
	\nonterminal{offset-expression} \\

\nonterminaldef{size-expression} \\
	\terminal{size} \terminal{(} \nonterminal{type} \terminal{)} \\

\nonterminaldef{length-expression} \\
	\terminal{len} \terminal{(} \nonterminal{identifier} \terminal{)} \\

\nonterminaldef{offset-expression} \\
	\terminal{offset} \terminal{(} \nonterminal{field-access-expression} \terminal{)} \\
\end{grammar}

Forward references: \subsecref{Field access}

\specsubsubitem
A \nonterminal{measurement-expression} is used to measure objects. The result
type shall be \terminal{size}.

\specsubsubitem
The \terminal{size} expression shall compute the \textit{size} of the specified
\nonterminal{type}.

\specsubsubitem
The \terminal{len} expression shall compute the \textit{length} of a bounded
array, or the \code{length} field of a slice object, referred to by
\nonterminal{identifier}. If an unbounded array object is given, the
translation environment shall print a diagnostic message and abort.

\specsubsubitem
The \terminal{offset} expression shall determine the struct field which would be
accessed by \nonterminal{field-access-expression} and compute its
\textit{offset}.

\specsubsection{Field access}

\specsubsection{Indexing}

\begin{grammar}
\nonterminaldef{indexing-expression} \\
	\nonterminal{postfix-expression} \terminal{[} \nonterminal{simple-expression} \terminal{]} \\
\end{grammar}

\specsubsubitem
An \nonterminal{indexing-expression} shall access a specific value of a slice
or array type. The \nonterminal{postfix-expression} shall have a result type of
slice or array, and the \nonterminal{simple-expression} shall have a result
type which is assignable to \nonterminal{size}.

\specsubsubitem
The result type of an \nonterminal{indexing-expression} is the secondary type
of the slice or array type given by the \nonterminal{postfix-expression} result
type.

\specsubsubitem
The execution environment shall compute the result of
\nonterminal{simple-expression} to obtain $N$ for selecting the \textit{N} per
the algorithm given in \subsecref{Slice and array types}.

\specsubsubitem
The execution environment shall perform a \textit{bounds test} on the value of
$N$ to ensure it falls within the acceptable range for the given slice or array
type. It shall test that $N < Z$, where $Z$ is the length of the bounded array
type, or the \code{length} field of the slice, whichever is appropriate.  For
unbounded array types, the bounds test shall not occur. If the bounds test
fails, a diagnostic message shall be printed and the execution environment
shall abort.

The implementation may perform a bounds test in the translation environment if
is able, print a diagnostic message, and abort the translation environment if
it fails.

\specsubsection{Slicing}

\begin{grammar}
\nonterminaldef{slicing-expression} \\
	\nonterminal{postfix-expression} \terminal{[} \optional{\nonterminal{simple-expression}} \terminal{..} \optional{\nonterminal{simple-expression}} \terminal{]} \\
\end{grammar}

\specsubsubitem
A \nonterminal{slicing-expression} shall have a result type of
\nonterminal{slice}, which is computed a subset of a slice or array object.
\nonterminal{postfix-expression} shall be of a slice or array type, and the
optional \nonterminal{simple-expression}s shall be assignable to
\nonterminal{size}.

\specsubsubitem
The first \nonterminal{simple-expression} shall compute value $L$, and the
second shall compute $H$. If absent, $L = 0$ and $H = \code{length}$, where
\code{length} shall be equal to the length of a bounded array type or the
length of a slice type, represented in either case by the result of
\nonterminal{postfix-expression}. If $H$ is not specified, and
\nonterminal{postfix-expression} is of an unbounded array type, the translation
environment shall abort.

\specsubsubitem
The resulting slice value shall have its \code{data} field set from, in the case
of an array type, the address of the array; or in the case of a slice type, the
\code{data} value of the source object; plus $L \times S$, where $S$ is the
size of the slice or array's secondary type.

\specsubsubitem
The resulting slice value shall have its \code{length} and \code{capacity}
fields set to $H - L$.

\specsubsubitem
The secondary type of the resulting slice type shall be equivalent to the
secondary type of the slice or array type given by
\nonterminal{postfix-expression}. The resulting slice type shall inherit the
\nonterminal{const} attribute from this type.

\specsubsection{Postfix expressions}

\begin{grammar}
\nonterminaldef{postfix-expression} \\
	\nonterminal{nested-expression} \\
	\nonterminal{assertion-expression} \\
	\nonterminal{call-expression} \\
	\nonterminal{field-access-expression} \\
	\nonterminal{indexing-expression} \\
	\nonterminal{measurement-expression} \\
	\nonterminal{slicing-expression} \\
\end{grammar}

\specsubsubitem
\nonterminal{postfix-expression} is an expression class for expressions whose
operators use postfix notation.

\specsubsection{Unary arithmetic}

\begin{grammar}
\nonterminaldef{unary-expression} \\
	\nonterminal{postfix-expression} \\
	\nonterminal{unary-operator} \nonterminal{unary-expression} \\

\nonterminaldef{unary-operator} \oneof \\
	\terminal{+}
	\terminal{-}
	\terminal{\textasciitilde}
	\terminal{!}
	\terminal{*}
	\terminal{\&}
\end{grammar}

% TODO: Consider removing unary +

\specsubsubitem
A unary expression applies a \nonterminal{unary-operator} to a single value.

\specsubsubitem
The \terminal{+} and \terminal{-} operators shall respectively perform unary
positive and unary negation operations. The result type shall be equivalent to
the type of \nonterminal{unary-expression}, which shall be of a signed numeric
type.

\specsubsubitem
The \terminal{\textasciitilde} operator shall perform a binary NOT operation,
inverting each bit of the value. Its result type shall be equivalent to the
type of \nonterminal{unary-expression}, which shall be of an unsigned integer
type.

\specsubsubitem
The \terminal{!} operator shall perform a logical NOT operation. The result
type, and the type of \nonterminal{unary-expression}, shall both be
\terminal{bool}. If the \nonterminal{unary-expression} is \terminal{true}, the
result shall be \terminal{false}, and vice-versa.

\specsubsubitem
The \terminal{*} operator shall dereference a pointer, and return the object it
references.  The type of \nonterminal{unary-expression} shall be a pointer
type, and the result type shall be the pointer's secondary type. The pointer
type shall not be \textit{nullable}.

\specsubsubitem
The \terminal{\&} operator shall take the address of an object. The result type
shall be a pointer whose secondary type is the type of
\nonterminal{unary-expression}.

\informative{The following table is informative.}

\begin{tabular}{r | l }
Operator & Meaning \\
\hline
\terminal{+} & Positive \\
\terminal{-} & Negation \\
\terminal{\textasciitilde} & Binary NOT \\
\terminal{!} & Logical NOT \\
\terminal{*} & Dereference pointer \\
\terminal{\&} & Take address \\
\end{tabular}

\specsubsection{Casts and type assertions}

\specsubsection{Multiplicative arithmetic}

\specsubsection{Additive arithmetic}

\specsubsection{Bit shifting arithmetic}

\specsubsection{Relational arithmetic}

\specsubsection{Equality}

\specsubsection{Bitwise arithmetic}

\specsubsection{Logical arithmetic}

\specsubsection{Scope expressions}

\specsubsection{If expressions}

\specsubsection{For loops}

\specsubsection{While loops}

\specsubsection{Match expressions}

\specsubsection{Switch expressions}

\specsubsection{Branching expressions}

\specsubsection{Assignment}

\specsubsection{Variable binding}

\specsubsection{Expression lists}

\specsubsection{Simple, complex, and compound expressions}
